// COMBINED FILE - GENERATED BY df_combinator v0.1.0
// DO NOT EDIT THIS FILE DIRECTLY. It is an amalgamation of multiple source files.
// Generated on: 2025-06-23 10:07:58.865151Z UTC

// --- Consolidated Imports ---
import 'dart:async' show Completer, FutureOr;
import 'dart:async' show FutureOr;
import 'dart:async';
import 'dart:collection' show Queue;
import 'dart:collection';
import 'dart:convert' show JsonEncoder;
import 'dart:convert' show jsonDecode;
import 'dart:convert';
import 'dart:io';
import 'package:df_safer_dart/df_safer_dart.dart';
import 'package:df_safer_dart_annotations/df_safer_dart_annotations.dart'
import 'package:df_safer_dart_annotations/df_safer_dart_annotations.dart' show noFuturesAllowed;
import 'package:df_safer_dart_annotations/df_safer_dart_annotations.dart' show unsafeOrError;
import 'package:df_safer_dart_annotations/df_safer_dart_annotations.dart';
import 'package:df_type/df_type.dart';
import 'package:equatable/equatable.dart' show Equatable;
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:meta/meta.dart' show protected;
import 'package:meta/meta.dart';
import 'package:path/path.dart' as p;
import 'package:stack_trace/stack_trace.dart';
import 'package:test/test.dart';
// --- End of Imports ---

// --------------------------------------------------
// Source: ./test/test_safe_completer.dart
// --------------------------------------------------
// --- AI GENERATED TEST ---

// import 'package:test/test.dart';
// import 'package:df_safer_dart/df_safer_dart.dart';

void main() {
  UNSAFE:
  {
    group('SafeCompleter Tests', () {
      test('should complete successfully with a synchronous value', () async {
        // Arrange
        final completer = SafeCompleter<int>();
        expect(
          completer.isCompleted,
          isFalse,
          reason: 'Completer should not be completed initially',
        );

        // Act
        completer.complete(42).end();

        // Assert
        expect(
          completer.isCompleted,
          isTrue,
          reason: 'Completer should be marked as completed',
        );
        final result = await completer.resolvable().value;
        expect(result, isA<Ok<int>>());
        expect(result.unwrap(), 42);
      });

      // THIS IS THE CORRECTED TEST
      test('should complete successfully with an asynchronous value', () async {
        // Arrange
        final completer = SafeCompleter<String>();
        final futureValue = Future.delayed(
          const Duration(milliseconds: 20),
          () => 'hello world',
        );

        // Act
        completer.complete(futureValue).end();

        // Assert: The completer is NOT yet complete because the future is still running.
        expect(
          completer.isCompleted,
          isFalse,
          reason: 'Completer is not completed until the future resolves',
        );

        // Await for the resolvable to finish, which internally completes the future.
        final result = await completer.resolvable().value;

        // Assert: NOW the completer should be marked as completed.
        expect(
          completer.isCompleted,
          isTrue,
          reason: 'Completer should be completed after awaiting the result',
        );
        expect(result, isA<Ok<String>>());
        expect(result.unwrap(), 'hello world');
      });

      test(
        'should complete with an error when resolve() is called with an Err',
        () async {
          // Arrange
          final completer = SafeCompleter<int>();
          final error = Err<int>('A deliberate test error');

          // Act
          completer.resolve(Sync.value(error)).end();

          // Assert
          expect(completer.isCompleted, isTrue);
          final resolvable = completer.resolvable();

          // Check that the resolvable completes with an error
          await expectLater(resolvable.value, completion(isA<Err>()));

          final result = await resolvable.value;
          expect((result as Err).error, 'A deliberate test error');
        },
      );

      // THIS IS THE CORRECTED TEST
      test('should complete with an error from a failing future', () async {
        // Arrange
        final completer = SafeCompleter<double>();
        final failingFuture = Future<double>.delayed(
          const Duration(milliseconds: 20),
          () => throw Exception('Network Failure'),
        );

        // Act
        completer.complete(failingFuture).end();

        // Assert: Not yet completed.
        expect(completer.isCompleted, isFalse);

        // Await the resolution.
        final resolvable = completer.resolvable();
        await expectLater(resolvable.value, completion(isA<Err>()));

        // Assert: Now it is completed (with an error).
        expect(completer.isCompleted, isTrue);

        final result = await resolvable.value;
        expect((result as Err).error, isA<Exception>());
        expect(
          (result.err().unwrap() as Exception).toString(),
          'Exception: Network Failure',
        );
      });

      test(
        'should prevent double completion and return an Err on the second attempt',
        () async {
          // Arrange
          final completer = SafeCompleter<String>();

          // Act: First, successful completion
          completer.complete('first value').end();
          expect(completer.isCompleted, isTrue);

          // Act: Second, failing completion attempt
          final secondAttemptResult = completer.complete('second value');

          // Assert
          expect(secondAttemptResult, isA<Sync<String>>());
          final result = secondAttemptResult.sync().unwrap().value;

          expect(
            result,
            isA<Err>(),
            reason: 'Second completion should result in an Err',
          );
          expect(
            (result as Err).error,
            'SafeCompleter<String> is already completed!',
          );

          // Verify that the original value remains unchanged
          final originalValue = await completer.resolvable().unwrap();
          expect(originalValue, 'first value');
        },
      );

      test(
        'should transform a successful value correctly using transf()',
        () async {
          // Arrange
          final intCompleter = SafeCompleter<int>();
          final stringCompleter = intCompleter.transf<String>(
            (i) => 'Value is $i',
          );

          // Act
          intCompleter.complete(123).end();

          // Assert
          final result = await stringCompleter.resolvable().value;
          expect(result, isA<Ok<String>>());
          expect(result.unwrap(), 'Value is 123');
        },
      );

      test(
        'should complete with an error if transf() causes a type cast failure',
        () async {
          // Arrange
          final intCompleter = SafeCompleter<int>();
          // Attempt to transform an int to a double without a converter function, which fails the `as` cast.
          final doubleCompleter = intCompleter.transf<double>();

          // Act
          intCompleter.complete(42).end();

          // Assert
          final result = await doubleCompleter.resolvable().value;
          expect(result, isA<Err>());
          expect(
            (result as Err).error,
            'Failed to transform type int to double.',
          );
        },
      );
    });
  }
}

// --------------------------------------------------
// Source: ./example/main.dart
// --------------------------------------------------
// import 'package:df_safer_dart/df_safer_dart.dart';
// import 'dart:convert';

typedef KeyValueMap = Map<String, dynamic>;

// A network call that can fail. Async handles both success and exceptions.
Async<String> fetchUserData(int userId) => Async(() async {
  await Future<void>.delayed(
    const Duration(milliseconds: 10),
  ); // Simulate network latency
  if (userId == 1) {
    return '{"config":{"notifications":{"sound":"chime.mp3"}}}';
  }
  if (userId == 2) {
    return '{"config":{}}';
  }
  if (userId == 3) {
    return '{"config": "bad_data"}';
  }
  throw Exception(
    'User Not Found',
  ); // This will be caught by Async and become an Err
});

// A parser that can fail. Sync automatically catches the jsonDecode exception.
Sync<KeyValueMap> parseJson(String json) =>
    Sync(() => jsonDecode(json) as KeyValueMap);

// A helper to safely extract a typed value. It cannot fail, it can only be absent,
// so it returns an Option.
Option<T> getFromMap<T extends Object>(KeyValueMap map, String key) {
  final value = map[key];
  return letAsOrNone<T>(value); // A safe-cast helper from the library
}

/// This is the logic pipeline. It reads like a description of the happy path.
/// There are no try-catch blocks and no null checks.
Async<Option<String>> getUserNotificationSound(int userId) {
  return fetchUserData(userId) // Starts with Async<String>
      .map(
        // The .unwrap() here will throw if parseJson created an Err.
        // The Async monad's .map will catch that throw and turn the
        // whole chain into an Err state.
        (jsonString) => UNSAFE(() => parseJson(jsonString).unwrap()),
      )
      .map(
        // This .map only runs if fetching and parsing were successful.
        (data) =>
            // Start the Option chain to safely drill into the data.
            // .flatMap is used to chain functions that return another Option.
            getFromMap<KeyValueMap>(data, 'config')
                .flatMap(
                  (config) => getFromMap<KeyValueMap>(config, 'notifications'),
                )
                .flatMap(
                  (notifications) => getFromMap<String>(notifications, 'sound'),
                ),
      );
}

void main() async {
  for (var id in [1, 2, 3, 4, 5]) {
    print('Processing User ID: $id');

    // Execute the pipeline. `await value` opens the Async box.
    final finalResult = await getUserNotificationSound(id).value;

    switch (finalResult) {
      case Ok(value: final optionSound):
        switch (optionSound) {
          // Success! The value is an Option<String>.
          // Now open the Option box.
          case Some(value: final sound):
            print('  -> Success: Sound setting is "$sound"\n');
          case None():
            print('  -> Success: Sound setting was not specified.\n');
        }
      case Err err:
        // The entire pipeline failed at some point.
        print('  -> Failure: An error occurred: ${err.error}\n');
    }
  }
}

// --------------------------------------------------
// Source: ./.github/scripts/update_readme.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'dart:io';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

void main(List<String> args) {
  if (args.length < 3) {
    print('Usage: dart run update_readme.dart <template_path> <package_name> <package_version>');
    exit(1);
  }

  final templatePath = args[0];
  final packageName = args[1];
  final packageVersion = args[2];

  // These paths are relative to where the script is run (the project root).
  final localContentPath = '_README_CONTENT.md';
  final finalReadmePath = 'README.md';

  // --- 1. Load the master template file from the path provided by the CI ---
  final templateFile = File(templatePath);
  if (!templateFile.existsSync()) {
    print('ERROR: Master README template not found at $templatePath');
    exit(1);
  }
  final readmeTemplate = templateFile.readAsStringSync();

  // --- 2. Load the local content file ---
  final localContentFile = File(localContentPath);
  if (!localContentFile.existsSync()) {
    print('INFO: No _README_CONTENT.md found for $packageName. Cannot generate README.');
    // Exit gracefully if there's no content to inject for this package.
    exit(0);
  }
  final localReadmeContent = localContentFile.readAsStringSync();

  // --- 3. Perform all replacements ---
  var finalContent = readmeTemplate.replaceAll('{{{PACKAGE}}}', packageName);
  finalContent = finalContent.replaceAll('{{{VERSION}}}', packageVersion);
  finalContent = finalContent.replaceAll('{{{_README_CONTENT}}}', localReadmeContent);

  // --- 4. Write the new README.md file ---
  final finalReadmeFile = File(finalReadmePath);
  finalReadmeFile.writeAsStringSync(finalContent);

  print('SUCCESS: README.md for $packageName v$packageVersion has been updated.');
}

// --------------------------------------------------
// Source: ./.github/scripts/update_changelog.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'dart:io';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

void main(List<String> args) {
  final version = args.isNotEmpty ? args[0] : '0.1.0';
  final comitMesssage = args.length > 1 ? args[1].replaceFirst(RegExp(r'^\++'), '') : '';
  final changelogPath = 'CHANGELOG.md';
  final file = File(changelogPath);
  if (!file.existsSync()) {
    print('$changelogPath does not exist.');
    exit(1);
  }
  var contents = file.readAsStringSync();
  contents = contents.replaceAll('# Changelog', '').trim();
  final sections = extractSections(contents);
  final versionExist = sections.where((e) => e.version == version).isNotEmpty;
  if (versionExist) {
    sections.where((e) => e.version == version).forEach((e) {
      e.addUpdate(comitMesssage);
    });
  } else {
    sections.add(
      _VersionSection(
        version: version,
        releasedAt: DateTime.now().toUtc(),
        updates: {comitMesssage},
      ),
    );
  }
  contents = '# Changelog\n\n${(sections.toList()..sort((a, b) {
      return compareVersions(b.version, a.version);
    })).map((e) => e.toString()).join('\n')}';

  file.writeAsStringSync(contents);
  print('Changelog updated with version $version.');
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

Set<_VersionSection> extractSections(String contents) {
  final headerPattern = RegExp(r'## \[\d+\.\d+\.\d+(\+\d+)?\]');
  final allVersionMatches = headerPattern.allMatches(contents).toList();
  final results = <_VersionSection>{};
  for (var i = 0; i < allVersionMatches.length; i++) {
    final start = allVersionMatches[i].end;
    final end = i + 1 < allVersionMatches.length ? allVersionMatches[i + 1].start : contents.length;
    final sectionContents = contents.substring(start, end).trim();
    final lines = sectionContents.split('\n').where((line) => line.isNotEmpty).toList();
    final version =
        allVersionMatches[i].group(0)!.substring(4, allVersionMatches[i].group(0)!.length - 1);
    var releasedAt = DateTime.now().toUtc();
    final updates = <String>{};
    final old = lines
        .map((e) => e.trim())
        .where((e) => e.isNotEmpty)
        .map((e) => e.startsWith('-') ? e.substring(1) : e)
        .map((e) => e.trim())
        .where((e) => e.isNotEmpty);
    for (var line in old) {
      if (line.contains('Released @')) {
        releasedAt = parseReleaseDate(line);
      } else {
        updates.add(line);
      }
    }
    results.add(_VersionSection(
      version: version,
      releasedAt: releasedAt,
      updates: updates,
    ));
  }

  return results;
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class _VersionSection {
  //
  //
  //

  String version;
  DateTime releasedAt;
  Set<String> updates;

  //
  //
  //

  _VersionSection({
    required this.version,
    required this.releasedAt,
    Set<String>? updates,
  }) : this.updates = updates ?? {};

  //
  //
  //

  void addUpdate(String update) {
    updates.add(update);
    releasedAt = DateTime.now().toUtc();
  }

  //
  //
  //

  @override
  String toString() {
    final updatesString = updates.map((update) => '- $update').join('\n');
    return '## [$version]\n\n- Released @ ${releasedAt.month}/${releasedAt.year} (UTC)\n$updatesString\n';
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

int compareVersions(String version1, String version2) {
  List<int> parseVersion(String version) {
    // Split by the '+' first to handle the build number
    final parts = version.split('+');
    final versionParts = parts[0].split('.').map(int.tryParse).map((e) => e ?? 0).toList();
    // Add the build number as the last part (if it exists)
    if (parts.length > 1) {
      versionParts.add(int.tryParse(parts[1]) ?? 0);
    }
    return versionParts;
  }

  final v1 = parseVersion(version1);
  final v2 = parseVersion(version2);
  final maxLength = v1.length > v2.length ? v1.length : v2.length;
  for (var i = 0; i < maxLength; i++) {
    final part1 = i < v1.length ? v1[i] : 0;
    final part2 = i < v2.length ? v2[i] : 0;
    if (part1 > part2) return 1;
    if (part1 < part2) return -1;
  }
  return 0;
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

DateTime parseReleaseDate(String line) {
  if (line.contains('Released @')) {
    final temp = line.split('Released @').last.trim().replaceAll(' (UTC)', '');
    final parts = temp.split('/');
    if (parts.length == 2) {
      final month = int.tryParse(parts[0]) ?? 1;
      final year = int.tryParse(parts[1]) ?? DateTime.now().year;
      return DateTime.utc(year, month);
    }
  }

  return DateTime.now().toUtc();
}

// --------------------------------------------------
// Source: ./lib/df_safer_dart.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

/// A package inspired by functional programming designed to enhance the structure, safety, and debuggability of your applications.
library;

export 'src/_src.g.dart';

// --------------------------------------------------
// Source: ./lib/src/swap/swap_err.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $ErrSyncSwapX<T extends Object> on Err<Sync<T>> {
  @pragma('vm:prefer-inline')
  Sync<Err<T>> swap() => transfErr<T>().wrapSync();
}

extension $ErrAsyncSwapX<T extends Object> on Err<Async<T>> {
  @pragma('vm:prefer-inline')
  Async<Err<T>> swap() => transfErr<T>().wrapAsync();
}

extension $ErrResolvableSwapX<T extends Object> on Err<Resolvable<T>> {
  @pragma('vm:prefer-inline')
  Resolvable<Err<T>> swap() => transfErr<T>().wrapSync();
}

extension $ErrOptionSwapX<T extends Object> on Err<Option<T>> {
  @pragma('vm:prefer-inline')
  Option<Err<T>> swap() => Some(transfErr<T>());
}

extension $ErrSomeSwapX<T extends Object> on Err<Some<T>> {
  @pragma('vm:prefer-inline')
  Some<Err<T>> swap() => Some(transfErr<T>());
}

extension $ErrNoneSwapX<T extends Object> on Err<None<T>> {
  @pragma('vm:prefer-inline')
  None<Err<T>> swap() => const None();
}

extension $ErrResultSwapX<T extends Object> on Err<Result<T>> {
  @pragma('vm:prefer-inline')
  Result<Err<T>> swap() => Ok(transfErr<T>());
}

extension $ErrOkSwapX<T extends Object> on Err<Ok<T>> {
  @pragma('vm:prefer-inline')
  Ok<Err<T>> swap() => Ok(transfErr<T>());
}

// --------------------------------------------------
// Source: ./lib/src/swap/swap_async.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $AsyncSomeSwapX<T extends Object> on Async<Some<T>> {
  @pragma('vm:prefer-inline')
  Some<Async<T>> swap() => Some(map((e) => e.unwrap()));
}

extension $AsyncNoneSwapX<T extends Object> on Async<None<T>> {
  @pragma('vm:prefer-inline')
  None<Async<T>> swap() => const None();
}

extension $AsyncOkSwapX<T extends Object> on Async<Ok<T>> {
  @pragma('vm:prefer-inline')
  Ok<Async<T>> swap() => Ok(map((e) => e.unwrap()));
}

// --------------------------------------------------
// Source: ./lib/src/swap/swap_result.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $ResultSyncSwapX<T extends Object> on Result<Sync<T>> {
  @pragma('vm:prefer-inline')
  Sync<Result<T>> swap() {
    if (this is Ok<Sync<T>>) {
      return (this as Ok<Sync<T>>).swap();
    }
    return (this as Err<Sync<T>>).swap();
  }
}

extension $ResultAsyncSwapX<T extends Object> on Result<Async<T>> {
  @pragma('vm:prefer-inline')
  Async<Result<T>> swap() {
    if (this is Ok<Async<T>>) {
      return (this as Ok<Async<T>>).swap();
    }
    return (this as Err<Async<T>>).swap();
  }
}

extension $ResultResolvableSwapX<T extends Object> on Result<Resolvable<T>> {
  @pragma('vm:prefer-inline')
  Resolvable<Result<T>> swap() {
    if (this is Ok<Resolvable<T>>) {
      return (this as Ok<Resolvable<T>>).swap();
    }
    return (this as Err<Resolvable<T>>).swap();
  }
}

extension $ResultOptionSwapX<T extends Object> on Result<Option<T>> {
  @pragma('vm:prefer-inline')
  Option<Result<T>> swap() {
    if (this is Ok<Option<T>>) {
      return (this as Ok<Option<T>>).swap();
    }
    return (this as Err<Option<T>>).swap();
  }
}

extension $ResultSomeSwapX<T extends Object> on Result<Some<T>> {
  @pragma('vm:prefer-inline')
  Some<Result<T>> swap() {
    if (this is Ok<Some<T>>) {
      return (this as Ok<Some<T>>).swap();
    }
    return (this as Err<Some<T>>).swap();
  }
}

extension $ResultNoneSwapX<T extends Object> on Result<None<T>> {
  @pragma('vm:prefer-inline')
  Option<Result<T>> swap() {
    if (this is Ok<None<T>>) {
      return (this as Ok<None<T>>).swap();
    }
    return (this as Err<None<T>>).swap();
  }
}

extension $ResultOkSwapX<T extends Object> on Result<Ok<T>> {
  @pragma('vm:prefer-inline')
  Ok<Result<T>> swap() {
    if (this is Ok<Ok<T>>) {
      return this as Ok<Ok<T>>;
    }
    return (this as Err<Ok<T>>).swap();
  }
}

extension $ResultErrSwapX<T extends Object> on Result<Err<T>> {
  @pragma('vm:prefer-inline')
  Result<T> swap() {
    if (this is Ok<Err<T>>) {
      return (this as Ok<Err<T>>).unwrap();
    }
    return (this as Err<Err<T>>).transfErr();
  }
}

// --------------------------------------------------
// Source: ./lib/src/swap/swap_ok.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $OkSyncSwapX<T extends Object> on Ok<Sync<T>> {
  @pragma('vm:prefer-inline')
  Sync<Ok<T>> swap() => unwrap().map((e) => Ok(e));
}

extension $OkAsyncSwapX<T extends Object> on Ok<Async<T>> {
  @pragma('vm:prefer-inline')
  Async<Ok<T>> swap() => unwrap().map((e) => Ok(e));
}

extension $OkResolvableSwapX<T extends Object> on Ok<Resolvable<T>> {
  @pragma('vm:prefer-inline')
  Resolvable<Ok<T>> swap() => unwrap().map((e) => Ok(e));
}

extension $OkOptionSwapX<T extends Object> on Ok<Option<T>> {
  @pragma('vm:prefer-inline')
  Option<Ok<T>> swap() => unwrap().map((e) => Ok(e));
}

extension $OkSomeSwapX<T extends Object> on Ok<Some<T>> {
  @pragma('vm:prefer-inline')
  Some<Ok<T>> swap() => unwrap().map((e) => Ok(e));
}

extension $OkNoneSwapX<T extends Object> on Ok<None<T>> {
  @pragma('vm:prefer-inline')
  None<Ok<T>> swap() => const None();
}

extension $OkResultSwapX<T extends Object> on Ok<Result<T>> {
  @pragma('vm:prefer-inline')
  Result<Ok<T>> swap() => unwrap().map((e) => Ok(e));
}

extension $OkErrSwapX<T extends Object> on Ok<Err<T>> {
  @pragma('vm:prefer-inline')
  Err<Ok<T>> swap() => unwrap().transfErr<Ok<T>>();
}

// --------------------------------------------------
// Source: ./lib/src/swap/swap_resolvable.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $ResolvableSomeSwapX<T extends Object> on Resolvable<Some<T>> {
  @pragma('vm:prefer-inline')
  Some<Resolvable<T>> swap() {
    if (this is Sync<Some<T>>) {
      return (this as Sync<Some<T>>).swap();
    }
    return (this as Async<Some<T>>).swap();
  }
}

extension $ResolvableNoneSwapX<T extends Object> on Resolvable<None<T>> {
  @pragma('vm:prefer-inline')
  None<Resolvable<T>> swap() => const None();
}

extension $ResolvableOkSwapX<T extends Object> on Resolvable<Ok<T>> {
  @pragma('vm:prefer-inline')
  Ok<Resolvable<T>> swap() {
    return Ok(map((e) => e.unwrap()));
  }
}

// --------------------------------------------------
// Source: ./lib/src/swap/swap_some.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $SomeSyncSwapX<T extends Object> on Some<Sync<T>> {
  @pragma('vm:prefer-inline')
  Sync<Some<T>> swap() => unwrap().map((e) => Some(e));
}

extension $SomeAsyncSwapX<T extends Object> on Some<Async<T>> {
  @pragma('vm:prefer-inline')
  Async<Some<T>> swap() => unwrap().map((e) => Some(e));
}

extension $SomeResolvableSwapX<T extends Object> on Some<Resolvable<T>> {
  @pragma('vm:prefer-inline')
  Resolvable<Some<T>> swap() => unwrap().map((e) => Some(e));
}

extension $SomeOptionSwapX<T extends Object> on Some<Option<T>> {
  @pragma('vm:prefer-inline')
  Option<Some<T>> swap() => unwrap().map((e) => Some(e));
}

extension $SomeNoneSwapX<T extends Object> on Some<None<T>> {
  @pragma('vm:prefer-inline')
  None<Some<T>> swap() => const None();
}

extension $SomeResultSwapX<T extends Object> on Some<Result<T>> {
  @pragma('vm:prefer-inline')
  Result<Some<T>> swap() => unwrap().map((e) => Some(e));
}

extension $SomeOkSwapX<T extends Object> on Some<Ok<T>> {
  @pragma('vm:prefer-inline')
  Ok<Some<T>> swap() => Ok(Some(unwrap().unwrap()));
}

extension $SomeErrSwapX<T extends Object> on Some<Err<T>> {
  @pragma('vm:prefer-inline')
  Err<Some<T>> swap() => unwrap().transfErr<Some<T>>();
}

// --------------------------------------------------
// Source: ./lib/src/swap/swap_sync.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $SyncAsyncSwapX<T extends Object> on Sync<Async<T>> {
  @pragma('vm:prefer-inline')
  Async<Sync<T>> swap() {
    switch (value) {
      case Ok(value: final asyncValue):
        return Async(() async {
          final innerResult = await asyncValue.value;
          return Sync.unsafe(innerResult);
        });
      case final Err<Async<T>> err:
        final failedSync = Sync.unsafe(err.transfErr<T>());
        return Async.unsafe(Future.value(Ok(failedSync)));
    }
  }
}

extension $SyncResolvableSwapX<T extends Object> on Sync<Resolvable<T>> {
  @pragma('vm:prefer-inline')
  Resolvable<Sync<T>> swap() {
    switch (value) {
      case Ok(value: final resolvableValue):
        switch (resolvableValue) {
          case Sync(value: final syncValue):
            return Sync.unsafe(Ok(Sync.unsafe(syncValue)));
          case Async(value: final asyncValue):
            return Async<Sync<T>>(() async {
              final result = await asyncValue;
              return Sync.unsafe(result);
            });
        }
      case final Err<Resolvable<T>> err:
        final failedSync = Sync.unsafe(err.transfErr<T>());
        return Sync.unsafe(Ok(failedSync));
    }
  }
}

extension $SyncOptionSwapX<T extends Object> on Sync<Option<T>> {
  @pragma('vm:prefer-inline')
  Option<Sync<T>> swap() {
    switch (value) {
      case Ok(value: final optionValue):
        switch (optionValue) {
          case Some(value: final someValue):
            return Sync.unsafe(Ok(someValue)).wrapSome();
          case None():
            return const None();
        }
      case final Err<Option<T>> err:
        return Sync.unsafe(err.transfErr<T>()).wrapSome();
    }
  }
}

extension $SyncSomeSwapX<T extends Object> on Sync<Some<T>> {
  @pragma('vm:prefer-inline')
  Some<Sync<T>> swap() => map((e) => e.unwrap()).wrapSome();
}

extension $SyncNoneSwapX<T extends Object> on Sync<None<T>> {
  @pragma('vm:prefer-inline')
  None<Sync<T>> swap() => const None();
}

extension $SyncResultSwapX<T extends Object> on Sync<Result<T>> {
  @pragma('vm:prefer-inline')
  Result<Sync<T>> swap() {
    switch (value) {
      case Ok(value: final resultValue):
        switch (resultValue) {
          case Ok(value: final okValue):
            return Sync.unsafe(Ok(okValue)).wrapOk();
          case final Err<T> err:
            return err.transfErr<Sync<T>>();
        }
      case final Err<Result<T>> err:
        return err.transfErr<Sync<T>>();
    }
  }
}

extension $SyncOkSwapX<T extends Object> on Sync<Ok<T>> {
  @pragma('vm:prefer-inline')
  Ok<Sync<T>> swap() => Ok(Sync.unsafe(Ok(value.unwrap().unwrap())));
}

extension $SyncErrSwapX<T extends Object> on Sync<Err<T>> {
  @pragma('vm:prefer-inline')
  Err<Sync<T>> swap() => value.unwrap().transfErr<Sync<T>>();
}

// --------------------------------------------------
// Source: ./lib/src/swap/swap_none.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $NoneSyncSwapX<T extends Object> on None<Sync<T>> {
  @pragma('vm:prefer-inline')
  Sync<None<T>> swap() => None<T>().wrapSync();
}

extension $NoneAsyncSwapX<T extends Object> on None<Async<T>> {
  @pragma('vm:prefer-inline')
  Async<None<T>> swap() => None<T>().wrapAsync();
}

extension $NoneResolvableSwapX<T extends Object> on None<Resolvable<T>> {
  @pragma('vm:prefer-inline')
  Resolvable<None<T>> swap() => None<T>().wrapResolvable();
}

extension $NoneOptionSwapX<T extends Object> on None<Option<T>> {
  @pragma('vm:prefer-inline')
  Option<None<T>> swap() => const Some(None());
}

extension $NoneSomeSwapX<T extends Object> on None<Some<T>> {
  @pragma('vm:prefer-inline')
  Some<None<T>> swap() => const Some(None());
}

extension $NoneResultSwapX<T extends Object> on None<Result<T>> {
  @pragma('vm:prefer-inline')
  Result<None<T>> swap() => const Ok(None());
}

extension $NoneOkSwapX<T extends Object> on None<Ok<T>> {
  @pragma('vm:prefer-inline')
  Ok<None<T>> swap() => const Ok(None());
}

extension $NoneErrSwapX<T extends Object> on None<Err<T>> {
  @pragma('vm:prefer-inline')
  Err<None<T>> swap() {
    return Err(const None());
  }
}

// --------------------------------------------------
// Source: ./lib/src/swap/swap_option.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $OptionSyncSwapX<T extends Object> on Option<Sync<T>> {
  @pragma('vm:prefer-inline')
  Sync<Option<T>> swap() {
    if (this is Some<Sync<T>>) {
      return (this as Some<Sync<T>>).swap();
    }
    return (this as None<Sync<T>>).swap();
  }
}

extension $OptionAsyncSwapX<T extends Object> on Option<Async<T>> {
  @pragma('vm:prefer-inline')
  Async<Option<T>> swap() {
    if (this is Some<Async<T>>) {
      return (this as Some<Async<T>>).swap();
    }
    return (this as None<Async<T>>).swap();
  }
}

extension $OptionResolvableSwapX<T extends Object> on Option<Resolvable<T>> {
  @pragma('vm:prefer-inline')
  Resolvable<Option<T>> swap() {
    if (this is Some<Resolvable<T>>) {
      return (this as Some<Resolvable<T>>).swap();
    }
    return (this as None<Resolvable<T>>).swap();
  }
}

extension $OptionSomeSwapX<T extends Object> on Option<Some<T>> {
  @pragma('vm:prefer-inline')
  Some<Option<T>> swap() {
    if (this is Some<Some<T>>) {
      return this as Some<Some<T>>;
    }
    return (this as None<Some<T>>).swap();
  }
}

extension $OptionNoneSwapX<T extends Object> on Option<None<T>> {
  @pragma('vm:prefer-inline')
  None<Option<T>> swap() {
    return const None();
  }
}

extension $OptionResultSwapX<T extends Object> on Option<Result<T>> {
  @pragma('vm:prefer-inline')
  Result<Option<T>> swap() {
    if (this is Some<Result<T>>) {
      return (this as Some<Result<T>>).swap();
    }
    return (this as None<Result<T>>).swap();
  }
}

extension $OptionOkSwapX<T extends Object> on Option<Ok<T>> {
  @pragma('vm:prefer-inline')
  Ok<Option<T>> swap() {
    if (this is Some<Result<T>>) {
      return (this as Some<Ok<T>>).swap();
    }
    return (this as None<Ok<T>>).swap();
  }
}

extension $OptionErrSwapX<T extends Object> on Option<Err<T>> {
  @pragma('vm:prefer-inline')
  Err<Option<T>> swap() {
    if (this is Some<Result<T>>) {
      return (this as Some<Err<T>>).swap();
    }
    return (this as None<Err<T>>).swap();
  }
}

// --------------------------------------------------
// Source: ./lib/src/utils/safe_completer.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'dart:async' show Completer, FutureOr;

// import 'package:df_safer_dart_annotations/df_safer_dart_annotations.dart'
    show noFuturesAllowed;

// import '../monads/monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class SafeCompleter<T extends Object> {
  //
  //
  //

  final _completer = Completer<T>();
  Option<FutureOr<T>> _value = const None();
  bool _isResolving = false;

  //
  //
  //

  /// Completes the operation with the provided [resolvable].
  Resolvable<T> resolve(Resolvable<T> resolvable) {
    if (_isResolving) {
      return Sync.unsafe(Err('SafeCompleter<$T> is already resolving!'));
    }
    _isResolving = true;
    if (isCompleted) {
      return Sync.unsafe(Err('SafeCompleter<$T> is already completed!'));
    }

    return resolvable.resultMap((e) {
      // Use a switch on the Result 'e' for exhaustive, safe handling.
      switch (e) {
        case Ok(value: final value):
          _value = Some(value);
          _completer.complete(value);
          _isResolving = false;
          return e;
        case Err():
          _completer.completeError(e);
          _isResolving = false;
          return e;
      }
    });
  }

  /// Completes the operation with the provided [value].
  @pragma('vm:prefer-inline')
  Resolvable<T> complete(FutureOr<T> value) => resolve(Resolvable(() => value));

  /// Returns a [Resolvable] that will complete when this [SafeCompleter] is
  /// completed.
  @pragma('vm:prefer-inline')
  Resolvable<T> resolvable() {
    return Resolvable(() {
      // Use a switch on the Option '_value' for clear and safe state checking.
      switch (_value) {
        case Some(value: final v):
          return v;
        case None():
          return _completer.future;
      }
    });
  }

  /// Checks if the value has been set or if the [SafeCompleter] is completed.
  @pragma('vm:prefer-inline')
  bool get isCompleted => _completer.isCompleted || _value.isSome();

  /// Transforms the type of the value managed by this [SafeCompleter].
  SafeCompleter<R> transf<R extends Object>([
    @noFuturesAllowed R Function(T e)? noFuturesAllowed,
  ]) {
    final completer = SafeCompleter<R>();
    resolvable().map((e) {
      try {
        final result = noFuturesAllowed != null
            ? noFuturesAllowed(e)
            : (e as R);
        completer.resolve(Sync<R>.unsafe(Ok(result))).end();
      } catch (e) {
        completer
            .resolve(Sync.unsafe(Err('Failed to transform type $T to $R.')))
            .end();
      }
      return e;
    }).end();
    return completer;
  }
}

// --------------------------------------------------
// Source: ./lib/src/utils/safer_map.dart
// --------------------------------------------------
// ignore_for_file: must_use_unsafe_wrapper_or_error
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '../monads/monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $NoneIfEmptyOnMapExtension<K, V> on Map<K, V> {
  /// Returns this map wrapped in a [Some] if it's not empty,
  /// otherwise returns [None].
  Option<Map<K, V>> get noneIfEmpty {
    return isEmpty ? const None() : Some(this);
  }
}

extension $GetOptionOnMapExtension<K, V extends Object> on Map<K, V> {
  /// Safely gets the value for a given [key], returning an [Option<V>].
  Option<V> getOption(K key) {
    if (containsKey(key)) {
      return Some(this[key]!);
    }
    return const None();
  }
}

extension $NonNoneValuesOnMapExtension<K, V extends Object> on Map<K, Option<V>> {
  /// **Filters.** Returns a new map containing only entries where the value is a [Some].
  Map<K, V> get nonNoneValues => Map.fromEntries(
        entries.where((e) => e.value.isSome()).map(
              (e) => MapEntry(e.key, e.value.unwrap()),
            ),
      );

  /// **Combines.** If all values are [Some], returns a `Some<Map<K, V>>`.
  /// If any value is [None], returns [None].
  Option<Map<K, V>> get nonNoneAll {
    final buffer = <K, V>{};
    for (final entry in entries) {
      if (entry.value.isNone()) return const None();
      buffer[entry.key] = entry.value.unwrap();
    }
    return Some(buffer);
  }
}

extension $NonNoneKeysOnMapExtension<K extends Object, V> on Map<Option<K>, V> {
  /// **Filters.** Returns a new map containing only entries where the key is a [Some].
  Map<K, V> get nonNoneKeys => Map.fromEntries(
        entries.where((e) => e.key.isSome()).map(
              (e) => MapEntry(e.key.unwrap(), e.value),
            ),
      );

  /// **Combines.** If all keys are [Some], returns a `Some<Map<K, V>>`.
  /// If any key is [None], returns [None].
  Option<Map<K, V>> get nonNoneAll {
    final buffer = <K, V>{};
    for (final entry in entries) {
      if (entry.key.isNone()) return const None();
      buffer[entry.key.unwrap()] = entry.value;
    }
    return Some(buffer);
  }
}

extension $NonNoneOnMapExtension<K extends Object, V extends Object> on Map<Option<K>, Option<V>> {
  /// **Filters.** Returns a new map containing only entries where both key and value are [Some].
  Map<K, V> get nonNone => Map.fromEntries(
        entries.where((e) => e.key.isSome() && e.value.isSome()).map(
              (e) => MapEntry(e.key.unwrap(), e.value.unwrap()),
            ),
      );

  /// **Combines.** If all keys and values are [Some], returns a `Some<Map<K, V>>`.
  /// If any key or value is [None], returns [None].
  Option<Map<K, V>> get nonNoneAll {
    final buffer = <K, V>{};
    for (final entry in entries) {
      if (entry.key.isNone() || entry.value.isNone()) return const None();
      buffer[entry.key.unwrap()] = entry.value.unwrap();
    }
    return Some(buffer);
  }
}

extension $NonErrValuesOnMapExtension<K, V extends Object> on Map<K, Result<V>> {
  /// **Filters.** Returns a new map containing only entries where the value is an [Ok].
  Map<K, V> get nonErrValues => Map.fromEntries(
        entries.where((e) => e.value.isOk()).map(
              (e) => MapEntry(e.key, e.value.unwrap()),
            ),
      );

  /// **Combines.** If all values are [Ok], returns a `Result<Map<K, V>>`.
  /// If any value is an [Err], returns the first [Err] found.
  Result<Map<K, V>> get nonErrAll {
    final buffer = <K, V>{};
    for (final entry in entries) {
      if (entry.value.isErr()) return entry.value.err().unwrap().transfErr();
      buffer[entry.key] = entry.value.unwrap();
    }
    return Ok(buffer);
  }
}

extension $NonErrKeysOnMapExtension<K extends Object, V> on Map<Result<K>, V> {
  /// **Filters.** Returns a new map containing only entries where the key is an [Ok].
  Map<K, V> get nonErrKeys => Map.fromEntries(
        entries.where((e) => e.key.isOk()).map(
              (e) => MapEntry(e.key.unwrap(), e.value),
            ),
      );

  /// **Combines.** If all keys are [Ok], returns a `Result<Map<K, V>>`.
  /// If any key is an [Err], returns the first [Err] found.
  Result<Map<K, V>> get nonErrAll {
    final buffer = <K, V>{};
    for (final entry in entries) {
      if (entry.key.isErr()) return entry.key.err().unwrap().transfErr();
      buffer[entry.key.unwrap()] = entry.value;
    }
    return Ok(buffer);
  }
}

extension $NonErrOnMapExtension<K extends Object, V extends Object> on Map<Result<K>, Result<V>> {
  /// **Filters.** Returns a new map containing only entries where both key and value are [Ok].
  Map<K, V> get nonErr => Map.fromEntries(
        entries.where((e) => e.key.isOk() && e.value.isOk()).map(
              (e) => MapEntry(e.key.unwrap(), e.value.unwrap()),
            ),
      );

  /// **Combines.** If all keys and values are [Ok], returns a `Result<Map<K, V>>`.
  /// If any key or value is an [Err], returns the first [Err] found.
  Result<Map<K, V>> get nonErrAll {
    final buffer = <K, V>{};
    for (final entry in entries) {
      if (entry.key.isErr()) return entry.key.err().unwrap().transfErr();
      if (entry.value.isErr()) return entry.value.err().unwrap().transfErr();
      buffer[entry.key.unwrap()] = entry.value.unwrap();
    }
    return Ok(buffer);
  }
}

// --------------------------------------------------
// Source: ./lib/src/utils/unit.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:equatable/equatable.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A type representing a "no value" unit, similar to `void` but usable in
/// generics.
final class Unit implements Equatable {
  const Unit._();

  @pragma('vm:prefer-inline')
  factory Unit() => instance;

  static const Unit instance = Unit._();
  static const Unit i = instance;

  @override
  List<Object?> get props => [];

  @override
  String toString() => 'Unit()';

  @override
  bool? get stringify => false;
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

const UNIT = Unit.instance;

// --------------------------------------------------
// Source: ./lib/src/utils/safer_string.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '../monads/monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $SaferString on String {
  // Returns this string wrapped in a [Some] if it's not empty,
  /// otherwise returns [None].
  Option<String> get noneIfEmpty {
    return Option.from(isEmpty ? null : this);
  }

  /// Returns the first character as a [Some], or [None] if the string is empty.
  Option<String> get firstOrNone => isEmpty ? const None() : Some(this[0]);

  /// Returns the last character as a [Some], or [None] if the string is empty.
  Option<String> get lastOrNone => isEmpty ? const None() : Some(this[length - 1]);

  /// Returns the character at the given [index] as a [Some], or [None] if the
  /// index is out of bounds.
  Option<String> elementAtOrNone(int index) {
    if (index < 0 || index >= length) {
      return const None();
    }
    return Some(this[index]);
  }
}

// --------------------------------------------------
// Source: ./lib/src/utils/safe_sequencer.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import 'dart:collection' show Queue;

// import 'package:df_safer_dart_annotations/df_safer_dart_annotations.dart' show noFuturesAllowed;

// import '/df_safer_dart.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class SafeSequencer<T extends Object> {
  final _TOnPrevErr? _onPrevErr;
  final bool _eagerError;
  Resolvable<Option<T>> get current => _current;
  late var _current = Resolvable<Option<T>>(() => const None());
  bool _isExecutingHandler = false;
  final _reentrantQueue = Queue<_Task<T>>();

  SafeSequencer({
    _TOnPrevErr? onPrevErr,
    bool eagerError = false,
  })  : _onPrevErr = onPrevErr,
        _eagerError = eagerError;

  @pragma('vm:prefer-inline')
  Resolvable<Option<T>> get last => pushTask((e) => Sync.unsafe(e));

  /// Pushes a new task onto the end of the sequence.
  Resolvable<Option<T>> pushTask(
    @noFuturesAllowed _THandler<T> handler, {
    _TOnPrevErr? onPrevErr,
    bool? eagerError,
  }) {
    final task = _Task<T>(
      handler: handler,
      onPrevErr: onPrevErr,
      eagerError: eagerError,
    );
    if (_isExecutingHandler) {
      _reentrantQueue.add(task);
      return _current;
    }
    // Chain the new task onto the sequence.
    return _chainTask(task);
  }

  /// The **Scheduler**. Its role is to determine *when* to execute the next
  /// task, handling the sync/async nature of the sequence's current state.
  Resolvable<Option<T>> _chainTask(_Task<T> task) {
    final value = _current.value;

    if (value is Future<Result<Option<T>>>) {
      // Async Path: Schedule the next step to execute after the current Future completes.
      _current = Async(() async => _executeStep(task, await value)).flatten();
    } else {
      // Sync Path: Execute the next step immediately with the current value.
      _current = _executeStep(task, value);
    }
    return _current;
  }

  /// The **Executor**. Its role is to take the resolved value from the previous
  /// step and run the logic for the current task.
  Resolvable<Option<T>> _executeStep(
    _Task<T> task,
    Result<Option<T>> previousResult,
  ) {
    // Check if the previous step resulted in an error.
    switch (previousResult) {
      case Err err:
        _onPrevErr?.call(err);
        task.onPrevErr?.call(err);
        // If eager error is enabled, halt the chain by returning the current
        // state (which holds the error we just received) instead of executing
        // the next handler.
        if (task.eagerError ?? _eagerError) {
          return _current;
        }
      default:
      // No error, or not in eager mode, so proceed to execution.
    }
    // Execute the handler for the current task.
    return _executeHandler(task.handler, previousResult) ?? _current;
  }

  /// Safely executes the handler, managing re-entrant state.
  Resolvable<Option<T>>? _executeHandler(
    _THandler<T> handler,
    Result<Option<T>> previousValue,
  ) {
    _isExecutingHandler = true;
    try {
      return handler(previousValue);
    } finally {
      _isExecutingHandler = false;
      _processReentrantQueue();
    }
  }

  /// Processes tasks that were queued while a handler was executing.
  void _processReentrantQueue() {
    while (_reentrantQueue.isNotEmpty) {
      final task = _reentrantQueue.removeFirst();
      pushTask(
        task.handler,
        onPrevErr: task.onPrevErr,
        eagerError: task.eagerError,
      ).end();
    }
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

typedef _THandler<T extends Object> = Resolvable<Option<T>>? Function(Result<Option<T>> previous);

typedef _TOnPrevErr = void Function(Err err);

final class _Task<T extends Object> {
  final _THandler<T> handler;
  final _TOnPrevErr? onPrevErr;
  final bool? eagerError;

  const _Task({
    required this.handler,
    required this.onPrevErr,
    required this.eagerError,
  });
}

// --------------------------------------------------
// Source: ./lib/src/utils/safer_iterable.dart
// --------------------------------------------------
// ignore_for_file: must_use_unsafe_wrapper_or_error
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'dart:collection' show Queue;

// import '../monads/monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $SaferIterableExtension<E extends Object> on Iterable<E> {
  /// Returns this [Iterable] wrapped in a [Some] if it's not empty,
  /// otherwise returns [None].
  Option<Iterable<E>> get noneIfEmpty => isEmpty ? const None() : Some(this);

  /// Returns the first element as a [Some], or [None] if the [Iterable] is empty.
  Option<E> get firstOrNone {
    final it = iterator;
    return it.moveNext() ? Some(it.current) : const None();
  }

  /// Returns the last element as a [Some], or [None] if the [Iterable] is empty.
  Option<E> get lastOrNone {
    if (isEmpty) return const None();
    return Some(last);
  }

  /// Returns the single element as a [Some], or [None] if the [Iterable] does
  /// not contain exactly one element.
  Option<E> get singleOrNone {
    final it = iterator;
    if (it.moveNext()) {
      final result = it.current;
      if (!it.moveNext()) {
        return Some(result);
      }
    }
    return const None();
  }

  /// Returns the first element satisfying [test] as a [Some], or [None].
  Option<E> firstWhereOrNone(bool Function(E element) test) {
    for (final element in this) {
      if (test(element)) return Some(element);
    }
    return const None();
  }

  /// Returns the last element satisfying [test] as a [Some], or [None].
  Option<E> lastWhereOrNone(bool Function(E element) test) {
    late E result;
    var found = false;
    for (final element in this) {
      if (test(element)) {
        result = element;
        found = true;
      }
    }
    return found ? Some(result) : const None();
  }

  /// Returns the single element satisfying [test] as a [Some], or [None].
  Option<E> singleWhereOrNone(bool Function(E element) test) {
    late E result;
    var found = false;
    for (final element in this) {
      if (test(element)) {
        if (found) return const None(); // Found more than one
        result = element;
        found = true;
      }
    }
    return found ? Some(result) : const None();
  }

  /// Reduces the collection to a single value by iteratively combining elements.
  /// Returns the result as a [Some], or [None] if the [Iterable] is empty.
  Option<E> reduceOrNone(E Function(E value, E element) combine) {
    if (isEmpty) return const None();
    return Some(reduce(combine));
  }

  /// Returns the element at the given [index] as a [Some], or [None] if the
  /// index is out of bounds.
  Option<E> elementAtOrNone(int index) {
    if (index < 0) return const None();
    var i = 0;
    for (final element in this) {
      if (i == index) return Some(element);
      i++;
    }
    return const None();
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $NonNoneOnIterableExtension<E extends Object> on Iterable<Option<E>> {
  /// Returns a new [Iterable] containing only the values from [Some] elements.
  Iterable<E> get nonNone => where((e) => e.isSome()).map((e) => e.unwrap());

  /// If all elements are [Some], returns a `Some<List<E>>` containing all
  /// unwrapped values. If even one element is [None], returns [None].
  Option<List<E>> get noneNoneAll {
    final buffer = <E>[];
    for (final e in this) {
      if (e.isNone()) return const None();
      buffer.add(e.unwrap());
    }
    return Some(buffer);
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $NonErrOnIterableExtension<E extends Object> on Iterable<Result<E>> {
  /// Returns a new [Iterable] containing only the values from [Ok] elements.
  Iterable<E> get nonErr => where((e) => e.isOk()).map((e) => e.unwrap());

  /// If all elements are [Ok], returns a `Some<List<E>>` containing all
  /// unwrapped values. If even one element is [None], returns [None].
  Option<List<E>> get nonErrAll {
    final buffer = <E>[];
    for (final e in this) {
      if (e.isErr()) return const None();
      buffer.add(e.unwrap());
    }
    return Some(buffer);
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $NoneIfEmptyOnListExtension<E extends Object> on List<E> {
  /// Returns this list wrapped in a [Some] if it's not empty, otherwise
  /// returns [None].
  Option<List<E>> get noneIfEmpty => isEmpty ? const None() : Some(this);
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $NoneIfEmptyOnSetExtension<E extends Object> on Set<E> {
  /// Returns this set wrapped in a [Some] if it's not empty, otherwise returns
  /// [None].
  Option<Set<E>> get noneIfEmpty => isEmpty ? const None() : Some(this);
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $NoneIfEmptyOnQueueExtension<E extends Object> on Queue<E> {
  /// Returns this queue wrapped in a [Some] if it's not empty, otherwise
  /// returns [None].
  Option<Queue<E>> get noneIfEmpty => isEmpty ? const None() : Some(this);
}

// --------------------------------------------------
// Source: ./lib/src/utils/here.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by DevCetra.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:path/path.dart' as p;
// import 'package:stack_trace/stack_trace.dart';

// import '../_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A utility class for capturing the current code location (file, line,
/// column, member).
///
/// This is useful for debugging and logging purposes, especially when dealing
/// with errors or unexpected states.
final class Here {
  //
  //
  //

  final int level;

  //
  //
  //

  const Here(this.level) : assert(level >= 0);

  /// Returns the [Frame] for the current code location, skipping the initial
  /// stack levels specified by [level].
  ///
  /// Returns `null` if no suitable frame is found.
  Option<Frame> call() {
    final frames = Trace.current(level).frames;
    for (var n = 0; n < frames.length; n++) {
      final frame = frames[n];
      final lineNumber = frame.line;
      final columnNumber = frame.column;
      if (lineNumber != null && columnNumber != null) {
        return Some(frame);
      }
    }
    return const None();
  }

  /// A string representing the basepath location of the call.
  Option<String> get basepath => call().map(
    (e) => [
      p.basenameWithoutExtension(e.library),
      if (e.member != null) e.member,
    ].join('/'),
  );

  /// A string representing the location of the call.
  Option<String> get location => call().map((e) => e.location);
}

// --------------------------------------------------
// Source: ./lib/src/utils/debug.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

/// A constatnt that can be used to check if your app is running in a Dart only
/// or Flutter environment. It's `true` if `dart.library.ui` is defined and
/// `false` otherwise.
const kIsDartLibraryUI = bool.fromEnvironment('dart.library.ui');

// --------------------------------------------------
// Source: ./lib/src/utils/lazy.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import 'package:meta/meta.dart';

// import '../_src.g.dart';
// import '../monads/monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A class that provides lazy initialization for instances of type [T].
class Lazy<T extends Object> {
  /// Holds the current singleton instance of type [T] or `null` if no
  /// [singleton] instance was created.
  @protected
  Option<Resolvable<T>> currentInstance = const None();

  /// A constructor function that creates instances of type [T].
  final LazyConstructor<T> _constructor;

  Lazy(this._constructor);

  /// Returns the singleton instance [currentInstance], or creating it if necessary.
  @pragma('vm:prefer-inline')
  Resolvable<T> get singleton {
    return (currentInstance.isNone()
            ? currentInstance = Some(_constructor())
            : currentInstance)
        .unwrap();
  }

  /// Returns a new instance of [T] each time, acting as a factory.
  @pragma('vm:prefer-inline')
  Resolvable<T> get factory => _constructor();

  /// Resets the singleton instance, by setting [currentInstance] back to `null`
  /// allowing it to be re-created via [singleton].
  @pragma('vm:prefer-inline')
  void resetSingleton() => currentInstance = const None();
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

typedef LazyConstructor<T extends Object> = Resolvable<T> Function();

// --------------------------------------------------
// Source: ./lib/src/utils/combine_monads.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import 'package:df_safer_dart_annotations/df_safer_dart_annotations.dart';

// import '../monads/monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Combines an iterable of [Resolvable]s into one containing a list of their
/// values.
///
/// The result is an [Async] if any of the [resolvables] are `Async`.
/// If any resolvable contains an [Err], applies [onErr] to combine errors.
Resolvable<List<T>> combineResolvable<T extends Object>(
  Iterable<Resolvable<T>> resolvables, {
  @noFuturesAllowed Err<List<T>> Function(List<Result<T>> allResults)? onErr,
}) {
  if (resolvables.isEmpty) {
    return Sync.value(const Ok([]));
  }

  // If any resolvable is async, the result must be async.
  if (resolvables.any((r) => r.isAsync())) {
    final asyncs = resolvables.map((r) => r.toAsync());
    return combineAsync(asyncs, onErr: onErr);
  } else {
    // All are sync, so we can proceed synchronously.
    final syncs = resolvables.map((r) => r as Sync<T>);
    return combineSync(syncs, onErr: onErr);
  }
}

/// Combines an iterable of [Sync]s into one containing a list of their values.
///
/// If any [Sync] contains an [Err], applies the [onErr] function to combine
/// errors.
Sync<List<T>> combineSync<T extends Object>(
  Iterable<Sync<T>> syncs, {
  @noFuturesAllowed Err<List<T>> Function(List<Result<T>> allResults)? onErr,
}) {
  if (syncs.isEmpty) {
    return Sync.value(const Ok([]));
  }

  return Sync(() {
    final results = syncs.map((s) => s.value).toList();
    final combined = combineResult(results, onErr: onErr);
    switch (combined) {
      case Ok(value: final value):
        return value;
      case Err err:
        throw err;
    }
  });
}

/// Combines an iterable of [Async]s into one containing a list of their values.
///
/// The inputs are awaited concurrently. If any resolves to an [Err], applies
/// the [onErr] function to combine errors.
Async<List<T>> combineAsync<T extends Object>(
  Iterable<Async<T>> asyncs, {
  @noFuturesAllowed Err<List<T>> Function(List<Result<T>> allResults)? onErr,
}) {
  if (asyncs.isEmpty) {
    return Async.value(Future.value(const Ok([])));
  }

  return Async(() async {
    final results = await Future.wait(asyncs.map((a) => a.value));
    final combined = combineResult(results, onErr: onErr);
    switch (combined) {
      case Ok(value: final value):
        return value;
      case Err err:
        throw err;
    }
  });
}

/// Combines an iterable of [Option]s into one containing a list of their values.
///
/// If any [Option] is a [None], the result is a [None].
Option<List<T>> combineOption<T extends Object>(Iterable<Option<T>> options) {
  final values = <T>[];
  for (final option in options) {
    switch (option) {
      case Some(value: final value):
        values.add(value);
      case None():
        return const None();
    }
  }
  return Some(values);
}

/// Combines an iterable of [Result]s into one containing a list of their values.
///
/// If any [Result] is an [Err], applies the [onErr] function to combine errors.
Result<List<T>> combineResult<T extends Object>(
  Iterable<Result<T>> results, {
  @noFuturesAllowed Err<List<T>> Function(List<Result<T>> allResults)? onErr,
}) {
  final successes = <T>[];
  final asList = results.toList();
  for (final result in asList) {
    switch (result) {
      case Ok(value: final value):
        successes.add(value);
      case final Err err:
        if (onErr != null) {
          return onErr(asList);
        } else {
          return err.transfErr();
        }
    }
  }
  return Ok(successes);
}

// --------------------------------------------------
// Source: ./lib/src/utils/unsafe.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:df_safer_dart_annotations/df_safer_dart_annotations.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Executes a block of code that is considered UNSAFE, allowing the use of
/// methods like `unwrap()`. This function provides no actual safety guarantees;
/// it only serves as a marker for linter rules and to signal to developers
/// that the contained code can throw exceptions from monad operations.
///
/// Use this to explicitly acknowledge that you are handling a potentially
/// failing operation outside the monadic context.
T UNSAFE<T>(@mustBeAnonymous @noFuturesAllowed T Function() block) {
  assert(!_isSubtype<T, Future<Object>>(), '$T must never be a Future.');
  try {
    return block();
  } catch (_) {
    // We may want to do something here at some point.
    rethrow;
  }
}

@pragma('vm:prefer-inline')
bool _isSubtype<TChild, TParent>() => <TChild>[] is List<TParent>;

// --------------------------------------------------
// Source: ./lib/src/utils/let_or_none_collections.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'dart:collection';

// import '../_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

Option<Iterable<Option<T>>> letIterableOrNone<T extends Object>(dynamic input) {
  switch (input) {
    case Monad m:
      return letIterableOrNone(m.rawSync().value.orNull());
    case Iterable<T> i:
      return Some(i.map((e) => Some(e)));
    case Iterable<dynamic> i:
      return Some(i.map((e) => letOrNone(e)));
    case String s:
      return jsonDecodeOrNone<Iterable<dynamic>>(s).map((d) => d.map((e) => letOrNone<T>(e)));
    default:
      return const None();
  }
}

Option<List<Option<T>>> letListOrNone<T extends Object>(dynamic input) {
  return letIterableOrNone<T>(input).map((e) => List.from(e));
}

Option<Set<Option<T>>> letSetOrNone<T extends Object>(dynamic input) {
  return letIterableOrNone<T>(input).map((e) => Set.from(e));
}

Option<Queue<Option<T>>> letQueueOrNone<T extends Object>(dynamic input) {
  return letIterableOrNone<T>(input).map((e) => Queue.from(e));
}

// --------------------------------------------------
// Source: ./lib/src/utils/ergonomics.dart
// --------------------------------------------------
// ignore_for_file: must_use_unsafe_wrapper_or_error
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'dart:async';

// import 'package:df_safer_dart_annotations/df_safer_dart_annotations.dart' show unsafeOrError;

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

@pragma('vm:prefer-inline')
Sync<None<T>> syncNone<T extends Object>() => const Sync.unsafe(Ok(None()));

@pragma('vm:prefer-inline')
Async<None<T>> asyncNone<T extends Object>() => Async.unsafe(Future.value(Ok(None<T>())));

@pragma('vm:prefer-inline')
Resolvable<None<T>> resolvableNone<T extends Object>() => syncNone();

@pragma('vm:prefer-inline')
Sync<Unit> syncUnit() => Sync.unsafe(Ok(Unit()));

@pragma('vm:prefer-inline')
Async<Unit> asyncUnit() => Async.unsafe(Future.value(Ok(Unit())));

@pragma('vm:prefer-inline')
Resolvable<Unit> resolvableUnit() => syncUnit();

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $$SyncOptionExtension<T extends Object> on Sync<Option<T>> {
  @unsafeOrError
  @pragma('vm:prefer-inline')
  T unwrapSync() => unwrap().unwrap();
}

extension $$AsyncOptionExtension<T extends Object> on Async<Option<T>> {
  @unsafeOrError
  @pragma('vm:prefer-inline')
  Future<T> unwrapAsync() => unwrap().then((e) => e.unwrap());
}

extension $$ResolvableOptionExtension<T extends Object> on Resolvable<Option<T>> {
  @unsafeOrError
  @pragma('vm:prefer-inline')
  T unwrapSync() => sync().unwrap().unwrapSync();

  @unsafeOrError
  @pragma('vm:prefer-inline')
  Future<T> unwrapAsync() => async().unwrap().unwrapAsync();
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

typedef TReducedMonad<T extends Object> = Resolvable<Option<T>>;
typedef TOptionResult<T extends Object> = Option<Result<T>>;

// --------------------------------------------------
// Source: ./lib/src/utils/let_or_none_map.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import 'let_or_none.dart';

// import '../monads/monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Intelligently converts a [dynamic] input into an `Option<Map<K, Option<V>>>`.
///
/// This function performs a **shallow (one-level) conversion** and is the
/// recommended safe way to create a map from an unknown data source. It returns
/// [None] if the input cannot be resolved to a map.
///
/// ### Accepted Inputs:
/// - A `Map`: Converts its immediate keys and values.
/// - A JSON `String`: Parses the string and then converts the resulting map.
/// - A `Monad`: Safely unwraps the monad and attempts conversion on its value.
Option<Map<K, Option<V>>> letMapOrNone<K extends Object, V extends Object>(dynamic input) {
  return switch (input) {
    final Monad m => switch (m.rawSync().value) {
        Ok(value: final v) => letMapOrNone<K, V>(v),
        Err() => const None(),
      },
    final Map<dynamic, dynamic> m => Some(_convertMap<K, V>(m)),
    final String s =>
      jsonDecodeOrNone<Map<dynamic, dynamic>>(s.trim()).map((d) => _convertMap<K, V>(d)),
    _ => const None(),
  };
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

Map<K, Option<V>> _convertMap<K extends Object, V extends Object>(Map<dynamic, dynamic> map) {
  final entries = map.entries.map((entry) {
    final rawKey = entry.key is Monad ? (entry.key as Monad).rawSync().value.orNull() : entry.key;
    final rawValue =
        entry.value is Monad ? (entry.value as Monad).rawSync().value.orNull() : entry.value;
    final keyOption = letOrNone<K>(rawKey);
    final valueOption = letOrNone<V>(rawValue);
    if (keyOption.isNone()) {
      return const _EmptySentinel();
    }
    return MapEntry(keyOption.unwrap(), valueOption);
  });
  final filteredEntries =
      entries.where((e) => e != const _EmptySentinel()).cast<MapEntry<K, Option<V>>>();

  return Map.fromEntries(filteredEntries);
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

final class _EmptySentinel {
  const _EmptySentinel();
}

// --------------------------------------------------
// Source: ./lib/src/utils/safe_sequencer_callbacks.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import 'package:df_safer_dart_annotations/df_safer_dart_annotations.dart' show noFuturesAllowed;

// import '/df_safer_dart.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class SafeSequencerCallbacks<T extends Object, TParam extends Object> {
  //
  //
  //

  final _seq = SafeSequencer<T>();
  final _callbacks = <Object, TSafeCallback<T, TParam>>{};

  //
  //
  //

  _CallbackRemover addCallback(
    @noFuturesAllowed TSafeCallback<T, TParam> callback, {
    Object? callbackKey,
  }) {
    final key = callbackKey ?? callback;
    _callbacks[key] = callback;
    return _CallbackRemover(() => _callbacks.remove(key));
  }

  //
  //
  //

  bool callbackExists(dynamic callbackKey) => _callbacks.containsKey(callbackKey);

  //
  //
  //

  bool removeCallback(Object callbackKey) => _callbacks.remove(callbackKey) != null;

  //
  //
  //

  void clearCallbacks() => _callbacks.clear();

  //
  //
  //

  Resolvable<Option<T>> call(
    Object callbackKey,
    TParam param, {
    bool eagerError = false,
    void Function(Err err)? onError,
  }) {
    final callback = _callbacks.getOption(callbackKey);
    if (callback.isNone()) {
      return Sync.unsafe(
        Err('No callback associated with $callbackKey exists!'),
      );
    }
    return _seq.pushTask((prev) {
      if (prev.isErr()) {
        onError?.call(prev.err().unwrap());
        if (eagerError) {
          return Sync.unsafe(prev);
        }
      }
      return callback.unwrap()(callbackKey, param);
    });
  }

  //
  //
  //

  Resolvable<Map<Object, Result<Option<T>>>> callAll(
    TParam param, {
    Set<dynamic>? include,
    Set<dynamic> exclude = const {},
    bool eagerError = true,
    void Function(Err err)? onError,
  }) {
    final results = <Object, Result<Option<T>>>{};
    for (final e in _callbacks.entries) {
      if (include == null || include.contains(e)) {
        if (exclude.isEmpty || !exclude.contains(e)) {
          final callbackKey = e.key;
          call(
            callbackKey,
            param,
            eagerError: eagerError,
            onError: onError,
          ).end();
          _seq.pushTask((e) {
            results[callbackKey] = e;
            return syncNone();
          }).end();
        }
      }
    }
    return _seq.last.map((e) => results);
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

typedef TSafeCallback<T extends Object, TParam extends Object> = Resolvable<Option<T>> Function(
    Object callbackKey, TParam param);

class _CallbackRemover {
  final void Function() _remover;
  bool _didRemove = false;
  _CallbackRemover(this._remover);

  void remove() {
    assert(!_didRemove, 'Callback already removed!');
    if (_didRemove) return;
    _didRemove = true;
    _remover();
  }
}

// --------------------------------------------------
// Source: ./lib/src/utils/map_monad.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '../monads/monad/monad.dart';
// import 'ergonomics.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $MapMonad2<T extends Object> on Monad<Monad<Object>> {
  @pragma('vm:prefer-inline')
  TReducedMonad<Object> map2<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad3<T extends Object> on Monad<Monad<Monad<Object>>> {
  @pragma('vm:prefer-inline')
  TReducedMonad<Object> map3<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map2((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad4<T extends Object> on Monad<Monad<Monad<Monad<Object>>>> {
  @pragma('vm:prefer-inline')
  TReducedMonad<Object> map4<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map3((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad5<T extends Object> on Monad<Monad<Monad<Monad<Monad<Object>>>>> {
  @pragma('vm:prefer-inline')
  TReducedMonad<Object> map5<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map4((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad6<T extends Object> on Monad<Monad<Monad<Monad<Monad<Monad<Object>>>>>> {
  @pragma('vm:prefer-inline')
  TReducedMonad<Object> map6<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map5((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad7<T extends Object> on Monad<Monad<Monad<Monad<Monad<Monad<Monad<Object>>>>>>> {
  @pragma('vm:prefer-inline')
  TReducedMonad<Object> map7<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map6((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad8<T extends Object>
    on Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Object>>>>>>>> {
  @pragma('vm:prefer-inline')
  TReducedMonad<Object> map8<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map7((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad9<T extends Object>
    on Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Object>>>>>>>>> {
  @pragma('vm:prefer-inline')
  TReducedMonad<Object> map9<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map8((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad10<T extends Object>
    on Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Object>>>>>>>>>> {
  @pragma('vm:prefer-inline')
  TReducedMonad<Object> map10<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map9((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad11<T extends Object>
    on Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Object>>>>>>>>>>> {
  @pragma('vm:prefer-inline')
  TReducedMonad<Object> map11<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map10((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad12<T extends Object>
    on Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Object>>>>>>>>>>>> {
  @pragma('vm:prefer-inline')
  TReducedMonad<Object> map12<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map11((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad13<T extends Object> on Monad<
    Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Object>>>>>>>>>>>>> {
  @pragma('vm:prefer-inline')
  TReducedMonad<Object> map13<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map12((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad14<T extends Object> on Monad<
    Monad<
        Monad<
            Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Object>>>>>>>>>>>>>> {
  @pragma('vm:prefer-inline')
  TReducedMonad<Object> map14<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map13((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad15<T extends Object> on Monad<
    Monad<
        Monad<
            Monad<
                Monad<
                    Monad<
                        Monad<
                            Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Object>>>>>>>>>>>>>>> {
  @pragma('vm:prefer-inline')
  TReducedMonad<Object> map15<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map14((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad16<T extends Object> on Monad<
    Monad<
        Monad<
            Monad<
                Monad<
                    Monad<
                        Monad<
                            Monad<
                                Monad<
                                    Monad<
                                        Monad<Monad<Monad<Monad<Monad<Monad<Object>>>>>>>>>>>>>>>> {
  @pragma('vm:prefer-inline')
  TReducedMonad<Object> map16<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map15((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad17<T extends Object> on Monad<
    Monad<
        Monad<
            Monad<
                Monad<
                    Monad<
                        Monad<
                            Monad<
                                Monad<
                                    Monad<
                                        Monad<
                                            Monad<
                                                Monad<
                                                    Monad<
                                                        Monad<Monad<Monad<Object>>>>>>>>>>>>>>>>> {
  @pragma('vm:prefer-inline')
  TReducedMonad<Object> map17<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map16((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad18<T extends Object> on Monad<
    Monad<
        Monad<
            Monad<
                Monad<
                    Monad<
                        Monad<
                            Monad<
                                Monad<
                                    Monad<
                                        Monad<
                                            Monad<
                                                Monad<
                                                    Monad<
                                                        Monad<
                                                            Monad<
                                                                Monad<
                                                                    Monad<Object>>>>>>>>>>>>>>>>>> {
  @pragma('vm:prefer-inline')
  TReducedMonad<Object> map18<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map17((e) => mapper(e as T))).reduce();
  }
}

// --------------------------------------------------
// Source: ./lib/src/utils/let_or_none.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'dart:convert' show jsonDecode;

// import 'package:df_type/df_type.dart';

// import '../_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

Option<T> letOrNone<T extends Object>(dynamic input) {
  if (input is Some<T>) return input;
  if (input is T) return Some(input);
  if (input == null) return const None();
  return letAsOrNone<T>(() {
    if (typeEquality<T, double>() || typeEquality<T, double?>()) {
      return letDoubleOrNone(input);
    } else if (typeEquality<T, int>() || typeEquality<T, int?>()) {
      return letIntOrNone(input);
    } else if (typeEquality<T, bool>() || typeEquality<T, bool?>()) {
      return letBoolOrNone(input);
    } else if (typeEquality<T, DateTime>() || typeEquality<T, DateTime?>()) {
      return letDateTimeOrNone(input);
    } else if (typeEquality<T, Uri>() || typeEquality<T, Uri?>()) {
      return letUriOrNone(input);
    } else if (isSubtype<T, List<dynamic>>()) {
      return letListOrNone<Object>(input);
    } else if (isSubtype<T, Set<dynamic>>()) {
      return letSetOrNone<Object>(input);
    } else if (isSubtype<T, Iterable<dynamic>>()) {
      return letIterableOrNone<Object>(input);
    } else if (isSubtype<T, Map<dynamic, dynamic>>()) {
      return letMapOrNone<Object, Object>(input);
    } else if (typeEquality<T, String>() || typeEquality<T, String?>()) {
      return letAsStringOrNone(input);
    }
    return input;
  }());
}

Option<T> letAsOrNone<T extends Object>(dynamic input) {
  switch (input) {
    case T value:
      return Some(value);
    case Monad monad:
      final monadValue = monad.rawSync().value;
      return switch (monadValue) {
        Ok(value: final value) => letAsOrNone<T>(value),
        Err() => const None(),
      };
    default:
      return const None();
  }
}

Option<String> letAsStringOrNone(dynamic input) {
  try {
    return Some(input.toString());
  } catch (_) {
    return const None();
  }
}

Option<T> jsonDecodeOrNone<T extends Object>(String input) {
  try {
    final decoded = jsonDecode(input);
    return decoded is T ? Some(decoded) : const None();
  } catch (e) {
    return const None();
  }
}

Option<num> letNumOrNone(dynamic input) {
  switch (input) {
    case num value:
      return Some(value);
    case String string:
      return Option.from(num.tryParse(string.trim()));
    case Monad monad:
      final monadValue = monad.rawSync().value;
      return switch (monadValue) {
        Ok(value: final okValue) => letNumOrNone(okValue),
        Err() => const None(),
      };
    default:
      return const None();
  }
}

@pragma('vm:prefer-inline')
Option<int> letIntOrNone(dynamic input) {
  return letNumOrNone(input).map((n) => n.toInt());
}

@pragma('vm:prefer-inline')
Option<double> letDoubleOrNone(dynamic input) {
  return letNumOrNone(input).map((n) => n.toDouble());
}

Option<bool> letBoolOrNone(dynamic input) {
  switch (input) {
    case bool value:
      return Some(value);
    case String string:
      return Option.from(bool.tryParse(string.trim()));
    case Monad monad:
      final monadValue = monad.rawSync().value;
      return switch (monadValue) {
        Ok(value: final value) => letBoolOrNone(value),
        Err() => const None(),
      };
    default:
      return const None();
  }
}

Option<Uri> letUriOrNone(dynamic input) {
  switch (input) {
    case Uri value:
      return Some(value);
    case String string:
      return Option.from(Uri.tryParse(string.trim()));
    case Monad monad:
      final monadValue = monad.rawSync().value;
      return switch (monadValue) {
        Ok(value: final value) => letUriOrNone(value),
        Err() => const None(),
      };
    default:
      return const None();
  }
}

Option<DateTime> letDateTimeOrNone(dynamic input) {
  switch (input) {
    case DateTime value:
      return Some(value);
    case String string:
      return Option.from(DateTime.tryParse(string.trim()));
    case Monad monad:
      final monadValue = monad.rawSync().value;
      return switch (monadValue) {
        Ok(value: final value) => letDateTimeOrNone(value),
        Err() => const None(),
      };
    default:
      return const None();
  }
}

// --------------------------------------------------
// Source: ./lib/src/extensions/result_iterable_extension.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import '../monads/monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $IterableResultExtension<T extends Object> on Iterable<Result<T>> {
  Iterable<Ok<T>> whereOk() {
    return where((e) => e.isOk()).map((e) => e.ok().unwrap());
  }

  Iterable<Err<T>> whereErr() {
    return where((e) => e.isOk()).map((e) => e.err().unwrap());
  }
}

extension $IterableFutureResultExtension<T extends Object> on Iterable<Future<Result<T>>> {
  Future<Iterable<Ok<T>>> whereOk() {
    return Future.wait(this).then((e) => e.whereOk());
  }

  Future<Iterable<Err<T>>> whereErr() {
    return Future.wait(this).then((e) => e.whereErr());
  }
}

extension $IterableOkExtension<T extends Object> on Iterable<Ok<T>> {
  Iterable<T> unwrapAll() {
    return whereOk().map((e) => e.value);
  }
}

extension $FutureIterableOkExtension<T extends Object> on Future<Iterable<Ok<T>>> {
  Future<Iterable<T>> unwrapAll() {
    return then((e) => e.unwrapAll());
  }
}

// --------------------------------------------------
// Source: ./lib/src/extensions/to_unit_on_monad_extensions.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '../monads/monad/monad.dart';
// import '../utils/unit.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

// Void.

extension $ToUnitOnVoidMonad on Monad<void> {
  Monad<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnVoidOption on Option<void> {
  Option<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnVoidSome on Some<void> {
  Some<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnVoidNone on None<void> {
  None<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnVoidResolvable on Resolvable<void> {
  Resolvable<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnVoidSync on Sync<void> {
  Sync<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnVoidAsync on Async<void> {
  Async<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnVoidResult on Result<void> {
  Result<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnVoidOk on Ok<void> {
  Ok<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnVoidErr on Err<void> {
  Err<Unit> toUnit() => map((_) => Unit());
}

// Object.

extension $ToUnitOnObjectMonad on Monad<Object> {
  Monad<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnObjectOption on Option<Object> {
  Option<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnObjectSome on Some<Object> {
  Some<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnObjectNone on None<Object> {
  None<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnObjectResolvable on Resolvable<Object> {
  Resolvable<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnObjectSync on Sync<Object> {
  Sync<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnObjectAsync on Async<Object> {
  Async<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnObjectResult on Result<Object> {
  Result<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnObjectOk on Ok<Object> {
  Ok<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnObjectErr on Err<Object> {
  Err<Unit> toUnit() => map((_) => Unit());
}

// --------------------------------------------------
// Source: ./lib/src/extensions/resolvable_iterable_extension.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import '../monads/monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $IterableResolvableExtension<T extends Object> on Iterable<Resolvable<T>> {
  Iterable<Sync<T>> whereSync() {
    return where((e) => e.isSync()).map((e) => e.sync().unwrap());
  }

  Iterable<Async<T>> whereAsync() {
    return where((e) => e.isAsync()).map((e) => e.async().unwrap());
  }

  Iterable<Async<T>> mapToAsync() {
    return map((e) => e.toAsync());
  }
}

extension $IterableSyncExtension<T extends Object> on Iterable<Sync<T>> {
  Iterable<Result<T>> mapToResults() {
    return whereSync().map((e) => e.value);
  }
}

extension $IterableAsyncExtension<T extends Object> on Iterable<Async<T>> {
  Iterable<Future<Result<T>>> mapToResults() {
    return whereAsync().map((e) => e.value);
  }
}

// --------------------------------------------------
// Source: ./lib/src/extensions/to_resolvable_extension.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'dart:async';

// import '../monads/monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $ToResolvableExtension<T extends Object> on FutureOr<T> {
  @pragma('vm:prefer-inline')
  Resolvable<T> toResolvable({
    Err<T> Function(Object?)? onError,
    void Function()? onFinalize,
  }) {
    return Resolvable(() => this, onError: onError, onFinalize: onFinalize);
  }
}

extension $ToAsyncExtension<T extends Object> on Future<T> {
  @pragma('vm:prefer-inline')
  Async<T> toAsync({
    Err<T> Function(Object?)? onError,
    void Function()? onFinalize,
  }) {
    assert(
      !_isSubtype<T, Future<Object>>(),
      'Do not call toAsync on nested futures: $T.',
    );
    return Async(() => this, onError: onError, onFinalize: onFinalize);
  }
}

extension $ToSync<T extends Object> on T {
  @pragma('vm:prefer-inline')
  Sync<T> toSync({
    Err<T> Function(Object?)? onError,
    void Function()? onFinalize,
  }) {
    assert(
      !_isSubtype<T, Future<Object>>(),
      'Do not call toSync on futures: $T.',
    );
    return Sync(() => this, onError: onError, onFinalize: onFinalize);
  }
}

@pragma('vm:prefer-inline')
bool _isSubtype<TChild, TParent>() => <TChild>[] is List<TParent>;

// --------------------------------------------------
// Source: ./lib/src/extensions/to_safe_stream_extension.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'dart:async';
// import '../monads/monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// An extension on [Stream] to provide a safe way to handle stream events.
extension $ToSafeStreamExtension<T extends Object> on Stream<T> {
  /// Transforms a [Stream<T>] into a [Stream<Result<T>>].
  ///
  /// Each data event from the original stream is wrapped in an [Ok<T>].
  /// Each error event is wrapped in an [Err<T>].
  ///
  /// If [cancelOnError] is `true`, the stream will be closed upon the first
  /// error.
  Stream<Result<T>> toSafeStream({required bool cancelOnError}) {
    return transform(
      StreamTransformer.fromHandlers(
        handleData: (data, sink) {
          sink.add(Ok(data));
        },
        handleError: (error, stackTrace, sink) {
          if (error is Err) {
            sink.add(error.transfErr());
          } else {
            sink.add(Err<T>(error));
          }
          if (cancelOnError) {
            sink.close();
          }
        },
        handleDone: (sink) {
          sink.close();
        },
      ),
    );
  }
}

// --------------------------------------------------
// Source: ./lib/src/extensions/option_iterable_extension.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import '../monads/monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $IterableOptionExtension<T extends Object> on Iterable<Option<T>> {
  Iterable<Some<T>> whereSome() {
    return where((e) => e.isSome()).map((e) => e.some().unwrap());
  }

  Iterable<None<T>> whereNone() {
    return where((e) => e.isSome()).map((e) => e.none().unwrap());
  }
}

extension $IterableFutureOptionExtension<T extends Object> on Iterable<Future<Option<T>>> {
  Future<Iterable<Some<T>>> whereSome() {
    return Future.wait(this).then((e) => e.whereSome());
  }

  Future<Iterable<None<T>>> whereNone() {
    return Future.wait(this).then((e) => e.whereNone());
  }
}

extension $IterableSomeExtension<T extends Object> on Iterable<Some<T>> {
  Iterable<T> unwrapAll() {
    return whereSome().map((e) => e.value);
  }
}

extension $FutureIterableSomeExtension<T extends Object> on Future<Iterable<Some<T>>> {
  Future<Iterable<T>> unwrapAll() {
    return then((e) => e.unwrapAll());
  }
}

// --------------------------------------------------
// Source: ./lib/src/flatten/flatten_option.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:meta/meta.dart' show protected;

// import '../monads/monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $FlattenOption2<T extends Object> on Option<Option<T>> {
  @pragma('vm:prefer-inline')
  Option<T> flatten() => flatten2();

  @protected
  Option<T> flatten2() {
    switch (this) {
      case Some(value: final innerResult):
        return innerResult;
      case None():
        return const None();
    }
  }
}

extension $FlattenOption3<T extends Object> on Option<Option<Option<T>>> {
  @pragma('vm:prefer-inline')
  Option<T> flatten() => flatten3();

  @protected
  @pragma('vm:prefer-inline')
  Option<T> flatten3() => flatten2().flatten2();
}

extension $FlattenOption4<T extends Object> on Option<Option<Option<Option<T>>>> {
  @pragma('vm:prefer-inline')
  Option<T> flatten() => flatten4();

  @protected
  @pragma('vm:prefer-inline')
  Option<T> flatten4() => flatten3().flatten2();
}

extension $FlattenOption5<T extends Object> on Option<Option<Option<Option<Option<T>>>>> {
  @pragma('vm:prefer-inline')
  Option<T> flatten() => flatten5();

  @protected
  @pragma('vm:prefer-inline')
  Option<T> flatten5() => flatten4().flatten2();
}

extension $FlattenOption6<T extends Object> on Option<Option<Option<Option<Option<Option<T>>>>>> {
  @pragma('vm:prefer-inline')
  Option<T> flatten() => flatten6();

  @protected
  @pragma('vm:prefer-inline')
  Option<T> flatten6() => flatten5().flatten2();
}

extension $FlattenOption7<T extends Object>
    on Option<Option<Option<Option<Option<Option<Option<T>>>>>>> {
  @pragma('vm:prefer-inline')
  Option<T> flatten() => flatten7();

  @protected
  @pragma('vm:prefer-inline')
  Option<T> flatten7() => flatten6().flatten2();
}

extension $FlattenOption8<T extends Object>
    on Option<Option<Option<Option<Option<Option<Option<Option<T>>>>>>>> {
  @pragma('vm:prefer-inline')
  Option<T> flatten() => flatten8();

  @protected
  @pragma('vm:prefer-inline')
  Option<T> flatten8() => flatten7().flatten2();
}

extension $FlattenOption9<T extends Object>
    on Option<Option<Option<Option<Option<Option<Option<Option<Option<T>>>>>>>>> {
  @pragma('vm:prefer-inline')
  Option<T> flatten() => flatten9();

  @protected
  @pragma('vm:prefer-inline')
  Option<T> flatten9() => flatten8().flatten2();
}

// --------------------------------------------------
// Source: ./lib/src/flatten/flatten_resolvable.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import 'package:meta/meta.dart' show protected;

// import '../monads/monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $FlattenResolvable2<T extends Object> on Resolvable<Resolvable<T>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten2();

  @protected
  Resolvable<T> flatten2() {
    switch (this) {
      // Case 1: The outer container is a Sync.
      case Sync(value: final outerResult):
        switch (outerResult) {
          // Case 1a: The outer Sync contains an Ok.
          case Ok(value: final innerResolvable):
            // The inner value is the next Resolvable, which we return directly.
            return innerResolvable;
          // Case 1b: The outer Sync contains an Err.
          case final Err<Resolvable<T>> err:
            // Propagate the error, wrapped in a Sync.
            return Sync.value(err.transfErr());
        }

      // Case 2: The outer container is an Async.
      case Async(value: final outerFutureResult):
        return Async(() async {
          final outerResult = await outerFutureResult;
          // After awaiting, we have a Result. Switch on it.
          switch (outerResult) {
            // Case 2a: The outer Async contained an Ok.
            case Ok(value: final innerResolvable):
              // Await the inner Resolvable and return its value.
              return await innerResolvable.unwrap();
            // Case 2b: The outer Async contained an Err.
            case final Err<Resolvable<T>> err:
              // Re-throw the error to be caught by the Async constructor.
              throw err;
          }
        });
    }
  }
}

extension $FlattenResolvable3<T extends Object> on Resolvable<Resolvable<Resolvable<T>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten3();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten3() => flatten2().flatten2();
}

extension $FlattenResolvable4<T extends Object>
    on Resolvable<Resolvable<Resolvable<Resolvable<T>>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten4();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten4() => flatten3().flatten2();
}

extension $FlattenResolvable5<T extends Object>
    on Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<T>>>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten5();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten5() => flatten4().flatten2();
}

extension $FlattenResolvable6<T extends Object>
    on Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<T>>>>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten6();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten6() => flatten5().flatten2();
}

extension $FlattenResolvable7<T extends Object>
    on Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<T>>>>>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten7();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten7() => flatten6().flatten2();
}

extension $FlattenResolvable8<T extends Object> on Resolvable<
    Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<T>>>>>>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten8();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten8() => flatten7().flatten2();
}

extension $FlattenResolvable9<T extends Object> on Resolvable<
    Resolvable<
        Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<T>>>>>>>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten9();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten9() => flatten8().flatten2();
}

// --------------------------------------------------
// Source: ./lib/src/flatten/flatten_result.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:meta/meta.dart' show protected;

// import '../monads/monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $FlattenResult2<T extends Object> on Result<Result<T>> {
  @pragma('vm:prefer-inline')
  Result<T> flatten() => flatten2();

  @protected
  Result<T> flatten2() {
    switch (this) {
      case Ok(value: final innerResult):
        return innerResult;
      case Err err:
        return err.transfErr();
    }
  }
}

extension $FlattenResult3<T extends Object> on Result<Result<Result<T>>> {
  @pragma('vm:prefer-inline')
  Result<T> flatten() => flatten3();

  @protected
  @pragma('vm:prefer-inline')
  Result<T> flatten3() => flatten2().flatten2();
}

extension $FlattenResult4<T extends Object> on Result<Result<Result<Result<T>>>> {
  @pragma('vm:prefer-inline')
  Result<T> flatten() => flatten4();

  @protected
  @pragma('vm:prefer-inline')
  Result<T> flatten4() => flatten3().flatten2();
}

extension $FlattenResult5<T extends Object> on Result<Result<Result<Result<Result<T>>>>> {
  @pragma('vm:prefer-inline')
  Result<T> flatten() => flatten5();

  @protected
  @pragma('vm:prefer-inline')
  Result<T> flatten5() => flatten4().flatten2();
}

extension $FlattenResult6<T extends Object> on Result<Result<Result<Result<Result<Result<T>>>>>> {
  @pragma('vm:prefer-inline')
  Result<T> flatten() => flatten6();

  @protected
  @pragma('vm:prefer-inline')
  Result<T> flatten6() => flatten5().flatten2();
}

extension $FlattenResult7<T extends Object>
    on Result<Result<Result<Result<Result<Result<Result<T>>>>>>> {
  @pragma('vm:prefer-inline')
  Result<T> flatten() => flatten7();

  @protected
  @pragma('vm:prefer-inline')
  Result<T> flatten7() => flatten6().flatten2();
}

extension $FlattenResult8<T extends Object>
    on Result<Result<Result<Result<Result<Result<Result<Result<T>>>>>>>> {
  @pragma('vm:prefer-inline')
  Result<T> flatten() => flatten8();

  @protected
  @pragma('vm:prefer-inline')
  Result<T> flatten8() => flatten7().flatten2();
}

extension $FlattenResult9<T extends Object>
    on Result<Result<Result<Result<Result<Result<Result<Result<Result<T>>>>>>>>> {
  @pragma('vm:prefer-inline')
  Result<T> flatten() => flatten9();

  @protected
  @pragma('vm:prefer-inline')
  Result<T> flatten9() => flatten8().flatten2();
}

// --------------------------------------------------
// Source: ./lib/src/flatten/flatten_resolvable_result.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import 'package:meta/meta.dart' show protected;

// import '../monads/monad/monad.dart';
// import 'flatten_result.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $FlattenResolvableResult2<T extends Object> on Resolvable<Result<T>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten2();

  @protected
  Resolvable<T> flatten2() {
    switch (value) {
      case Future<Result<Result<T>>> value:
        return Async(() async {
          return (await value).flatten2().unwrap();
        });
      default:
        return Sync(() {
          return (value as Result<Result<T>>).flatten2().unwrap();
        });
    }
  }
}

extension $FlattenResolvableResulte3<T extends Object> on Resolvable<Result<Result<T>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten3();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten3() => flatten2().flatten2();
}

extension $FlattenResolvableResulte4<T extends Object> on Resolvable<Result<Result<Result<T>>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten4();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten4() => flatten3().flatten2();
}

extension $FlattenResolvableResulte5<T extends Object>
    on Resolvable<Result<Result<Result<Result<T>>>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten5();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten5() => flatten4().flatten2();
}

extension $FlattenResolvableResulte6<T extends Object>
    on Resolvable<Result<Result<Result<Result<Result<T>>>>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten6();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten6() => flatten5().flatten2();
}

extension $FlattenResolvableResulte7<T extends Object>
    on Resolvable<Result<Result<Result<Result<Result<Result<T>>>>>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten7();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten7() => flatten6().flatten2();
}

extension $FlattenResolvableResulte8<T extends Object>
    on Resolvable<Result<Result<Result<Result<Result<Result<Result<T>>>>>>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten8();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten8() => flatten7().flatten2();
}

extension $FlattenResolvableResulte9<T extends Object>
    on Resolvable<Result<Result<Result<Result<Result<Result<Result<Result<T>>>>>>>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten9();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten9() => flatten8().flatten2();
}

// --------------------------------------------------
// Source: ./lib/src/err_model/_err_model.g.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// GENERATED - DO NOT MODIFY BY HAND
// See: https://github.com/dev-cetera/df_generate_dart_models
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: annotate_overrides
// ignore_for_file: overridden_fields

// part of 'err_model.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Generated class for [_ErrModel].
class ErrModel {
  //
  //
  //

  /// No description provided.
  final String? type;

  /// No description provided.
  final String? error;

  /// No description provided.
  final int? statusCode;

  /// No description provided.
  final List<String>? stackTrace;

  /// Constructs a new instance of [ErrModel]
  /// from optional and required parameters.
  const ErrModel({
    required this.type,
    required this.error,
    this.statusCode,
    this.stackTrace,
  });

  /// Creates a copy of this instance, replacing the specified fields.
  ErrModel copyWith({
    String? type,
    String? error,
    int? statusCode,
    List<String>? stackTrace,
  }) {
    return ErrModel(
      type: type ?? this.type,
      error: error ?? this.error,
      statusCode: statusCode ?? this.statusCode,
      stackTrace: stackTrace ?? this.stackTrace,
    );
  }

  /// Creates a copy of this instance, removing the specified fields.
  ErrModel copyWithout({
    bool type = true,
    bool error = true,
    bool statusCode = true,
    bool stackTrace = true,
  }) {
    return ErrModel(
      type: type ? this.type : null,
      error: error ? this.error : null,
      statusCode: statusCode ? this.statusCode : null,
      stackTrace: stackTrace ? this.stackTrace : null,
    );
  }

  /// Returns the value of the [type] field.
  /// If the field is nullable, the return value may be null; otherwise, it
  /// will always return a non-null value.
  @pragma('vm:prefer-inline')
  String get type$ => type!;

  /// Returns the value of the [error] field.
  /// If the field is nullable, the return value may be null; otherwise, it
  /// will always return a non-null value.
  @pragma('vm:prefer-inline')
  String get error$ => error!;

  /// Returns the value of the [statusCode] field.
  /// If the field is nullable, the return value may be null; otherwise, it
  /// will always return a non-null value.
  @pragma('vm:prefer-inline')
  int? get statusCode$ => statusCode;

  /// Returns the value of the [stackTrace] field.
  /// If the field is nullable, the return value may be null; otherwise, it
  /// will always return a non-null value.
  @pragma('vm:prefer-inline')
  List<String>? get stackTrace$ => stackTrace;
}

// --------------------------------------------------
// Source: ./lib/src/err_model/err_model.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~
// import 'package:df_generate_dart_models_core/df_generate_dart_models_core.dart';

// part '_err_model.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

// @GenerateDartModel(
//   fields: {
//     Field(fieldPath: ['type'], fieldType: String, nullable: false),
//     Field(fieldPath: ['error'], fieldType: String, nullable: false),
//     Field(fieldPath: ['statusCode'], fieldType: int, nullable: true),
//     Field(fieldPath: ['stackTrace'], fieldType: List<String>, nullable: true),
//   },
// )
// ignore: unused_element
abstract class _ErrModel {}

// --------------------------------------------------
// Source: ./lib/src/monads/impl/_sync_impl.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// part of '../monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

sealed class SyncImpl<T extends Object> {
  Object get value;
}

// --------------------------------------------------
// Source: ./lib/src/monads/impl/_async_impl.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// part of '../monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

sealed class AsyncImpl<T extends Object> {
  Future<Object> get value;
}

// --------------------------------------------------
// Source: ./lib/src/monads/result/_ok.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// part of '../monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represents the success case of a [Result], containing a
/// [value].
final class Ok<T extends Object> extends Result<T> implements SyncImpl<T> {
  @override
  @pragma('vm:prefer-inline')
  T get value => super.value as T;

  const Ok(T super.value) : super._();

  @override
  @pragma('vm:prefer-inline')
  bool isOk() => true;

  @override
  @pragma('vm:prefer-inline')
  bool isErr() => false;

  @override
  @pragma('vm:prefer-inline')
  Result<T> ifOk(@noFuturesAllowed void Function(Ok<T> ok) noFuturesAllowed) {
    try {
      noFuturesAllowed(this);
      return this;
    } catch (error) {
      return Err(error);
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Ok<T> ifErr(@noFuturesAllowed void Function(Err<T> err) noFuturesAllowed) => this;

  @override
  @pragma('vm:prefer-inline')
  None<Err<T>> err() => const None();

  @override
  @pragma('vm:prefer-inline')
  Some<Ok<T>> ok() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  T? orNull() => value;

  @override
  @pragma('vm:prefer-inline')
  Result<R> flatMap<R extends Object>(
    @noFuturesAllowed Result<R> Function(T value) noFuturesAllowed,
  ) {
    return noFuturesAllowed(unwrap());
  }

  @override
  @pragma('vm:prefer-inline')
  Ok<T> mapOk(@noFuturesAllowed Ok<T> Function(Ok<T> ok) noFuturesAllowed) {
    return noFuturesAllowed(this);
  }

  @override
  @pragma('vm:prefer-inline')
  Ok<T> mapErr(@noFuturesAllowed Err<T> Function(Err<T> err) noFuturesAllowed) {
    return this;
  }

  @override
  @pragma('vm:prefer-inline')
  Result<Object> fold(
    @noFuturesAllowed Result<Object>? Function(Ok<T> ok) onOk,
    @noFuturesAllowed Result<Object>? Function(Err<T> err) onErr,
  ) {
    try {
      return onOk(this) ?? this;
    } catch (error) {
      return Err(error);
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Ok<T> okOr(Result<T> other) => this;

  @override
  @pragma('vm:prefer-inline')
  Result<T> errOr(Result<T> other) => other;

  @override
  @pragma('vm:prefer-inline')
  T unwrap() => value;

  @override
  @pragma('vm:prefer-inline')
  T unwrapOr(T fallback) => value;

  @override
  @pragma('vm:prefer-inline')
  Ok<R> map<R extends Object>(
    @noFuturesAllowed R Function(T value) noFuturesAllowed,
  ) {
    return Ok(noFuturesAllowed(value));
  }

  @override
  Result<R> transf<R extends Object>([
    @noFuturesAllowed R Function(T e)? noFuturesAllowed,
  ]) {
    try {
      final a = unwrap();
      final b = noFuturesAllowed?.call(a) ?? a as R;
      return Ok(b);
    } catch (e) {
      assert(false, e);
      return Err('Cannot transform $T to $R.');
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Some<Ok<T>> wrapSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<Ok<T>> wrapOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Ok<T>> wrapResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<Ok<T>> wrapSync() => Sync.unsafe(Ok(this));

  @override
  @pragma('vm:prefer-inline')
  Async<Ok<T>> wrapAsync() => Async.unsafe(Future.value(Ok(this)));

  @override
  @pragma('vm:prefer-inline')
  Ok<void> asVoid() => this;
}

// --------------------------------------------------
// Source: ./lib/src/monads/result/_err.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// part of '../monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represents the failure case of a [Result], containing an
/// error [value].
final class Err<T extends Object> extends Result<T> implements SyncImpl<T>, Exception {
  /// An optional HTTP status code associated with the error.
  final Option<int> statusCode;

  /// The stack trace captured when the [Err] was created.
  final Trace stackTrace;

  @override
  @protected
  @pragma('vm:prefer-inline')
  Object get value => super.value;

  @pragma('vm:prefer-inline')
  Object get error => value;

  /// Creates a new [Err] from [value] and an optional [statusCode].
  Err(super.value, {int? statusCode})
      : statusCode = Option.from(statusCode),
        stackTrace = Trace.current(),
        super._();

  /// Creates an [Err] from an [ErrModel].
  @pragma('vm:prefer-inline')
  factory Err.fromModel(ErrModel model) {
    final error = model.error;
    return Err(error ?? 'Unknown error!', statusCode: model.statusCode);
  }

  @override
  @pragma('vm:prefer-inline')
  bool isOk() => false;

  @override
  @pragma('vm:prefer-inline')
  bool isErr() => true;

  @override
  @pragma('vm:prefer-inline')
  Err<T> ifOk(@noFuturesAllowed void Function(Ok<T> ok) noFuturesAllowed) {
    return this;
  }

  @override
  @pragma('vm:prefer-inline')
  Err<T> ifErr(@noFuturesAllowed void Function(Err<T> err) noFuturesAllowed) {
    try {
      noFuturesAllowed(this);
      return this;
    } catch (error) {
      return Err(error);
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Some<Err<T>> err() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  None<Ok<T>> ok() => const None();

  @override
  @pragma('vm:prefer-inline')
  T? orNull() => null;

  @override
  @pragma('vm:prefer-inline')
  Result<R> flatMap<R extends Object>(
    @noFuturesAllowed Result<R> Function(T value) noFuturesAllowed,
  ) {
    return transfErr();
  }

  @override
  @pragma('vm:prefer-inline')
  Err<T> mapOk(@noFuturesAllowed Ok<T> Function(Ok<T> ok) noFuturesAllowed) {
    return this;
  }

  @override
  @pragma('vm:prefer-inline')
  Err<T> mapErr(
    @noFuturesAllowed Err<T> Function(Err<T> err) noFuturesAllowed,
  ) {
    return noFuturesAllowed(this);
  }

  @override
  @pragma('vm:prefer-inline')
  Result<Object> fold(
    @noFuturesAllowed Result<Object>? Function(Ok<T> ok) onOk,
    @noFuturesAllowed Result<Object>? Function(Err<T> err) onErr,
  ) {
    try {
      return onErr(this) ?? this;
    } catch (error) {
      return Err(error);
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Result<T> okOr(Result<T> other) => other;

  @override
  @pragma('vm:prefer-inline')
  Result<T> errOr(Result<T> other) => this;

  /// Returns an [Option] containing the error if its type matches `E`.
  @pragma('vm:prefer-inline')
  Option<E> matchError<E extends Object>() => value is E ? Some(value as E) : const None();

  /// Transforms the `Err`'s generic type from `T` to `R` while preserving the
  /// contained `error`.
  @pragma('vm:prefer-inline')
  Err<R> transfErr<R extends Object>() {
    return Err(value, statusCode: statusCode.orNull());
  }

  /// Converts this [Err] to a data model for serialization.
  ErrModel toModel() {
    final type = 'Err<${T.toString()}>';
    final error = _safeToString(value);
    return ErrModel(
      type: type,
      error: error,
      statusCode: statusCode.orNull(),
      stackTrace: stackTrace.frames.map((e) => e.toString()).toList(),
    );
  }

  /// Converts this [Err] to a JSON map.
  Map<String, dynamic> toJson() {
    final model = toModel();
    return {
      if (model.type != null) 'type': model.type,
      if (model.error != null) 'error': model.error,
      if (model.statusCode != null) 'statusCode': model.statusCode,
      if (model.stackTrace != null) 'stackTrace': model.stackTrace,
    };
  }

  @override
  @protected
  @unsafeOrError
  @pragma('vm:prefer-inline')
  T unwrap() {
    throw this;
  }

  @override
  @protected
  @pragma('vm:prefer-inline')
  T unwrapOr(T fallback) => fallback;

  @override
  @pragma('vm:prefer-inline')
  Err<R> map<R extends Object>(
    @noFuturesAllowed R Function(T value) noFuturesAllowed,
  ) {
    return transfErr();
  }

  @override
  @protected
  @pragma('vm:prefer-inline')
  Err<R> transf<R extends Object>([
    @noFuturesAllowed R Function(T e)? noFuturesAllowed,
  ]) {
    return transfErr<R>();
  }

  @override
  @pragma('vm:prefer-inline')
  Some<Err<T>> wrapSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<Err<T>> wrapOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Err<T>> wrapResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<Err<T>> wrapSync() => Sync.unsafe(Ok(this));

  @override
  @pragma('vm:prefer-inline')
  Async<Err<T>> wrapAsync() => Async.unsafe(Future.value(Ok(this)));

  @override
  @pragma('vm:prefer-inline')
  Err<void> asVoid() => this;

  @override
  @unsafeOrError
  @pragma('vm:prefer-inline')
  String toString() {
    final encoder = const JsonEncoder.withIndent('  ');
    return encoder.convert(toJson());
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

String _safeToString(Object? obj) {
  try {
    return obj.toString();
  } catch (e) {
    assert(false, e);
    return '${obj.runtimeType}@${obj.hashCode.toRadixString(16)}';
  }
}

// --------------------------------------------------
// Source: ./lib/src/monads/result/_result.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// part of '../monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represents the result of an operation: every [Result] is
/// either [Ok] and contains a success value, or [Err] and contains an error
/// value.
sealed class Result<T extends Object> extends Monad<T> implements SyncImpl<T> {
  /// Combines 2 [Result] monads into 1 containing a tuple of their values if
  /// all are [Ok].
  ///
  /// If any are [Err], applies [onErr] function to combine errors.
  ///
  /// See also: [combineResult].
  static Result<(T1, T2)> zip2<T1 extends Object, T2 extends Object>(
    Result<T1> r1,
    Result<T2> r2, [
    @noFuturesAllowed Err<(T1, T2)> Function(Result<T1>, Result<T2>)? onErr,
  ]) {
    final combined = combineResult<Object>(
      [r1, r2],
      onErr: onErr == null ? null : (l) => onErr(l[0].transf<T1>(), l[1].transf<T2>()).transfErr(),
    );
    return combined.map((l) => (l[0] as T1, l[1] as T2));
  }

  /// Combines 3 [Result] monads into 1 containing a tuple of their values if
  /// all are [Ok].
  ///
  /// If any are [Err], applies [onErr] function to combine errors.
  ///
  /// See also: [combineResult].
  static Result<(T1, T2, T3)> zip3<T1 extends Object, T2 extends Object, T3 extends Object>(
    Result<T1> r1,
    Result<T2> r2,
    Result<T3> r3, [
    @noFuturesAllowed Err<(T1, T2, T3)> Function(Result<T1>, Result<T2>, Result<T3>)? onErr,
  ]) {
    final combined = combineResult<Object>(
      [r1, r2, r3],
      onErr: onErr == null
          ? null
          : (l) => onErr(
                l[0].transf<T1>(),
                l[1].transf<T2>(),
                l[2].transf<T3>(),
              ).transfErr(),
    );
    return combined.map((l) => (l[0] as T1, l[1] as T2, l[2] as T3));
  }

  const Result._(super.value);

  /// Returns `this` as a base [Result] type.
  @pragma('vm:prefer-inline')
  Result<T> asResult() => this;

  /// Returns `true` if this [Result] is an [Ok].
  bool isOk();

  /// Returns `true` if this [Result] is an [Err].
  bool isErr();

  /// Performs a side-effect with the contained value if this is an [Ok].
  Result<T> ifOk(@noFuturesAllowed void Function(Ok<T> ok) noFuturesAllowed);

  /// Performs a side-effect with the contained error if this is an [Err].
  Result<T> ifErr(@noFuturesAllowed void Function(Err<T> err) noFuturesAllowed);

  /// Safely gets the [Err] instance.
  /// Returns a [Some] on [Err], or a [None] on [Ok].
  Option<Err<T>> err();

  /// Safely gets the [Ok] instance.
  /// Returns a [Some] on [Ok], or a [None] on [Err].
  Option<Ok<T>> ok();

  /// Returns the contained [Ok] value or `null`.
  T? orNull();

  /// Maps a `Result<T>` to `Result<R>` by applying a function that returns
  /// another [Result].
  Result<R> flatMap<R extends Object>(
    @noFuturesAllowed Result<R> Function(T value) noFuturesAllowed,
  );

  /// Transforms the inner [Ok] instance if this is an [Ok].
  Result<T> mapOk(@noFuturesAllowed Ok<T> Function(Ok<T> ok) noFuturesAllowed);

  /// Transforms the inner [Err] instance if this is an [Err].
  Result<T> mapErr(
    @noFuturesAllowed Err<T> Function(Err<T> err) noFuturesAllowed,
  );

  /// Folds the two cases of this [Result] into a single new [Result].
  Result<Object> fold(
    @noFuturesAllowed Result<Object>? Function(Ok<T> ok) onOk,
    @noFuturesAllowed Result<Object>? Function(Err<T> err) onErr,
  );

  /// Returns this if it's [Ok], otherwise returns the `other` [Result].
  Result<T> okOr(Result<T> other);

  /// Returns this if it's [Err], otherwise returns the `other` [Result].
  Result<T> errOr(Result<T> other);

  @override
  @unsafeOrError
  T unwrap();

  @override
  T unwrapOr(T fallback);

  @override
  Result<R> map<R extends Object>(
    @noFuturesAllowed R Function(T value) noFuturesAllowed,
  );

  @override
  Result<R> transf<R extends Object>([
    @noFuturesAllowed R Function(T e)? noFuturesAllowed,
  ]);

  @override
  @pragma('vm:prefer-inline')
  Some<Result<T>> wrapSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<Result<T>> wrapOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Result<T>> wrapResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<Result<T>> wrapSync() => Sync.unsafe(Ok(this));

  @override
  @pragma('vm:prefer-inline')
  Async<Result<T>> wrapAsync() => Async.unsafe(Future.value(Ok(this)));

  @override
  @pragma('vm:prefer-inline')
  Result<void> asVoid() => this;

  @override
  @nonVirtual
  @pragma('vm:prefer-inline')
  void end() {}
}

// --------------------------------------------------
// Source: ./lib/src/monads/option/_none.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// part of '../monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represents an [Option] that does not contain a value.
final class None<T extends Object> extends Option<T> implements SyncImpl<T> {
  @override
  @pragma('vm:prefer-inline')
  Unit get value => super.value as Unit;

  const None() : super._(Unit.instance);

  @override
  @pragma('vm:prefer-inline')
  bool isSome() => false;

  @override
  @pragma('vm:prefer-inline')
  bool isNone() => true;

  @override
  @pragma('vm:prefer-inline')
  Err<Some<T>> some() {
    return Err('Called some() on None<$T>.');
  }

  @override
  @pragma('vm:prefer-inline')
  Ok<None<T>> none() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<None<T>> ifSome(
    @noFuturesAllowed void Function(Some<T> some) noFuturesAllowed,
  ) {
    return Ok(this);
  }

  @override
  @pragma('vm:prefer-inline')
  Result<None<T>> ifNone(@noFuturesAllowed void Function() noFuturesAllowed) {
    try {
      noFuturesAllowed();
      return Ok(this);
    } catch (error) {
      return Err(error);
    }
  }

  @override
  @pragma('vm:prefer-inline')
  T? orNull() => null;

  @override
  @pragma('vm:prefer-inline')
  None<T> mapSome(
    @noFuturesAllowed Some<T> Function(Some<T> some) noFuturesAllowed,
  ) {
    return this;
  }

  @override
  @pragma('vm:prefer-inline')
  None<R> flatMap<R extends Object>(
    @noFuturesAllowed Option<R> Function(T value) noFuturesAllowed,
  ) {
    return const None();
  }

  @override
  @pragma('vm:prefer-inline')
  None<T> filter(@noFuturesAllowed bool Function(T value) noFuturesAllowed) {
    return const None();
  }

  @override
  @pragma('vm:prefer-inline')
  Result<Option<Object>> fold(
    @noFuturesAllowed Option<Object>? Function(Some<T> some) onSome,
    @noFuturesAllowed Option<Object>? Function(None<T> none) onNone,
  ) {
    try {
      return Ok(onNone(this) ?? this);
    } catch (error) {
      return Err(error);
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Option<T> someOr(Option<T> other) => other;

  @override
  @pragma('vm:prefer-inline')
  None<T> noneOr(Option<T> other) => this;

  @override
  @protected
  @unsafeOrError
  @pragma('vm:prefer-inline')
  T unwrap() {
    throw Err<T>('Called unwrap() on None<$T>.');
  }

  @override
  @protected
  @pragma('vm:prefer-inline')
  T unwrapOr(T fallback) => fallback;

  @override
  @pragma('vm:prefer-inline')
  None<R> map<R extends Object>(
    @noFuturesAllowed R Function(T value) noFuturesAllowed,
  ) {
    return None<R>();
  }

  @override
  @pragma('vm:prefer-inline')
  Ok<None<R>> transf<R extends Object>([
    @noFuturesAllowed R Function(T e)? noFuturesAllowed,
  ]) {
    return const Ok(None());
  }

  @override
  @pragma('vm:prefer-inline')
  Some<None<T>> wrapSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<None<T>> wrapOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<None<T>> wrapResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<None<T>> wrapSync() => Sync.unsafe(Ok(this));

  @override
  @pragma('vm:prefer-inline')
  Async<None<T>> wrapAsync() => Async.unsafe(Future.value(Ok(this)));

  @override
  @pragma('vm:prefer-inline')
  None<void> asVoid() => this;
}

// --------------------------------------------------
// Source: ./lib/src/monads/option/_option.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// part of '../monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represents an optional value: every [Option] is either
/// [Some] and contains a value, or [None] and does not.
sealed class Option<T extends Object> extends Monad<T> implements SyncImpl<T> {
  /// Combines 2 [Option] monads into 1 containing a tuple of their values if
  /// all are [Some].
  ///
  /// Returns [None] if any are [None].
  ///
  /// See also: [combineOption].
  static Option<(T1, T2)> zip2<T1 extends Object, T2 extends Object>(
    Option<T1> o1,
    Option<T2> o2,
  ) {
    return combineOption<Object>([o1, o2]).map((l) => (l[0] as T1, l[1] as T2));
  }

  /// Combines 3 [Option] monads into 1 containing a tuple of their values if
  /// all are [Some].
  ///
  /// Returns [None] if any are [None].
  ///
  /// See also: [combineOption].
  static Option<(T1, T2, T3)> zip3<T1 extends Object, T2 extends Object, T3 extends Object>(
      Option<T1> o1, Option<T2> o2, Option<T3> o3) {
    return combineOption<Object>([
      o1,
      o2,
      o3,
    ]).map((l) => (l[0] as T1, l[1] as T2, l[2] as T3));
  }

  const Option._(super.value);

  /// Creates an [Option] from a nullable value.
  ///
  /// Returns [Some] if the [value] is not `null`, otherwise returns [None].
  factory Option.from(T? value) {
    // This is already safe and idiomatic, no switch needed here.
    if (value != null) {
      return Some(value);
    } else {
      return const None();
    }
  }

  @Deprecated('Use "Option.from(T? value)" instead.')
  factory Option.fromNullable(T? value) => Option.from(value);

  /// Returns `this` as a base [Option] type.
  @pragma('vm:prefer-inline')
  Option<T> asOption() => this;

  /// Returns `true` if this [Option] is a [Some].
  bool isSome();

  /// Returns `true` if this [Option] is a [None].
  bool isNone();

  /// Safely gets the [Some] instance.  Returns an [Ok] on [Some], or an [Err]
  /// on [None].
  Result<Some<T>> some();

  /// Safely gets the [None] instance. Returns an [Ok] on [None], or an [Err]
  /// on [Some].
  Result<None<T>> none();

  /// Performs a side-effect with the contained value if this is a [Some].
  Result<Option<T>> ifSome(
    @noFuturesAllowed void Function(Some<T> some) noFuturesAllowed,
  );

  /// Performs a side-effect if this is a [None].
  Result<Option<T>> ifNone(@noFuturesAllowed void Function() noFuturesAllowed);

  /// Returns the contained value or `null`.
  T? orNull();

  /// Transforms the inner [Some] instance if this is a [Some].
  Option<T> mapSome(
    @noFuturesAllowed Some<T> Function(Some<T> some) noFuturesAllowed,
  );

  /// Maps an `Option<T>` to `Option<R>` by applying a function that returns
  /// another [Option].
  Option<R> flatMap<R extends Object>(
    @noFuturesAllowed Option<R> Function(T value) noFuturesAllowed,
  );

  /// Returns [None] if the predicate [noFuturesAllowed] returns `false`.
  /// Otherwise, returns the original [Option].
  Option<T> filter(@noFuturesAllowed bool Function(T value) noFuturesAllowed);

  /// Folds the two cases of this [Option] into a single [Result].
  ///
  /// The `onSome` and `onNone` functions must return a new [Option].
  Result<Option<Object>> fold(
    @noFuturesAllowed Option<Object>? Function(Some<T> some) onSome,
    @noFuturesAllowed Option<Object>? Function(None<T> none) onNone,
  );

  /// Returns this if it's [Some], otherwise returns the `other` [Option].
  Option<T> someOr(Option<T> other);

  /// Returns this if it's [None], otherwise returns the `other` [Option].
  Option<T> noneOr(Option<T> other);

  @override
  @unsafeOrError
  T unwrap();

  @override
  T unwrapOr(T fallback);

  @override
  Option<R> map<R extends Object>(
    @noFuturesAllowed R Function(T value) noFuturesAllowed,
  );

  @override
  Result<Option<R>> transf<R extends Object>([
    @noFuturesAllowed R Function(T e)? noFuturesAllowed,
  ]);

  @override
  @pragma('vm:prefer-inline')
  Some<Option<T>> wrapSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<Option<T>> wrapOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Option<T>> wrapResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<Option<T>> wrapSync() => Sync.unsafe(Ok(this));

  @override
  @pragma('vm:prefer-inline')
  Async<Option<T>> wrapAsync() => Async.unsafe(Future.value(Ok(this)));

  @override
  @pragma('vm:prefer-inline')
  Option<void> asVoid() => this;

  @override
  @nonVirtual
  @pragma('vm:prefer-inline')
  void end() {}
}

// --------------------------------------------------
// Source: ./lib/src/monads/option/_some.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// part of '../monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represents an [Option] that contains a [value].
final class Some<T extends Object> extends Option<T> implements SyncImpl<T> {
  @override
  @pragma('vm:prefer-inline')
  T get value => super.value as T;

  const Some(T super.value) : super._();

  @override
  @pragma('vm:prefer-inline')
  bool isSome() => true;

  @override
  @pragma('vm:prefer-inline')
  bool isNone() => false;

  @override
  @pragma('vm:prefer-inline')
  Ok<Some<T>> some() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Err<None<T>> none() {
    return Err('Called none() on Some<$T>.');
  }

  @override
  @pragma('vm:prefer-inline')
  Result<Some<T>> ifSome(
    @noFuturesAllowed void Function(Some<T> some) noFuturesAllowed,
  ) {
    try {
      noFuturesAllowed(this);
      return Ok(this);
    } catch (error) {
      return Err(error);
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Ok<Some<T>> ifNone(@noFuturesAllowed void Function() noFuturesAllowed) {
    return Ok(this);
  }

  @override
  @pragma('vm:prefer-inline')
  T? orNull() => value;

  @override
  @pragma('vm:prefer-inline')
  Some<T> mapSome(
    @noFuturesAllowed Some<T> Function(Some<T> some) noFuturesAllowed,
  ) {
    return noFuturesAllowed(this);
  }

  @override
  @pragma('vm:prefer-inline')
  Option<R> flatMap<R extends Object>(
    @noFuturesAllowed Option<R> Function(T value) noFuturesAllowed,
  ) {
    return noFuturesAllowed(UNSAFE(() => unwrap()));
  }

  @override
  @pragma('vm:prefer-inline')
  Option<T> filter(@noFuturesAllowed bool Function(T value) noFuturesAllowed) {
    return noFuturesAllowed(value) ? this : const None();
  }

  @override
  @pragma('vm:prefer-inline')
  Result<Option<Object>> fold(
    @noFuturesAllowed Option<Object>? Function(Some<T> some) onSome,
    @noFuturesAllowed Option<Object>? Function(None<T> none) onNone,
  ) {
    try {
      return Ok(onSome(this) ?? this);
    } catch (error) {
      return Err(error);
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Some<T> someOr(Option<T> other) => this;

  @override
  @pragma('vm:prefer-inline')
  Option<T> noneOr(Option<T> other) => other;

  @override
  @unsafeOrError
  @pragma('vm:prefer-inline')
  T unwrap() => value;

  @override
  @pragma('vm:prefer-inline')
  T unwrapOr(T fallback) => value;

  @override
  @pragma('vm:prefer-inline')
  Some<R> map<R extends Object>(
    @noFuturesAllowed R Function(T value) noFuturesAllowed,
  ) {
    return Some(noFuturesAllowed(value));
  }

  @override
  Result<Option<R>> transf<R extends Object>([
    @noFuturesAllowed R Function(T e)? noFuturesAllowed,
  ]) {
    try {
      UNSAFE:
      final value0 = unwrap();
      final value1 = noFuturesAllowed?.call(value0) ?? value0 as R;
      return Ok(Option.from(value1));
    } catch (e) {
      assert(false, e);
      return Err('Cannot transform $T to $R');
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Some<Some<T>> wrapSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<Some<T>> wrapOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Some<T>> wrapResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<Some<T>> wrapSync() => Sync.unsafe(Ok(this));

  @override
  @pragma('vm:prefer-inline')
  Async<Some<T>> wrapAsync() => Async.unsafe(Future.value(Ok(this)));

  @override
  @pragma('vm:prefer-inline')
  Some<void> asVoid() => this;
}

// --------------------------------------------------
// Source: ./lib/src/monads/resolvable/_async.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// part of '../monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represents a [Resolvable] that holds an asynchronous [Result].
///
/// The contained [value] is always a [Future].
///
/// # IMPORTANT:
///
/// Await all Futures in the constructor [Async.new] to ensure errors are
/// properly caught and propagated.
final class Async<T extends Object> extends Resolvable<T> implements AsyncImpl<T> {
  /// Combines 2 [Async] monads into 1 containing a tuple of their values
  /// if all resolve to [Ok].
  ///
  /// If any resolve to [Err], applies [onErr] function to combine errors.
  ///
  /// See also: [combineAsync].
  static Async<(T1, T2)> zip2<T1 extends Object, T2 extends Object>(
    Async<T1> a1,
    Async<T2> a2, [
    @noFuturesAllowed Err<(T1, T2)> Function(Result<T1>, Result<T2>)? onErr,
  ]) {
    final combined = combineAsync<Object>(
      [a1, a2],
      onErr: onErr == null ? null : (l) => onErr(l[0].transf<T1>(), l[1].transf<T2>()).transfErr(),
    );
    return combined.map((l) => (l[0] as T1, l[1] as T2));
  }

  /// Combines 3 [Async] monads into 1 containing a tuple of their values
  /// if all resolve to [Ok].
  ///
  /// If any resolve to [Err], applies [onErr] function to combine errors.
  ///
  /// See also: [combineAsync].
  static Async<(T1, T2, T3)> zip3<T1 extends Object, T2 extends Object, T3 extends Object>(
    Async<T1> a1,
    Async<T2> a2,
    Async<T3> a3, [
    @noFuturesAllowed Err<(T1, T2, T3)> Function(Result<T1>, Result<T2>, Result<T3>)? onErr,
  ]) {
    final combined = combineAsync<Object>(
      [a1, a2, a3],
      onErr: onErr == null
          ? null
          : (l) => onErr(
                l[0].transf<T1>(),
                l[1].transf<T2>(),
                l[2].transf<T3>(),
              ).transfErr(),
    );
    return combined.map((l) => (l[0] as T1, l[1] as T2, l[2] as T3));
  }

  @override
  @pragma('vm:prefer-inline')
  Future<Result<T>> get value => super.value as Future<Result<T>>;

  @protected
  @unsafeOrError
  const Async.unsafe(Future<Result<T>> super.value) : super.unsafe();

  /// Creates an [Async] with a pre-computed [Future] of a [Result].
  ///
  /// # IMPORTANT
  ///
  /// [T] must never be a [Future].
  Async.value(Future<Result<T>> super.value)
      : assert(!_isSubtype<T, Future<Object>>(), '$T must never be a Future.'),
        super.unsafe();

  /// Creates an [Async] by executing an asynchronous function
  /// [mustAwaitAllFutures].
  ///
  /// # IMPORTANT:
  ///
  /// Always all futures witin [mustAwaitAllFutures] to ensure errors are be
  /// caught and propagated.
  factory Async(
    @mustBeAnonymous @mustAwaitAllFutures Future<T> Function() mustAwaitAllFutures, {
    @noFuturesAllowed Err<T> Function(Object? error)? onError,
    @noFuturesAllowed void Function()? onFinalize,
  }) {
    assert(!_isSubtype<T, Future<Object>>(), '$T must never be a Future.');
    return Async.unsafe(() async {
      try {
        return Ok<T>(await mustAwaitAllFutures());
      } on Err catch (e) {
        return e.transfErr<T>();
      } catch (error) {
        try {
          if (onError == null) {
            rethrow;
          }
          return onError(error);
        } catch (error) {
          return Err<T>(error);
        }
      } finally {
        onFinalize?.call();
      }
    }());
  }

  @override
  @pragma('vm:prefer-inline')
  bool isSync() => false;

  @override
  @pragma('vm:prefer-inline')
  bool isAsync() => true;

  @override
  @pragma('vm:prefer-inline')
  Err<Sync<T>> sync() {
    return Err('Called sync() on Async<$T>.');
  }

  @override
  @pragma('vm:prefer-inline')
  Ok<Async<T>> async() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Async<T> ifSync(
    @noFuturesAllowed void Function(Sync<T> async) noFuturesAllowed,
  ) {
    return this;
  }

  @override
  @pragma('vm:prefer-inline')
  Async<T> ifAsync(
    @noFuturesAllowed void Function(Async<T> async) noFuturesAllowed,
  ) {
    try {
      noFuturesAllowed(this);
      return this;
    } catch (error) {
      return Async.unsafe(Future.value(Err(error)));
    }
  }

  @override
  Async<R> resultMap<R extends Object>(
    @noFuturesAllowed Result<R> Function(Result<T> value) noFuturesAllowed,
  ) {
    return Async(() async {
      final a = await value;
      switch (a) {
        case Ok():
          final b = noFuturesAllowed(a);
          switch (b) {
            case Ok(value: final v):
              return v;
            case Err():
              throw b;
          }
        case Err():
          throw a;
      }
    });
  }

  @override
  @pragma('vm:prefer-inline')
  Async<R> mapFutureOr<R extends Object>(FutureOr<R> Function(T value) mapper) {
    return Async(() async => mapper((await value).unwrap()));
  }

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Object> fold(
    @noFuturesAllowed Resolvable<Object>? Function(Sync<T> sync) onSync,
    @noFuturesAllowed Resolvable<Object>? Function(Async<T> async) onAsync,
  ) {
    try {
      return onAsync(this) ?? this;
    } catch (error) {
      return Async.unsafe(Future.value(Err(error)));
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Async<Object> foldResult(
    @noFuturesAllowed Result<Object>? Function(Ok<T> ok) onOk,
    @noFuturesAllowed Result<Object>? Function(Err<T> err) onErr,
  ) {
    return this.resultMap((e) => e.fold(onOk, onErr));
  }

  @override
  @pragma('vm:prefer-inline')
  Sync<T> toSync() {
    throw Err<T>('Called toSync() on Async<$T>.');
  }

  @override
  @pragma('vm:prefer-inline')
  Async<T> toAsync() => this;

  @override
  @pragma('vm:prefer-inline')
  Future<T?> orNull() => value.then((e) => e.orNull());

  @override
  @pragma('vm:prefer-inline')
  Resolvable<T> syncOr(Resolvable<T> other) => other;

  @override
  @pragma('vm:prefer-inline')
  Async<T> asyncOr(Resolvable<T> other) => this;

  @override
  @pragma('vm:prefer-inline')
  Async<T> okOr(Resolvable<T> other) {
    return Async(() async {
      final awaitedValue = await value;
      switch (awaitedValue) {
        case Ok(value: final v):
          return v;
        case Err():
          return (await other.value).unwrap();
      }
    });
  }

  @override
  @pragma('vm:prefer-inline')
  Async<T> errOr(Resolvable<T> other) {
    return Async(() async {
      final awaitedValue = await value;
      switch (awaitedValue) {
        case Err():
          return awaitedValue.unwrap();
        case Ok():
          return (await other.value).unwrap();
      }
    });
  }

  @override
  @pragma('vm:prefer-inline')
  Future<Option<Ok<T>>> ok() => value.then((e) => e.ok());

  @override
  @pragma('vm:prefer-inline')
  Future<Option<Err<T>>> err() => value.then((e) => e.err());

  @override
  @unsafeOrError
  @pragma('vm:prefer-inline')
  Future<T> unwrap() => value.then((e) => e.unwrap());

  @override
  FutureOr<T> unwrapOr(T fallback) => value.then((e) => e.unwrapOr(fallback));

  @override
  @pragma('vm:prefer-inline')
  Async<R> map<R extends Object>(
    @noFuturesAllowed R Function(T value) noFuturesAllowed,
  ) {
    return Async.unsafe(value.then((e) => e.map(noFuturesAllowed)));
  }

  @override
  Async<R> transf<R extends Object>([
    @noFuturesAllowed R Function(T e)? noFuturesAllowed,
  ]) {
    return Async(() async {
      final okOrErr = (await value).transf<R>(noFuturesAllowed);
      switch (okOrErr) {
        case Ok(value: final v):
          return v;
        case Err():
          throw okOrErr;
      }
    });
  }

  @override
  @pragma('vm:prefer-inline')
  Some<Async<T>> wrapSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<Async<T>> wrapOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Async<T>> wrapResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<Async<T>> wrapSync() => Sync.unsafe(Ok(this));

  @override
  @pragma('vm:prefer-inline')
  Async<Async<T>> wrapAsync() => Async.unsafe(Future.value(Ok(this)));

  @override
  @pragma('vm:prefer-inline')
  Async<void> asVoid() => this;

  @override
  @pragma('vm:prefer-inline')
  Future<void> end() {
    return value.then((e) => e.end()).catchError((_) {});
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

@pragma('vm:prefer-inline')
bool _isSubtype<TChild, TParent>() => <TChild>[] is List<TParent>;

// --------------------------------------------------
// Source: ./lib/src/monads/resolvable/_resolvable.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// part of '../monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represents a value which can be resolved either synchronously
/// [Sync] or asynchronously [Async].
///
/// The [value] of a [Sync] is never a [Future] while the value of an [Async]
/// is always a [Future].
sealed class Resolvable<T extends Object> extends Monad<T> {
  @override
  @pragma('vm:prefer-inline')
  FutureOr<Result<T>> get value => super.value as FutureOr<Result<T>>;

  @protected
  @unsafeOrError
  const Resolvable.unsafe(FutureOr<Result<T>> super.value);

  /// Combines 2 [Resolvable] monads into 1 containing a tuple of their values
  /// if all resolve to [Ok].
  ///
  /// If any resolve to [Err], applies [onErr] function to combine errors.
  ///
  /// See also: [combineResolvable].
  static Resolvable<(T1, T2)> zip2<T1 extends Object, T2 extends Object>(
    Resolvable<T1> r1,
    Resolvable<T2> r2, [
    @noFuturesAllowed Err<(T1, T2)> Function(Result<T1>, Result<T2>)? onErr,
  ]) {
    final combined = combineResolvable<Object>(
      [r1, r2],
      onErr: onErr == null ? null : (l) => onErr(l[0].transf<T1>(), l[1].transf<T2>()).transfErr(),
    );
    return combined.map((l) => (l[0] as T1, l[1] as T2));
  }

  /// Combines 3 [Resolvable] monads into 1 containing a tuple of their values
  /// if all resolve to [Ok].
  ///
  /// If any resolve to [Err], applies [onErr] function to combine errors.
  ///
  /// See also: [combineResolvable].
  static Resolvable<(T1, T2, T3)> zip3<T1 extends Object, T2 extends Object, T3 extends Object>(
    Resolvable<T1> r1,
    Resolvable<T2> r2,
    Resolvable<T3> r3, [
    @noFuturesAllowed Err<(T1, T2, T3)> Function(Result<T1>, Result<T2>, Result<T3>)? onErr,
  ]) {
    final combined = combineResolvable<Object>(
      [r1, r2, r3],
      onErr: onErr == null
          ? null
          : (l) => onErr(
                l[0].transf<T1>(),
                l[1].transf<T2>(),
                l[2].transf<T3>(),
              ).transfErr(),
    );
    return combined.map((l) => (l[0] as T1, l[1] as T2, l[2] as T3));
  }

  /// Creates a [Sync] or [Async] depending on the return type of
  /// [mustAwaitAllFutures].
  ///
  /// # IMPORTANT:
  ///
  /// Always all futures witin [mustAwaitAllFutures] to ensure errors are be
  /// caught and propagated.
  factory Resolvable(
    @mustBeAnonymous @mustAwaitAllFutures FutureOr<T> Function() mustAwaitAllFutures, {
    @noFuturesAllowed Err<T> Function(Object? error)? onError,
    @noFuturesAllowed void Function()? onFinalize,
  }) {
    final result = mustAwaitAllFutures();
    if (result is Future<T>) {
      return Async(() => result, onError: onError, onFinalize: onFinalize);
    } else {
      return Sync(() => result, onError: onError, onFinalize: onFinalize);
    }
  }

  /// Returns `this` as a base [Resolvable] type.
  @pragma('vm:prefer-inline')
  Resolvable<T> asResolvable() => this;

  /// Returns `true` if this is a [Sync] instance.
  bool isSync();

  /// Returns `true` if this is an [Async] instance.
  bool isAsync();

  /// Safely gets the [Sync] instance.
  /// Returns an [Ok] on [Sync], or an [Err] on [Async].
  Result<Sync<T>> sync();

  /// Safely gets the [Async] instance.
  /// Returns an [Ok] on [Async], or an [Err] on [Sync].
  Result<Async<T>> async();

  /// Performs a side-effect if this is a [Sync].
  Resolvable<T> ifSync(
    @noFuturesAllowed void Function(Sync<T> sync) noFuturesAllowed,
  );

  /// Performs a side-effect if this is an [Async].
  Resolvable<T> ifAsync(
    @noFuturesAllowed void Function(Async<T> async) noFuturesAllowed,
  );

  /// Maps the inner [Result] of this [Resolvable] using `mapper`.
  Resolvable<R> resultMap<R extends Object>(
    @noFuturesAllowed Result<R> Function(Result<T> value) noFuturesAllowed,
  );

  /// Maps the contained [Ok] value using a function that returns a `FutureOr`.
  Resolvable<R> mapFutureOr<R extends Object>(
    FutureOr<R> Function(T value) mapper,
  );

  /// Handles [Sync] and [Async] cases to produce a new [Resolvable].
  Resolvable<Object> fold(
    @noFuturesAllowed Resolvable<Object>? Function(Sync<T> sync) onSync,
    @noFuturesAllowed Resolvable<Object>? Function(Async<T> async) onAsync,
  );

  /// Exhaustively handles the inner [Ok] and [Err] cases, returning a new
  /// [Resolvable].
  Resolvable<Object> foldResult(
    @noFuturesAllowed Result<Object>? Function(Ok<T> ok) onOk,
    @noFuturesAllowed Result<Object>? Function(Err<T> err) onErr,
  );

  /// Ensures that resolving this value takes at least a specified [duration].
  /// If [duration] is null, this method returns the original value immediately.
  Resolvable<T> withMinDuration(Duration? duration) {
    if (duration == null) {
      return this;
    }
    return Async<Result<T>>(() async {
      return _withMinDuration(value, duration);
    }).flatten();
  }

  FutureOr<R> _withMinDuration<R extends Object>(
    FutureOr<R> input,
    Duration? duration,
  ) {
    if (duration == null) {
      return input;
    }
    return Future.wait([
      Future.value(input),
      Future<void>.delayed(duration),
    ]).then((e) => e.first as R);
  }

  /// Unsafely converts this [Resolvable] to a [Sync]. Throws if it's an [Async].
  Sync<T> toSync();

  /// Converts this [Resolvable] to an [Async].
  Async<T> toAsync();

  /// Returns the contained [Ok] value or `null`, resolving any [Future].
  Future<T?> orNull();

  /// Returns this if it's [Sync], otherwise returns `other`.
  Resolvable<T> syncOr(Resolvable<T> other);

  /// Returns this if it's [Async], otherwise returns `other`.
  Resolvable<T> asyncOr(Resolvable<T> other);

  /// Returns this if it contains an [Ok], otherwise returns `other`.
  Resolvable<T> okOr(Resolvable<T> other);

  /// Returns this if it contains an [Err], otherwise returns `other`.
  Resolvable<T> errOr(Resolvable<T> other);

  /// Safely gets the [Ok] instance, resolving any [Future].
  FutureOr<Option<Ok<T>>> ok();

  /// Safely gets the [Err] instance, resolving any [Future].
  FutureOr<Option<Err<T>>> err();

  @override
  @unsafeOrError
  FutureOr<T> unwrap();

  @override
  FutureOr<T> unwrapOr(T fallback);

  @override
  Resolvable<R> map<R extends Object>(
    @noFuturesAllowed R Function(T value) noFuturesAllowed,
  );

  @override
  Resolvable<R> transf<R extends Object>([
    @noFuturesAllowed R Function(T e)? noFuturesAllowed,
  ]);

  @override
  @pragma('vm:prefer-inline')
  Some<Resolvable<T>> wrapSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<Resolvable<T>> wrapOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Resolvable<T>> wrapResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<Resolvable<T>> wrapSync() => Sync.unsafe(Ok(this));

  @override
  @pragma('vm:prefer-inline')
  Async<Resolvable<T>> wrapAsync() => Async.unsafe(Future.value(Ok(this)));

  @override
  @pragma('vm:prefer-inline')
  Resolvable<void> asVoid() => this;
}

// --------------------------------------------------
// Source: ./lib/src/monads/resolvable/_sync.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// part of '../monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represents a [Resolvable] that holds a synchronous [Result].
///
/// The contained [value] is never a [Future].
///
/// # IMPORTANT:
///
/// Do not use any Futures in the constructor [Sync.new] to ensure errors are
/// properly caught and propagated.
final class Sync<T extends Object> extends Resolvable<T> implements SyncImpl<T> {
  /// Combines 2 [Sync] monads into 1 containing a tuple of their values
  /// if all resolve to [Ok].
  ///
  /// If any resolve to [Err], applies [onErr] function to combine errors.
  ///
  /// See also: [combineSync].
  static Sync<(T1, T2)> zip2<T1 extends Object, T2 extends Object>(
    Sync<T1> s1,
    Sync<T2> s2, [
    @noFuturesAllowed Err<(T1, T2)> Function(Result<T1>, Result<T2>)? onErr,
  ]) {
    final combined = combineSync<Object>(
      [s1, s2],
      onErr: onErr == null ? null : (l) => onErr(l[0].transf<T1>(), l[1].transf<T2>()).transfErr(),
    );
    return combined.map((l) => (l[0] as T1, l[1] as T2));
  }

  /// Combines 3 [Sync] monads into 1 containing a tuple of their values
  /// if all resolve to [Ok].
  ///
  /// If any resolve to [Err], applies [onErr] function to combine errors.
  ///
  /// See also: [combineSync].
  static Sync<(T1, T2, T3)> zip3<T1 extends Object, T2 extends Object, T3 extends Object>(
    Sync<T1> s1,
    Sync<T2> s2,
    Sync<T3> s3, [
    @noFuturesAllowed Err<(T1, T2, T3)> Function(Result<T1>, Result<T2>, Result<T3>)? onErr,
  ]) {
    final combined = combineSync<Object>(
      [s1, s2, s3],
      onErr: onErr == null
          ? null
          : (l) => onErr(
                l[0].transf<T1>(),
                l[1].transf<T2>(),
                l[2].transf<T3>(),
              ).transfErr(),
    );
    return combined.map((l) => (l[0] as T1, l[1] as T2, l[2] as T3));
  }

  @override
  @pragma('vm:prefer-inline')
  Result<T> get value => super.value as Result<T>;

  @protected
  @unsafeOrError
  const Sync.unsafe(Result<T> super.value) : super.unsafe();

  /// Creates a [Sync] with a pre-computed [Result].
  ///
  /// # IMPORTANT
  ///
  /// [T] must never be a [Future].
  Sync.value(Result<T> super.value)
      : assert(!_isSubtype<T, Future<Object>>(), '$T must never be a Future.'),
        super.unsafe();

  /// Creates a [Sync] executing a synchronous function [noFuturesAllowed].
  ///
  /// # IMPORTANT:
  ///
  /// Do not use any Futures in [noFuturesAllowed] to ensure errors are be
  /// caught and propagated.
  factory Sync(
    @mustBeAnonymous @noFuturesAllowed T Function() noFuturesAllowed, {
    @noFuturesAllowed Err<T> Function(Object? error)? onError,
    @noFuturesAllowed void Function()? onFinalize,
  }) {
    assert(!_isSubtype<T, Future<Object>>(), '$T must never be a Future.');
    return Sync.unsafe(() {
      try {
        return Ok(noFuturesAllowed());
      } on Err catch (e) {
        return e.transfErr<T>();
      } catch (error) {
        try {
          if (onError == null) {
            rethrow;
          }
          return onError(error);
        } catch (e) {
          return Err<T>(e);
        }
      } finally {
        onFinalize?.call();
      }
    }());
  }

  @override
  @pragma('vm:prefer-inline')
  bool isSync() => true;

  @override
  @pragma('vm:prefer-inline')
  bool isAsync() => false;

  @override
  @pragma('vm:prefer-inline')
  Ok<Sync<T>> sync() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Err<Async<T>> async() {
    return Err('Called async() on Sync<$T>.');
  }

  @override
  @pragma('vm:prefer-inline')
  Sync<T> ifSync(
    @noFuturesAllowed void Function(Sync<T> sync) noFuturesAllowed,
  ) {
    try {
      noFuturesAllowed(this);
      return this;
    } catch (error) {
      return Sync.unsafe(Err(error));
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Sync<T> ifAsync(
    @noFuturesAllowed void Function(Async<T> async) noFuturesAllowed,
  ) =>
      this;

  @override
  @pragma('vm:prefer-inline')
  Sync<R> resultMap<R extends Object>(
    @noFuturesAllowed Result<R> Function(Result<T> value) noFuturesAllowed,
  ) {
    return Sync(() => noFuturesAllowed(value).unwrap());
  }

  @override
  @pragma('vm:prefer-inline')
  Resolvable<R> mapFutureOr<R extends Object>(
    FutureOr<R> Function(T value) mapper,
  ) {
    return Resolvable(() => mapper(value.unwrap()));
  }

  @override
  Resolvable<Object> fold(
    @noFuturesAllowed Resolvable<Object>? Function(Sync<T> sync) onSync,
    @noFuturesAllowed Resolvable<Object>? Function(Async<T> async) onAsync,
  ) {
    try {
      return onSync(this) ?? this;
    } catch (error) {
      return Sync.unsafe(Err(error));
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Sync<Object> foldResult(
    @noFuturesAllowed Result<Object>? Function(Ok<T> ok) onOk,
    @noFuturesAllowed Result<Object>? Function(Err<T> err) onErr,
  ) {
    return Sync.unsafe(value.fold(onOk, onErr));
  }

  @override
  @pragma('vm:prefer-inline')
  Sync<T> toSync() => this;

  @override
  @pragma('vm:prefer-inline')
  Async<T> toAsync() => Async.unsafe(Future.value(value));

  @override
  @pragma('vm:prefer-inline')
  Future<T?> orNull() => Future.value(value.orNull());

  @override
  @pragma('vm:prefer-inline')
  Sync<T> syncOr(Resolvable<T> other) => this;

  @override
  @pragma('vm:prefer-inline')
  Resolvable<T> asyncOr(Resolvable<T> other) => other;

  @override
  @pragma('vm:prefer-inline')
  Resolvable<T> okOr(Resolvable<T> other) {
    switch (value) {
      case Ok():
        return this;
      case Err():
        return other;
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Resolvable<T> errOr(Resolvable<T> other) {
    switch (value) {
      case Err():
        return this;
      case Ok():
        return other;
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Option<Ok<T>> ok() => value.ok();

  @override
  @pragma('vm:prefer-inline')
  Option<Err<T>> err() => value.err();

  @override
  @unsafeOrError
  @pragma('vm:prefer-inline')
  T unwrap() => value.unwrap();

  @override
  T unwrapOr(T fallback) => value.unwrapOr(fallback);

  @override
  @pragma('vm:prefer-inline')
  Sync<R> map<R extends Object>(
    @noFuturesAllowed R Function(T value) noFuturesAllowed,
  ) {
    return Sync(() => value.map((e) => noFuturesAllowed(e)).unwrap());
  }

  @override
  Sync<R> transf<R extends Object>([
    @noFuturesAllowed R Function(T e)? noFuturesAllowed,
  ]) {
    return Sync(() {
      final okOrErr = value.transf<R>(noFuturesAllowed);
      if (okOrErr.isErr()) {
        throw okOrErr;
      }
      return okOrErr.unwrap();
    });
  }

  @override
  @pragma('vm:prefer-inline')
  Some<Sync<T>> wrapSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<Sync<T>> wrapOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Sync<T>> wrapResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<Sync<T>> wrapSync() => Sync.unsafe(Ok(this));

  @override
  @pragma('vm:prefer-inline')
  Async<Sync<T>> wrapAsync() => Async.unsafe(Future.value(Ok(this)));

  @override
  @pragma('vm:prefer-inline')
  Sync<void> asVoid() => this;

  @override
  @pragma('vm:prefer-inline')
  void end() {}
}

// --------------------------------------------------
// Source: ./lib/src/monads/monad/monad.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import 'dart:async' show FutureOr;
// import 'dart:convert' show JsonEncoder;
// import 'package:equatable/equatable.dart' show Equatable;
// import 'package:meta/meta.dart';
// import 'package:stack_trace/stack_trace.dart';

// import 'package:df_safer_dart_annotations/df_safer_dart_annotations.dart';

// import '../../_src.g.dart';

// part '../option/_option.dart';
// part '../option/_some.dart';
// part '../option/_none.dart';
// part '../result/_result.dart';
// part '../result/_ok.dart';
// part '../result/_err.dart';
// part '../resolvable/_resolvable.dart';
// part '../resolvable/_async.dart';
// part '../resolvable/_sync.dart';

// part '../impl/_sync_impl.dart';
// part '../impl/_async_impl.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// The foundational sealed class for all monadic types like [Option], [Result],
/// and [Resolvable].
sealed class Monad<T extends Object> implements Equatable {
  final FutureOr<Object> value;

  const Monad(this.value);

  /// Reduces any nested [Monad] structure into a single [TReducedMonad].
  ///
  /// This flattens all [Monad] layers (`Option`, `Result`, `Resolvable`) into
  /// a final container that is always a `Resolvable` holding an `Option`.
  /// An [Err] state at any level will result in a failed `Resolvable`.
  TReducedMonad<R> reduce<R extends Object>() {
    return switch (this) {
      Some(value: final v) => Resolvable(() => Some(v as R)),
      Some(value: Monad<Object> v) => v.reduce<R>(),
      None() => syncNone<R>(),
      Ok(value: final v) => Resolvable(() => Some(v as R)),
      Ok(value: Monad<Object> v) => v.reduce<R>(),
      Err(error: final e) => Sync.unsafe(Err(e)),
      Sync(value: final result) => result.reduce<R>(),
      Async(value: final futureResult) => Async<Option<R>>(() async {
          final result = await futureResult;
          final innerResolvable = result.reduce<R>();
          return (await innerResolvable.value).unwrap();
        }),
    };
  }

  /// The low-level primitive for reducing a [Monad] chain. It recursively
  /// unwraps all [Monad] layers to return the innermost raw value, forcing the
  /// caller to handle terminal states via callbacks.
  ///
  /// - [onErr]: A function that is called when an [Err] is encountered.
  /// - [onNone]: A function that is called when a [None] is encountered.
  FutureOr<Object> raw({
    required FutureOr<Object> Function(Err<Object> err) onErr,
    required FutureOr<Object> Function() onNone,
  }) {
    FutureOr<Object> dive(Object obj) {
      return switch (obj) {
        Err() => onErr(obj),
        None() => onNone(),
        Monad(value: final v) => v is Future<Object> ? v.then(dive) : dive(v),
        Object() => obj,
      };
    }

    return dive(this);
  }

  /// Safely reduces any [Monad] chain to a single [Sync].
  ///
  /// It provides a direct way to get a raw synchronous value while collapsing
  /// all failure, empty, or asynchronous states into an [Err].
  /// 
  /// ### Example
  /// ```dart
  /// final success = Ok(Some(42)).rawSync();      // Contains Ok(42)
  /// final empty = Ok(None<int>()).rawSync();   // Contains Err(...)
  /// final failed = Err('fail').rawSync();      // Contains Err('fail')
  /// final isAsync = Async(() => 1).rawSync(); // Contains Err(...)
  /// ```
  Sync rawSync() {
    return Sync(() {
      final value = raw(
        onErr: (err) => err,
        onNone: () => Err('The Monad resolved to a None (empty) state!'),
      );
      if (value is Future) {
        return Err(
          'The Monad contains an asynchronous value! Use rawAsync instead.',
        );
      }
      if (value is Err) {
        return value;
      }
      return Ok(value);
    });
  }

  /// Reduces any [Monad] chain to a single [Async].
  ///
  /// It provides a direct way to get a raw value while collapsing
  /// all failure and empty states into an [Err].
  ///
  /// ### Example
  /// ```dart
  /// final result = await Async(() => 'hello').rawAsync().value; // Ok('hello')
  /// final emptyResult = await Some(None<int>()).rawAsync().value; // Err(...)
  /// ```
  Async rawAsync() {
    return Async(() async {
      final value = await raw(
        onErr: (err) => err,
        onNone: () => Err('The Monad resolved to a None (empty) state!'),
      );
      if (value is Err) {
        return value;
      }
      return value;
    });
  }

  /// **Strongly discouraged:** Unsafely returns the contained value.
  ///
  /// This method is the equivalent of the `!` (bang) operator for nullable
  /// types. It subverts the safety provided by the [Monad] by throwing an
  /// exception instead of allowing you to handle the failure state through
  /// the type system. A thrown exception from `unwrap()` should be considered a
  /// critical programming error.
  ///
  /// ---
  /// ### ⚠️ DANGER
  ///
  /// This method will throw an [Err] if the [Monad] is in a failure state
  /// ([Err] or [None]).
  ///
  /// ---
  /// ### Prefer Safer Alternatives:
  ///
  /// #### 1. To handle both success and failure cases:
  /// Use pattern matching with a `switch` expression. This is the most
  /// idiomatic and safest way to handle all possibilities.
  ///
  /// ```dart
  /// // For a Result<T>
  /// switch (myResult) {
  ///   case Ok(value: final data):
  ///     print('Success: $data');
  ///   case Err(error: final e):
  ///     print('Failure: $e');
  /// }
  ///
  /// // For an Option<T>
  /// switch (myOption) {
  ///   case Some(value: final data):
  ///     print('Found: $data');
  ///   case None():
  ///     print('Not found.');
  /// }
  /// ```
  ///
  /// #### 2. To provide a fallback value:
  /// Use [unwrapOr] to safely get the value or a default if it's absent.
  ///
  /// ```dart
  /// final user = findUser(id).unwrapOr(GuestUser());
  /// ```
  ///
  /// #### 3. To perform a side-effect only on success:
  /// Use `ifOk()` or `ifSome()` to run code without breaking the chain.
  ///
  /// ```dart
  //.   myResult.ifOk((ok) => logSuccess(ok.value));
  /// ```
  ///
  /// #### When is it okay to use `unwrap()`?
  /// The only acceptable time is within a test or a trusted context where a
  /// failure is a logic bug that *should* crash the test or program.
  /// Even then, it is best to wrap it in an `UNSAFE` block to signal this
  /// explicit breach of safety.
  ///
  /// ```dart
  /// final value = UNSAFE(() => Ok(1).unwrap()); // Signals deliberate unsafe access
  /// ```
  @unsafeOrError
  FutureOr<T> unwrap();

  /// Returns the contained value, or the `fallback` if the [Monad] is in an
  /// [Err] or [None] state.
  FutureOr<T> unwrapOr(T fallback);

  /// Transforms the contained value using the mapper function
  /// [noFuturesAllowed] while preserving the [Monad]'s structure.
  Monad<R> map<R extends Object>(
    @noFuturesAllowed R Function(T value) noFuturesAllowed,
  );

  /// Transforms the [Monad]'s generic type from `T` to `R`.
  ///
  /// Uses the transformer function [noFuturesAllowed] if provided, otherwise
  /// attempts a direct cast.
  Monad transf<R extends Object>([
    @noFuturesAllowed R Function(T e)? noFuturesAllowed,
  ]);

  /// Wraps this [Monad] in a [Some].
  Some<Monad<T>> wrapSome();

  /// Wraps this [Monad] in an [Ok].
  Ok<Monad<T>> wrapOk();

  /// Wraps this [Monad] in a [Resolvable].
  Resolvable<Monad<T>> wrapResolvable();

  /// Wraps this [Monad] in a [Sync].
  Sync<Monad<T>> wrapSync();

  /// Wraps this [Monad] in an [Async].
  Async<Monad<T>> wrapAsync();

  /// Transforms the contained value to `void`.
  Monad<void> asVoid();

  /// Suppresses the linter error `must_use_monad`.
  FutureOr<void> end();

  @override
  @pragma('vm:prefer-inline')
  List<Object?> get props => [value];

  @override
  @pragma('vm:prefer-inline')
  bool? get stringify => false;
}

// --------------------------------------------------
// Source: ./lib/src/_src.g.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// GENERATED - DO NOT MODIFY BY HAND
// See: https://github.com/dev-cetera/df_generate_dart_indexes
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

export './swap/swap_err.dart';
export './swap/swap_async.dart';
export './swap/swap_result.dart';
export './swap/swap_ok.dart';
export './swap/swap_resolvable.dart';
export './swap/swap_some.dart';
export './swap/swap_sync.dart';
export './swap/swap_none.dart';
export './swap/swap_option.dart';
export './utils/safe_completer.dart';
export './utils/safer_map.dart';
export './utils/unit.dart';
export './utils/safer_string.dart';
export './utils/safe_sequencer.dart';
export './utils/safer_iterable.dart';
export './utils/here.dart';
export './utils/debug.dart';
export './utils/lazy.dart';
export './utils/combine_monads.dart';
export './utils/unsafe.dart';
export './utils/let_or_none_collections.dart';
export './utils/ergonomics.dart';
export './utils/let_or_none_map.dart';
export './utils/safe_sequencer_callbacks.dart';
export './utils/map_monad.dart';
export './utils/let_or_none.dart';
export './extensions/result_iterable_extension.dart';
export './extensions/to_unit_on_monad_extensions.dart';
export './extensions/resolvable_iterable_extension.dart';
export './extensions/to_resolvable_extension.dart';
export './extensions/to_safe_stream_extension.dart';
export './extensions/option_iterable_extension.dart';
export './flatten/flatten_option.dart';
export './flatten/flatten_resolvable.dart';
export './flatten/flatten_result.dart';
export './flatten/flatten_resolvable_result.dart';
export './err_model/err_model.dart';
export './monads/monad/monad.dart';

// --------------------------------------------------
// Source: ./lazy_tests/test_safe_sequencer_no_deadlock.dart
// --------------------------------------------------
// import 'package:df_safer_dart/df_safer_dart.dart';

void main() async {
  print('Starting sequence...');
  await sequencer.pushTask(handlerA).end();
  print('Sequence finished.');

  // The final execution order should be sequential, not interleaved.
  print('Execution Order: $executionOrder');
  // Expected: [A starts, A ends, B starts, B ends, C starts and ends]
}

final executionOrder = <String>[];
final sequencer = SafeSequencer<int>();

Resolvable<Option<int>> handlerA(Result<Option<int>> previous) {
  executionOrder.add('A starts');
  // Re-entrant call: Schedule B to run after A is done.
  return sequencer.pushTask(handlerB).map((e) {
    executionOrder.add('A ends');
    return e;
  });
}

Resolvable<Option<int>> handlerB(Result<Option<int>> previous) {
  executionOrder.add('B starts');
  // Re-entrant call: Schedule C to run after B is done.
  return sequencer.pushTask(handlerC).map((e) {
    executionOrder.add('B ends');
    return e;
  });
}

Resolvable<Option<int>> handlerC(Result<Option<int>> previous) {
  executionOrder.add('C starts and ends');
  return Resolvable(() => const Some(3));
}

// --------------------------------------------------
// Source: ./lazy_tests/test_values.dart
// --------------------------------------------------
// import 'package:df_safer_dart/df_safer_dart.dart';

void main() {
  print(const Ok<int>(1).value); // 1
  print(const Ok<int>(1).value.runtimeType); // int
  print(Err<int>('Oh no!').error); // Oh no!
  print(Err<int>('Oh no!').error.runtimeType); // String
  print(Option.from('Hello World!').value); // Hello World!
  print(Option.from('Hello World!').value.runtimeType); // String
  print(const Some('Hello World!').value); // Hello World!
  print(const Some('Hello World!').value.runtimeType); // String
  print(const None<String>().value); // Unit()
  print(const None<String>().value.runtimeType); // Unit
}

// --------------------------------------------------
// Source: ./lazy_tests/test_safe_sequencer_errors.dart
// --------------------------------------------------
// import 'package:df_safer_dart/df_safer_dart.dart';

void main() {
  // ignore: must_use_unsafe_wrapper_or_error
  print(letListOrNone(Ok(Ok([Ok(1), Ok(2), Ok(3)]))).runtimeType);

  // UNSAFE:
  // SafeSequencer(eagerError: true)
  //   ..pushTask((prev) {
  //     print(prev);
  //     return const Sync.unsafe(Ok(Some(1)));
  //   })
  //   ..pushTask((prev) {
  //     print(prev);
  //     throw Err('Oh no!');
  //   })
  //   ..pushTask(
  //     (prev) {
  //       return const Sync.unsafe(Ok(Some(1)));
  //     },
  //     eagerError: false,
  //     onPrevErr: (err) {
  //       print('ERROR!!!');
  //     },
  //   )
  //   ..pushTask((prev) {
  //     print(prev);
  //     return const Sync.unsafe(Ok(Some(1)));
  //   }).end();
}

// --------------------------------------------------
// Source: ./lazy_tests/test_safe_sequencer.dart
// --------------------------------------------------
// import 'package:df_safer_dart/df_safer_dart.dart';

void main() {
  final seq = SafeSequencer();
  seq.pushTask((_) {
    return doWait().toResolvable();
  }).end();
  seq.pushTask((_) {
    return doNotWait().toResolvable();
  }).end();
  seq.pushTask((_) {
    return doWait().toResolvable();
  }).end();
  seq.pushTask((_) {
    return doNotWait().toResolvable();
  }).end();
}

Future<None> doWait() async {
  await Future<void>.delayed(const Duration(milliseconds: 100));
  print('A');
  return const None();
}

None doNotWait() {
  print('B');
  return const None();
}

// --------------------------------------------------
// Source: ./more_examples/async_example/lib/main.dart
// --------------------------------------------------
// import 'package:df_safer_dart/df_safer_dart.dart';
// import 'dart:convert';

typedef KeyValueMap = Map<String, dynamic>;

// A network call that can fail. Async handles both success and exceptions.
Async<String> fetchUserData(int userId) => Async(() async {
  await Future<void>.delayed(
    const Duration(milliseconds: 10),
  ); // Simulate network latency
  if (userId == 1) {
    return '{"config":{"notifications":{"sound":"chime.mp3"}}}';
  }
  if (userId == 2) {
    return '{"config":{}}';
  }
  if (userId == 3) {
    return '{"config": "bad_data"}';
  }
  throw Exception(
    'User Not Found',
  ); // This will be caught by Async and become an Err
});

// A parser that can fail. Sync automatically catches the jsonDecode exception.
Sync<KeyValueMap> parseJson(String json) =>
    Sync(() => jsonDecode(json) as KeyValueMap);

// A helper to safely extract a typed value. It cannot fail, it can only be absent,
// so it returns an Option.
Option<T> getFromMap<T extends Object>(KeyValueMap map, String key) {
  final value = map[key];
  return letAsOrNone<T>(value); // A safe-cast helper from the library
}

/// This is the logic pipeline. It reads like a description of the happy path.
/// There are no try-catch blocks and no null checks.
Async<Option<String>> getUserNotificationSound(int userId) {
  return fetchUserData(userId) // Starts with Async<String>
      .map(
        // The .unwrap() here will throw if parseJson created an Err.
        // The Async monad's .map will catch that throw and turn the
        // whole chain into an Err state.
        (jsonString) => parseJson(jsonString).unwrap(),
      )
      .map(
        // This .map only runs if fetching and parsing were successful.
        (data) =>
            // Start the Option chain to safely drill into the data.
            // .flatMap is used to chain functions that return another Option.
            getFromMap<KeyValueMap>(data, 'config')
                .flatMap(
                  (config) => getFromMap<KeyValueMap>(config, 'notifications'),
                )
                .flatMap(
                  (notifications) => getFromMap<String>(notifications, 'sound'),
                ),
      );
}

void main() async {
  for (var id in [1, 2, 3, 4, 5]) {
    print('Processing User ID: $id');

    // Execute the pipeline. `await value` opens the Async box.
    final finalResult = await getUserNotificationSound(id).value;

    switch (finalResult) {
      case Ok(value: final optionSound):
        switch (optionSound) {
          // Success! The value is an Option<String>.
          // Now open the Option box.
          case Some(value: final sound):
            print('  -> Success: Sound setting is "$sound"\n');
          case None():
            print('  -> Success: Sound setting was not specified.\n');
        }
      case Err err:
        // The entire pipeline failed at some point.
        print('  -> Failure: An error occurred: ${err.error}\n');
    }
  }
}

// --------------------------------------------------
// Source: ./more_examples/flutter_exmple/lib/main.dart
// --------------------------------------------------
// import 'package:df_safer_dart/df_safer_dart.dart';
// import 'package:flutter/material.dart';

void main() {
  final err = Err('test');
  print(err);
  runApp(const MaterialApp(home: SizedBox.shrink()));
}

// --------------------------------------------------
// Source: ./more_examples/result_example/lib/main.dart
// --------------------------------------------------
// import 'package:df_safer_dart/df_safer_dart.dart';

// A function that parses a string to an integer, with ZERO try-catch blocks.
// It returns a Sync, which holds a Result<int>.
Sync<int> parseInt(String value) {
  // The Sync monad executes this function.
  // - If int.parse() succeeds, it returns Ok(result).
  // - If int.parse() throws a FormatException, Sync catches it and returns Err(exception).
  return Sync(() => int.parse(value));
}

void main() {
  final syncResult =
      parseInt('100') // This returns a Sync<int> holding an Ok(100)
          .map((number) => number * 2); // .map only runs on the Ok value

  final result1 = syncResult.value; // This returns a Result<int>

  switch (result1) {
    case Ok(value: final number):
      print('Result: $number');
    case Err():
      print('Failed to parse');
  }
  final result2 = parseInt('Hello!').map((number) => number * 2).value;

  switch (result2) {
    case Ok(value: final number):
      print('Result: $number');
    case Err err:
      print('Failed to parse: ${err.error}');
  }
}

// --------------------------------------------------
// Source: ./more_examples/option_example/lib/main.dart
// --------------------------------------------------
// import 'package:df_safer_dart/df_safer_dart.dart';

// A function that might not find a user.
Option<String> findUsername(int id) {
  final users = {1: 'Alice', 2: 'Bob'};
  final username = users[id];
  // Option.from handles the null check for us.
  return Option.from(username);
}

void main() {
  // Chaining operations:
  final result =
      findUsername(1) // This returns Some('Alice')
          .map((name) => name.toUpperCase()); // .map only runs if it's a Some

  // Prints "Username is: ALICE"
  switch (result) {
    case Some(value: final name):
      print('Username is: $name');
    case None():
      print('User not found.');
  }
}

