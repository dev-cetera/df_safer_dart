// COMBINED FILE - GENERATED BY df_combinator v0.1.0
// DO NOT EDIT THIS FILE DIRECTLY. It is an amalgamation of multiple source files.
// Generated on: 2025-06-24 03:04:58.409104Z UTC

// --- Consolidated Imports ---
import 'dart:convert';
import 'dart:io';
import 'package:df_safer_dart/df_safer_dart.dart';
import 'package:equatable/equatable.dart';
import 'package:flutter/material.dart';
import 'package:path/path.dart' as p;
import 'package:test/test.dart';
// --- End of Imports ---

// --------------------------------------------------
// Source: ./test/test_safe_completer.dart
// --------------------------------------------------
// --- AI GENERATED TEST ---

// import 'package:test/test.dart';
// import 'package:df_safer_dart/df_safer_dart.dart';

void main() {
  UNSAFE:
  {
    group('SafeCompleter Tests', () {
      test('should complete successfully with a synchronous value', () async {
        // Arrange
        final completer = SafeCompleter<int>();
        expect(
          completer.isCompleted,
          isFalse,
          reason: 'Completer should not be completed initially',
        );

        // Act
        completer.complete(42).end();

        // Assert
        expect(
          completer.isCompleted,
          isTrue,
          reason: 'Completer should be marked as completed',
        );
        final result = await completer.resolvable().value;
        expect(result, isA<Ok<int>>());
        expect(result.unwrap(), 42);
      });

      // THIS IS THE CORRECTED TEST
      test('should complete successfully with an asynchronous value', () async {
        // Arrange
        final completer = SafeCompleter<String>();
        final futureValue = Future.delayed(
          const Duration(milliseconds: 20),
          () => 'hello world',
        );

        // Act
        completer.complete(futureValue).end();

        // Assert: The completer is NOT yet complete because the future is still running.
        expect(
          completer.isCompleted,
          isFalse,
          reason: 'Completer is not completed until the future resolves',
        );

        // Await for the resolvable to finish, which internally completes the future.
        final result = await completer.resolvable().value;

        // Assert: NOW the completer should be marked as completed.
        expect(
          completer.isCompleted,
          isTrue,
          reason: 'Completer should be completed after awaiting the result',
        );
        expect(result, isA<Ok<String>>());
        expect(result.unwrap(), 'hello world');
      });

      test(
        'should complete with an error when resolve() is called with an Err',
        () async {
          // Arrange
          final completer = SafeCompleter<int>();
          final error = Err<int>('A deliberate test error');

          // Act
          completer.resolve(Sync.err(error)).end();

          // Assert
          expect(completer.isCompleted, isTrue);
          final resolvable = completer.resolvable();

          // Check that the resolvable completes with an error
          await expectLater(resolvable.value, completion(isA<Err>()));

          final result = await resolvable.value;
          expect((result as Err).error, 'A deliberate test error');
        },
      );

      // THIS IS THE CORRECTED TEST
      test('should complete with an error from a failing future', () async {
        // Arrange
        final completer = SafeCompleter<double>();
        final failingFuture = Future<double>.delayed(
          const Duration(milliseconds: 20),
          () => throw Exception('Network Failure'),
        );

        // Act
        completer.complete(failingFuture).end();

        // Assert: Not yet completed.
        expect(completer.isCompleted, isFalse);

        // Await the resolution.
        final resolvable = completer.resolvable();
        await expectLater(resolvable.value, completion(isA<Err>()));

        // Assert: Now it is completed (with an error).
        expect(completer.isCompleted, isTrue);

        final result = await resolvable.value;
        expect((result as Err).error, isA<Exception>());
        expect(
          (result.err().unwrap() as Exception).toString(),
          'Exception: Network Failure',
        );
      });

      test(
        'should prevent double completion and return an Err on the second attempt',
        () async {
          // Arrange
          final completer = SafeCompleter<String>();

          // Act: First, successful completion
          completer.complete('first value').end();
          expect(completer.isCompleted, isTrue);

          // Act: Second, failing completion attempt
          final secondAttemptResult = completer.complete('second value');

          // Assert
          expect(secondAttemptResult, isA<Sync<String>>());
          final result = secondAttemptResult.sync().unwrap().value;

          expect(
            result,
            isA<Err>(),
            reason: 'Second completion should result in an Err',
          );
          expect(
            (result as Err).error,
            'SafeCompleter<String> is already completed!',
          );

          // Verify that the original value remains unchanged
          final originalValue = await completer.resolvable().unwrap();
          expect(originalValue, 'first value');
        },
      );

      test(
        'should transform a successful value correctly using transf()',
        () async {
          // Arrange
          final intCompleter = SafeCompleter<int>();
          final stringCompleter = intCompleter.transf<String>(
            (i) => 'Value is $i',
          );

          // Act
          intCompleter.complete(123).end();

          // Assert
          final result = await stringCompleter.resolvable().value;
          expect(result, isA<Ok<String>>());
          expect(result.unwrap(), 'Value is 123');
        },
      );

      test(
        'should complete with an error if transf() causes a type cast failure',
        () async {
          // Arrange
          final intCompleter = SafeCompleter<int>();
          // Attempt to transform an int to a double without a converter function, which fails the `as` cast.
          final doubleCompleter = intCompleter.transf<double>();

          // Act
          intCompleter.complete(42).end();

          // Assert
          final result = await doubleCompleter.resolvable().value;
          expect(result, isA<Err>());
          expect(
            (result as Err).error,
            'Failed to transform type int to double.',
          );
        },
      );
    });
  }
}

// --------------------------------------------------
// Source: ./example/main.dart
// --------------------------------------------------
// import 'package:df_safer_dart/df_safer_dart.dart';
// import 'dart:convert';

typedef KeyValueMap = Map<String, dynamic>;

// A network call that can fail. Async handles both success and exceptions.
Async<String> fetchUserData(int userId) => Async(() async {
  await Future<void>.delayed(
    const Duration(milliseconds: 10),
  ); // Simulate network latency
  if (userId == 1) {
    return '{"config":{"notifications":{"sound":"chime.mp3"}}}';
  }
  if (userId == 2) {
    return '{"config":{}}';
  }
  if (userId == 3) {
    return '{"config": "bad_data"}';
  }
  throw Exception(
    'User Not Found',
  ); // This will be caught by Async and become an Err
});

// A parser that can fail. Sync automatically catches the jsonDecode exception.
Sync<KeyValueMap> parseJson(String json) =>
    Sync(() => jsonDecode(json) as KeyValueMap);

// A helper to safely extract a typed value. It cannot fail, it can only be absent,
// so it returns an Option.
Option<T> getFromMap<T extends Object>(KeyValueMap map, String key) {
  final value = map[key];
  return letAsOrNone<T>(value); // A safe-cast helper from the library
}

/// This is the logic pipeline. It reads like a description of the happy path.
/// There are no try-catch blocks and no null checks.
Async<Option<String>> getUserNotificationSound(int userId) {
  return fetchUserData(userId) // Starts with Async<String>
      .map(
        // The .unwrap() here will throw if parseJson created an Err.
        // The Async monad's .map will catch that throw and turn the
        // whole chain into an Err state.
        (jsonString) => UNSAFE(() => parseJson(jsonString).unwrap()),
      )
      .map(
        // This .map only runs if fetching and parsing were successful.
        (data) =>
            // Start the Option chain to safely drill into the data.
            // .flatMap is used to chain functions that return another Option.
            getFromMap<KeyValueMap>(data, 'config')
                .flatMap(
                  (config) => getFromMap<KeyValueMap>(config, 'notifications'),
                )
                .flatMap(
                  (notifications) => getFromMap<String>(notifications, 'sound'),
                ),
      );
}

void main() async {
  for (var id in [1, 2, 3, 4, 5]) {
    print('Processing User ID: $id');

    // Execute the pipeline. `await value` opens the Async box.
    final finalResult = await getUserNotificationSound(id).value;

    switch (finalResult) {
      case Ok(value: final optionSound):
        switch (optionSound) {
          // Success! The value is an Option<String>.
          // Now open the Option box.
          case Some(value: final sound):
            print('  -> Success: Sound setting is "$sound"\n');
          case None():
            print('  -> Success: Sound setting was not specified.\n');
        }
      case Err err:
        // The entire pipeline failed at some point.
        print('  -> Failure: An error occurred: ${err.error}\n');
    }
  }
}

// --------------------------------------------------
// Source: ./.github/scripts/update_readme.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'dart:io';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

void main(List<String> args) {
  if (args.length < 3) {
    print('Usage: dart run update_readme.dart <template_path> <package_name> <package_version>');
    exit(1);
  }

  final templatePath = args[0];
  final packageName = args[1];
  final packageVersion = args[2];

  // These paths are relative to where the script is run (the project root).
  final localContentPath = '_README_CONTENT.md';
  final finalReadmePath = 'README.md';

  // --- 1. Load the master template file from the path provided by the CI ---
  final templateFile = File(templatePath);
  if (!templateFile.existsSync()) {
    print('ERROR: Master README template not found at $templatePath');
    exit(1);
  }
  final readmeTemplate = templateFile.readAsStringSync();

  // --- 2. Load the local content file ---
  final localContentFile = File(localContentPath);
  if (!localContentFile.existsSync()) {
    print('INFO: No _README_CONTENT.md found for $packageName. Cannot generate README.');
    // Exit gracefully if there's no content to inject for this package.
    exit(0);
  }
  final localReadmeContent = localContentFile.readAsStringSync();

  // --- 3. Perform all replacements ---
  var finalContent = readmeTemplate.replaceAll('{{{PACKAGE}}}', packageName);
  finalContent = finalContent.replaceAll('{{{VERSION}}}', packageVersion);
  finalContent = finalContent.replaceAll('{{{_README_CONTENT}}}', localReadmeContent);

  // --- 4. Write the new README.md file ---
  final finalReadmeFile = File(finalReadmePath);
  finalReadmeFile.writeAsStringSync(finalContent);

  print('SUCCESS: README.md for $packageName v$packageVersion has been updated.');
}

// --------------------------------------------------
// Source: ./.github/scripts/update_changelog.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'dart:io';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

void main(List<String> args) {
  final version = args.isNotEmpty ? args[0] : '0.1.0';
  final comitMesssage = args.length > 1 ? args[1].replaceFirst(RegExp(r'^\++'), '') : '';
  final changelogPath = 'CHANGELOG.md';
  final file = File(changelogPath);
  if (!file.existsSync()) {
    print('$changelogPath does not exist.');
    exit(1);
  }
  var contents = file.readAsStringSync();
  contents = contents.replaceAll('# Changelog', '').trim();
  final sections = extractSections(contents);
  final versionExist = sections.where((e) => e.version == version).isNotEmpty;
  if (versionExist) {
    for (final versionSection in sections.where((e) => e.version == version)) {
      if (comitMesssage.isNotEmpty) {
        versionSection.addUpdate(comitMesssage);
      }
    }
  } else {
    sections.add(
      _VersionSection(
        version: version,
        releasedAt: DateTime.now().toUtc(),
        updates: {comitMesssage},
      ),
    );
  }
  contents = '# Changelog\n\n${(sections.toList()..sort((a, b) {
      return compareVersions(b.version, a.version);
    })).map((e) => e.toString()).join('\n')}';

  file.writeAsStringSync(contents);
  print('Changelog updated with version $version.');
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

Set<_VersionSection> extractSections(String contents) {
  final headerPattern = RegExp(r'## \[\d+\.\d+\.\d+(\+\d+)?\]');
  final allVersionMatches = headerPattern.allMatches(contents).toList();
  final results = <_VersionSection>{};
  for (var i = 0; i < allVersionMatches.length; i++) {
    final start = allVersionMatches[i].end;
    final end = i + 1 < allVersionMatches.length ? allVersionMatches[i + 1].start : contents.length;
    final sectionContents = contents.substring(start, end).trim();
    final lines = sectionContents.split('\n').where((line) => line.isNotEmpty).toList();
    final version =
        allVersionMatches[i].group(0)!.substring(4, allVersionMatches[i].group(0)!.length - 1);
    var releasedAt = DateTime.now().toUtc();
    final updates = <String>{};
    final old = lines
        .map((e) => e.trim())
        .where((e) => e.isNotEmpty)
        .map((e) => e.startsWith('-') ? e.substring(1) : e)
        .map((e) => e.trim())
        .where((e) => e.isNotEmpty);
    for (var line in old) {
      if (line.contains('Released @')) {
        releasedAt = parseReleaseDate(line);
      } else {
        updates.add(line);
      }
    }
    results.add(
      _VersionSection(
        version: version,
        releasedAt: releasedAt,
        updates: updates,
      ),
    );
  }

  return results;
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class _VersionSection {
  //
  //
  //

  String version;
  DateTime releasedAt;
  Set<String> updates;

  //
  //
  //

  _VersionSection({
    required this.version,
    required this.releasedAt,
    Set<String>? updates,
  }) : updates = updates ?? {};

  //
  //
  //

  void addUpdate(String update) {
    updates.add(update);
    releasedAt = DateTime.now().toUtc();
  }

  //
  //
  //

  @override
  String toString() {
    final updatesString = updates.map((update) => '- $update').join('\n');
    return '## [$version]\n\n- Released @ ${releasedAt.month}/${releasedAt.year} (UTC)\n$updatesString\n';
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

int compareVersions(String version1, String version2) {
  List<int> parseVersion(String version) {
    // Split by the '+' first to handle the build number
    final parts = version.split('+');
    final versionParts = parts[0].split('.').map(int.tryParse).map((e) => e ?? 0).toList();
    // Add the build number as the last part (if it exists)
    if (parts.length > 1) {
      versionParts.add(int.tryParse(parts[1]) ?? 0);
    }
    return versionParts;
  }

  final v1 = parseVersion(version1);
  final v2 = parseVersion(version2);
  final maxLength = v1.length > v2.length ? v1.length : v2.length;
  for (var i = 0; i < maxLength; i++) {
    final part1 = i < v1.length ? v1[i] : 0;
    final part2 = i < v2.length ? v2[i] : 0;
    if (part1 > part2) return 1;
    if (part1 < part2) return -1;
  }
  return 0;
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

DateTime parseReleaseDate(String line) {
  if (line.contains('Released @')) {
    final temp = line.split('Released @').last.trim().replaceAll(' (UTC)', '');
    final parts = temp.split('/');
    if (parts.length == 2) {
      final month = int.tryParse(parts[0]) ?? 1;
      final year = int.tryParse(parts[1]) ?? DateTime.now().year;
      return DateTime.utc(year, month);
    }
  }

  return DateTime.now().toUtc();
}

// --------------------------------------------------
// Source: ./lib/_common.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

export 'src/_src.g.dart';

export 'dart:async' show FutureOr, Completer, StreamTransformer;
export 'dart:convert' show JsonEncoder, JsonDecoder;
export 'package:equatable/equatable.dart' show Equatable;
export 'dart:collection' show Queue;
export 'package:meta/meta.dart';
export 'package:stack_trace/stack_trace.dart';

export 'package:df_type/df_type.dart';
export 'package:df_safer_dart_annotations/df_safer_dart_annotations.dart';

// --------------------------------------------------
// Source: ./lib/df_safer_dart.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

/// A package inspired by functional programming designed to enhance the structure, safety, and debuggability of your applications.
library;

export 'src/_src.g.dart';

// --------------------------------------------------
// Source: ./lib/src/unit/unit.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:equatable/equatable.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A type representing a "no value" unit, similar to `void` but usable in
/// generics.
final class Unit implements Equatable {
  const Unit._();

  @pragma('vm:prefer-inline')
  factory Unit() => instance;

  static const Unit instance = Unit._();
  static const Unit i = instance;

  @override
  List<Object?> get props => [];

  @override
  String toString() => 'Unit()';

  @override
  bool? get stringify => false;
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

const UNIT = Unit.instance;

// --------------------------------------------------
// Source: ./lib/src/unit/to_unit_on_monad_extensions.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

// Void.

extension $ToUnitOnVoidMonad on Monad<void> {
  Monad<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnVoidOption on Option<void> {
  Option<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnVoidSome on Some<void> {
  Some<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnVoidNone on None<void> {
  None<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnVoidResolvable on Resolvable<void> {
  Resolvable<Unit> toUnit() => then((_) => Unit());
}

extension $ToUnitOnVoidSync on Sync<void> {
  Sync<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnVoidAsync on Async<void> {
  Async<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnVoidResult on Result<void> {
  Result<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnVoidOk on Ok<void> {
  Ok<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnVoidErr on Err<void> {
  Err<Unit> toUnit() => map((_) => Unit());
}

// Object.

extension $ToUnitOnObjectMonad on Monad<Object> {
  Monad<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnObjectOption on Option<Object> {
  Option<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnObjectSome on Some<Object> {
  Some<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnObjectNone on None<Object> {
  None<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnObjectResolvable on Resolvable<Object> {
  Resolvable<Unit> toUnit() => then((_) => Unit());
}

extension $ToUnitOnObjectSync on Sync<Object> {
  Sync<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnObjectAsync on Async<Object> {
  Async<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnObjectResult on Result<Object> {
  Result<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnObjectOk on Ok<Object> {
  Ok<Unit> toUnit() => map((_) => Unit());
}

extension $ToUnitOnObjectErr on Err<Object> {
  Err<Unit> toUnit() => map((_) => Unit());
}

// --------------------------------------------------
// Source: ./lib/src/tools/safe_completer.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class SafeCompleter<T extends Object> {
  //
  //
  //

  final _completer = Completer<T>();
  Option<FutureOr<T>> _value = const None();
  bool _isCompleting = false;

  //
  //
  //

  /// Completes the operation with the provided [resolvable].
  Resolvable<T> resolve(Resolvable<T> resolvable) {
    if (_isCompleting) {
      return Sync.err(Err('SafeCompleter<$T> is already resolving!'));
    }
    _isCompleting = true;
    if (isCompleted) {
      _isCompleting = false;
      return Sync.err(Err('SafeCompleter<$T> is already completed!'));
    }

    return resolvable.ifOk((self, ok) {
      final okValue = ok.unwrap();
      _value = Some(okValue);
      _completer.complete(okValue);
      _isCompleting = false;
    }).ifErr((self, err) {
      _completer.completeError(err);
      _isCompleting = false;
    });
  }

  /// Completes the operation with the provided [value].
  @pragma('vm:prefer-inline')
  Resolvable<T> complete(FutureOr<T> value) {
    return resolve(Resolvable(() => value));
  }

  /// Returns a [Resolvable] that will complete when this [SafeCompleter] is
  /// completed.
  @pragma('vm:prefer-inline')
  Resolvable<T> resolvable() {
    return Resolvable(() {
      // Use a switch on the Option '_value' for clear and safe state checking.
      switch (_value) {
        case Some(value: final okValue):
          return okValue;
        case None():
          return _completer.future;
      }
    });
  }

  /// Checks if the value has been set or if the [SafeCompleter] is completed.
  @pragma('vm:prefer-inline')
  bool get isCompleted => _completer.isCompleted || _value.isSome();

  /// Transforms the type of the value managed by this [SafeCompleter].
  SafeCompleter<R> transf<R extends Object>([
    @noFuturesAllowed R Function(T e)? noFuturesAllowed,
  ]) {
    final completer = SafeCompleter<R>();
    resolvable().then((e) {
      try {
        final result = noFuturesAllowed != null ? noFuturesAllowed(e) : (e as R);
        completer.resolve(Sync.okValue(result)).end();
      } catch (error, stackTrace) {
        completer
            .resolve(
              Sync.err(
                Err(
                  error,
                  stackTrace: stackTrace,
                ),
              ),
            )
            .end();
      }
      return e;
    }).end();
    return completer;
  }
}

// --------------------------------------------------
// Source: ./lib/src/tools/concurrent_task_batch.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Manages and executes a batch of tasks concurrently.
class ConcurrentTaskBatch<T extends Object> {
  //
  //
  //

  ConcurrentTaskBatch({
    bool eagerError = true,
    Duration? minTaskDuration,
    Resolvable<Object> Function(Err<Object>)? onError,
  })  : _minTaskDuration = minTaskDuration,
        _eagerError = eagerError,
        _onError = onError;

  /// Creates a new [ConcurrentTaskBatch] instance by copying tasks from another.
  factory ConcurrentTaskBatch.from(ConcurrentTaskBatch<T> other) {
    return ConcurrentTaskBatch<T>(eagerError: other._eagerError).._tasks = Queue.from(other._tasks);
  }

  var _tasks = Queue<Task<T>>.from([]);
  final Duration? _minTaskDuration;
  final bool _eagerError;
  final TOnTaskError? _onError;

  bool _isExecuting = false;

  /// Returns `true` if tasks are currently being executed.
  bool get isExecuting => _isExecuting;

  /// Returns `true` if tasks are not currently being executed.
  bool get isNotExecuting => !isExecuting;

  /// Adds a new task to the batch.
  ///
  /// - [handler]: The function to execute for this task.
  /// - [onError]: A specific error handler for this task.
  /// - [eagerError]: Overrides the batch's `eagerError` behavior for this task.
  /// - [minTaskDuration]: Overrides the batch's `minTaskDuration` for this task.
  void add(
    @noFuturesAllowed TTaskHandler<T> handler, {
    @noFuturesAllowed TOnTaskError? onError,
    bool? eagerError,
    Duration? minTaskDuration,
  }) {
    final task = Task(
      handler: handler,
      onError: onError,
      eagerError: eagerError ?? eagerError,
      minTaskDuration: minTaskDuration,
    );
    addTask(task);
  }

  /// Adds a pre-configured [Task] object to the batch.
  void addTask(Task<T> task) {
    _ifNotExecuting(() => _tasks.add(task));
  }

  /// Removes a specific [task] from the batch.
  /// Returns `true` if the task was found and removed, `false` otherwise.
  bool removeTask(Task<T> task) {
    return _ifNotExecuting(() => _tasks.remove(task)) ?? false;
  }

  /// Adds multiple [Task] objects to the batch.
  void addAllTasks(Iterable<Task<T>> tasks) {
    _ifNotExecuting(() => _tasks.addAll(tasks));
  }

  /// Clears all tasks from the batch.
  ///
  /// Returns `true` if tasks were cleared, `false` if called during execution.
  bool clearTasks() {
    return _ifNotExecuting(() {
          _tasks.clear();
          return true;
        }) ??
        false;
  }

  /// Removes the first task from the batch.
  ///
  /// Returns `true` if a task was removed, `false` if the batch was empty or
  /// if called during execution.
  bool removeFirstTask() {
    return _ifNotExecuting(() {
          _tasks.removeFirst();
          return true;
        }) ??
        false;
  }

  /// Removes the last task from the batch.
  ///
  /// Returns `true` if a task was removed, `false` if the batch was empty or
  /// if called during execution.
  bool removeLastTask() {
    return _ifNotExecuting(() {
          _tasks.removeLast();
          return true;
        }) ??
        false;
  }

  /// Internal helper to ensure modifications are not made while the sequencer
  /// is busy.
  R? _ifNotExecuting<R>(R Function() caller) {
    assert(!_isExecuting);
    if (!_isExecuting) {
      return caller();
    }
    return null;
  }

  /// Executes all tasks in the batch concurrently.
  TResolvableOption<T> executeTasks() {
    final itemFactories = _tasks.map(
      (task) => () => task
          .handler(Ok(None<T>()))
          .withMinDuration(_minTaskDuration ?? task.minTaskDuration)
          .value,
    );
    _isExecuting = true;
    return Resolvable(
      () => waitF<Option<T>>(
        itemFactories,
        (_) => const None(),
        eagerError: _eagerError,
        onError: (error, stackTrace) {
          return _onError
              ?.call(
                Err(
                  error,
                  stackTrace: stackTrace,
                ),
              )
              .value;
        },
      ),
    ).whenComplete((e) {
      _isExecuting = false;
      return e;
    });
  }
}

// --------------------------------------------------
// Source: ./lib/src/tools/task_sequencer.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class TaskSequencer<T extends Object> {
  //
  //
  //

  TaskSequencer({
    @noFuturesAllowed TOnTaskError? onPrevError,
    bool eagerError = false,
    Duration? minTaskDuration,
  })  : _onPrevError = onPrevError,
        _eagerError = eagerError,
        _minTaskDuration = minTaskDuration;

  final TOnTaskError? _onPrevError;
  final bool _eagerError;
  final Duration? _minTaskDuration;

  //
  //
  //

  TResolvableOption<T> get completion => _current;
  late TResolvableOption<T> _current = Sync.okValue(const None());

  int _executionCount = 0;
  bool get isExecuting => _executionCount > 0;
  bool get isNotExecuting => !isExecuting;

  final _reentrantQueue = Queue<Task<T>>();

  //
  //
  //

  SequencedTaskBatch<T> newBatch() => SequencedTaskBatch(sequencer: this);

  //
  //
  //

  TResolvableOption<T> then(
    @noFuturesAllowed TTaskHandler<T> handler, {
    @noFuturesAllowed TOnTaskError? onPrevError,
    bool? eagerError,
    Duration? minTaskDuration,
  }) {
    final task = Task<T>(
      handler: handler,
      onError: onPrevError,
      eagerError: eagerError,
      minTaskDuration: minTaskDuration,
    );
    if (isExecuting) {
      _reentrantQueue.add(task);
      return _current;
    }
    return _chainTask(task);
  }

  TResolvableOption<T> _chainTask(Task<T> task) {
    _executionCount++;
    final value = _current.value;
    if (value is TResultOption<T>) {
      _current = _executeStep(task, value);
    } else {
      _current = Async(() async => _executeStep(task, await value)).flatten();
    }

    final currentValue = _current.value;
    if (currentValue is Future<TResultOption<T>>) {
      currentValue.whenComplete(() {
        _executionCount--;
        _processReentrantQueue();
      });
    } else {
      _executionCount--;
      _processReentrantQueue();
    }

    return _current;
  }

  TResolvableOption<T> _executeStep(
    Task<T> task,
    TResultOption<T> previousResult,
  ) {
    Resolvable errorResolvable = resolvableNone();
    if (previousResult case Err err) {
      final a = Option.from(_onPrevError).map((e) => Resolvable(() => e(err)).flatten());
      final b = Option.from(task.onError).map((e) => Resolvable(() => e(err)).flatten());
      if ((a, b) case (Some(value: final someValueA), Some(value: final someValueB))) {
        errorResolvable = Resolvable.zip2(someValueA, someValueB);
      } else if (a case Some(value: final someValueA)) {
        errorResolvable = someValueA;
      } else if (b case Some(value: final someValueB)) {
        errorResolvable = someValueB;
      }
      if (task.eagerError ?? _eagerError) {
        final output = Sync.result(previousResult);
        return Resolvable.zip2(output, errorResolvable).then((e) => e.$1);
      }
    }
    final output = task.handler(previousResult).withMinDuration(
          task.minTaskDuration ?? _minTaskDuration,
        );
    return Resolvable.zip2(output, errorResolvable).then((e) => e.$1);
  }

  void _processReentrantQueue() {
    if (_reentrantQueue.isNotEmpty) {
      final nextTask = _reentrantQueue.removeFirst();
      _chainTask(nextTask).end();
    }
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

typedef TTaskHandler<T extends Object> = TResolvableOption<T> Function(TResultOption<T> previous);

typedef TOnTaskError = Resolvable Function(Err err);

final class Task<T extends Object> {
  @noFuturesAllowed
  final TTaskHandler<T> handler;
  @noFuturesAllowed
  final TOnTaskError? onError;
  final bool? eagerError;
  final Duration? minTaskDuration;

  const Task({
    required this.handler,
    required this.onError,
    required this.eagerError,
    required this.minTaskDuration,
  });
}

// --------------------------------------------------
// Source: ./lib/src/tools/to_safe_stream_extension.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// An extension on [Stream] to provide a safe way to handle stream events.
extension $ToSafeStreamExtension<T extends Object> on Stream<T> {
  /// Transforms a [Stream] into a [Stream].
  ///
  /// Each data event from the original stream is wrapped in an [Ok].
  /// Each error event is wrapped in an [Err].
  ///
  /// If [cancelOnError] is `true`, the stream will be closed upon the first
  /// error.
  Stream<Result<T>> toSafeStream({required bool cancelOnError}) {
    return transform(
      StreamTransformer.fromHandlers(
        handleData: (data, sink) {
          sink.add(Ok(data));
        },
        handleError: (error, stackTrace, sink) {
          if (error is Err) {
            sink.add(error.transfErr());
          } else {
            sink.add(Err<T>(error));
          }
          if (cancelOnError) {
            sink.close();
          }
        },
        handleDone: (sink) {
          sink.close();
        },
      ),
    );
  }
}

// --------------------------------------------------
// Source: ./lib/src/tools/let_or_none/let_or_none_collections.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/_common.dart';

// import '/src/utils/_no_stack_overflow_wrapper.dart' show NoStackOverflowWrapper;

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Converts [input] to `Iterable<Option<T>>`, returning [None] on failure.
///
/// Supported types:
///
/// - Any sync [Monad] chain.
/// - [bool]
/// - [num]
/// - [double]
/// - [int]
/// - [String]
/// - [DateTime]
/// - [Uri],
/// - [Iterable] (dynamic)
/// - [List]  (dynamic)
/// - [Set] (dynamic)
/// - [Map] (dynamic, dynamic)
Option<Iterable<Option<T>>> letIterableOrNone<T extends Object>(dynamic input) {
  if (input is Monad) {
    return switch (input.rawSync().value) {
      Ok(value: final okValue) => letIterableOrNone(NoStackOverflowWrapper(okValue)),
      Err() => const None(),
    };
  }
  return switch (input is NoStackOverflowWrapper ? input.value : input) {
    final Iterable<dynamic> i => Some(i.map((e) => letOrNone<T>(e))),
    final String s =>
      jsonDecodeOrNone<Iterable<dynamic>>(s).map((i) => i.map((e) => letOrNone<T>(e))),
    _ => const None(),
  };
}

// Converts [input] to `List<Option<T>>`, returning [None] on failure.
///
/// Supported types:
///
/// - Any sync [Monad] chain.
/// - [bool]
/// - [num]
/// - [double]
/// - [int]
/// - [String]
/// - [DateTime]
/// - [Uri],
/// - [Iterable] (dynamic)
/// - [List]  (dynamic)
/// - [Set] (dynamic)
/// - [Map] (dynamic, dynamic)
Option<List<Option<T>>> letListOrNone<T extends Object>(dynamic input) {
  return letIterableOrNone<T>(input).map((e) => List.from(e));
}

// Converts [input] to `Set<Option<T>>`, returning [None] on failure.
///
/// Supported types:
///
/// - Any sync [Monad] chain.
/// - [bool]
/// - [num]
/// - [double]
/// - [int]
/// - [String]
/// - [DateTime]
/// - [Uri],
/// - [Iterable] (dynamic)
/// - [List]  (dynamic)
/// - [Set] (dynamic)
/// - [Map] (dynamic, dynamic)
Option<Set<Option<T>>> letSetOrNone<T extends Object>(dynamic input) {
  return letIterableOrNone<T>(input).map((e) => Set.from(e));
}

// --------------------------------------------------
// Source: ./lib/src/tools/let_or_none/let_or_none_map.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import '/_common.dart';

// import '/src/utils/_no_stack_overflow_wrapper.dart' show NoStackOverflowWrapper;

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Converts [input] to `Map<K, Option<V>>`, returning [None] on failure.
///
/// Supported types:
///
/// - Any sync [Monad] chain.
/// - [bool]
/// - [num]
/// - [double]
/// - [int]
/// - [String]
/// - [DateTime]
/// - [Uri],
/// - [Iterable] (dynamic)
/// - [List]  (dynamic)
/// - [Set] (dynamic)
/// - [Map] (dynamic, dynamic)
Option<Map<K, Option<V>>> letMapOrNone<K extends Object, V extends Object>(dynamic input) {
  if (input is Monad) {
    return switch (input.rawSync().value) {
      Ok(value: final okValue) => letMapOrNone<K, V>(NoStackOverflowWrapper(okValue)),
      Err() => const None(),
    };
  }

  return switch (input is NoStackOverflowWrapper ? input.value : input) {
    final Map<dynamic, dynamic> m => _convertMapOrNone<K, V>(m),
    final String s => jsonDecodeOrNone<Map<dynamic, dynamic>>(s.trim())
        .map((d) => _convertMapOrNone<K, V>(d))
        .flatten(),
    final Monad m => switch (m.rawSync().value) {
        Ok(value: final okValue) => letMapOrNone<K, V>(okValue),
        Err() => const None(),
      },
    _ => const None(),
  };
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

Option<Map<K, Option<V>>> _convertMapOrNone<K extends Object, V extends Object>(
  Map<dynamic, dynamic> map,
) {
  final buffer = <K, Option<V>>{};
  for (final entry in map.entries) {
    final keyOption = letOrNone<K>(entry.key);
    if (keyOption.isNone()) {
      return const None();
    }
    final valueOption = letOrNone<V>(entry.value);
    buffer[keyOption.unwrap()] = valueOption;
  }
  return Some(buffer);
}

// --------------------------------------------------
// Source: ./lib/src/tools/let_or_none/let_or_none.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/_common.dart';

// import '/src/utils/_no_stack_overflow_wrapper.dart' show NoStackOverflowWrapper;

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Attempts to convert a dynamic [input] to the specified type [T], returning
/// [None] on failure.
///
/// This is a high-level dispatcher that uses more specific `let...OrNone`
/// helpers based on the target type [T].
///
/// Supported types:
///
/// - Any sync [Monad] chain.
/// - [bool]
/// - [num]
/// - [double]
/// - [int]
/// - [String]
/// - [DateTime]
/// - [Uri],
/// - [Iterable] (dynamic)
/// - [List]  (dynamic)
/// - [Set] (dynamic)
/// - [Map] (dynamic, dynamic)
Option<T> letOrNone<T extends Object>(dynamic input) {
  assert(
    !(isSubtype<T, List<dynamic>>() && !isSubtype<List<dynamic>, T>()) &&
        !(isSubtype<T, Set<dynamic>>() && !isSubtype<Set<dynamic>, T>()) &&
        !(isSubtype<T, Iterable<dynamic>>() && !isSubtype<Iterable<dynamic>, T>()) &&
        !(isSubtype<T, Map<dynamic, dynamic>>() && !isSubtype<Map<dynamic, dynamic>, T>()),
    'letOrNone<$T> cannot be used with specific collection types due to type safety. '
    'Only generic collection types are supported.',
  );
  // 1. Unwrap any monad to get the raw value.
  if (input is Monad) {
    return switch (input.rawSync().value) {
      Ok(value: final okValue) => letOrNone<T>(NoStackOverflowWrapper(okValue)),
      Err() => const None(),
    };
  }
  final rawInput = input is NoStackOverflowWrapper ? input.value : input;

  // 2. Handle null and direct type matches upfront for performance.
  if (rawInput is T) return Some(rawInput);
  if (rawInput == null) return const None();

  // 3. Dispatch to specific conversion logic based on the target type.
  final result = () {
    if (typeEquality<T, double>() || typeEquality<T, double?>()) {
      return letDoubleOrNone(rawInput);
    } else if (typeEquality<T, int>() || typeEquality<T, int?>()) {
      return letIntOrNone(rawInput);
    } else if (typeEquality<T, bool>() || typeEquality<T, bool?>()) {
      return letBoolOrNone(rawInput);
    } else if (typeEquality<T, DateTime>() || typeEquality<T, DateTime?>()) {
      return letDateTimeOrNone(rawInput);
    } else if (typeEquality<T, Uri>() || typeEquality<T, Uri?>()) {
      return letUriOrNone(rawInput);
    } else if (isSubtype<T, List<dynamic>>()) {
      return letListOrNone<Object>(rawInput);
    } else if (isSubtype<T, Set<dynamic>>()) {
      return letSetOrNone<Object>(rawInput);
    } else if (isSubtype<T, Iterable<dynamic>>()) {
      return letIterableOrNone<Object>(rawInput);
    } else if (isSubtype<T, Map<dynamic, dynamic>>()) {
      return letMapOrNone<Object, Object>(rawInput);
    } else if (typeEquality<T, String>() || typeEquality<T, String?>()) {
      return letAsStringOrNone(rawInput);
    }
    return rawInput;
  }();

  // 4. Perform a final safe cast on the result of the conversion.
  return letAsOrNone<T>(result);
}

/// Casts [input] to type [T], returning [None] on failure.
///
/// Supported types:
///
/// - Any sync [Monad] chain.
/// - [Object]
Option<T> letAsOrNone<T extends Object>(dynamic input) {
  if (input is Monad) {
    return switch (input.rawSync().value) {
      Ok(value: final okValue) => letAsOrNone<T>(NoStackOverflowWrapper(okValue)),
      Err() => const None(),
    };
  }
  final rawInput = input is NoStackOverflowWrapper ? input.value : input;
  return rawInput is T ? Some(rawInput) : const None();
}

/// Converts [input] to [String], returning [None] on failure.
///
/// Supported types:
///
/// - Any sync [Monad] chain.
/// - [Object]
Option<String> letAsStringOrNone(dynamic input) {
  if (input is Monad) {
    return switch (input.rawSync().value) {
      Ok(value: final okValue) => letAsStringOrNone(NoStackOverflowWrapper(okValue)),
      Err() => const None(),
    };
  }
  final rawInput = input is NoStackOverflowWrapper ? input.value : input;

  try {
    return Some(rawInput.toString());
  } catch (_) {
    return const None();
  }
}

/// Parses a JSON [input] into an object of type [T], returning [None] on
/// failure.
///
/// Supported types:
///
/// - Any sync [Monad] chain.
/// - [Object]
Option<T> jsonDecodeOrNone<T extends Object>(dynamic input) {
  return letAsStringOrNone(input).map((rawInput) {
    try {
      final decoded = const JsonDecoder().convert(rawInput);
      return decoded is T ? Some<T>(decoded) : None<T>();
    } catch (e, _) {
      return None<T>();
    }
  }).flatten();
}

/// Converts [input] to [num], returning [None] on failure.
///
/// Supported types:
///
/// - Any sync [Monad] chain.
/// - [String]
/// - [num]
/// - [double]
/// - [int]
/// - [String]
Option<num> letNumOrNone(dynamic input) {
  if (input is Monad) {
    return switch (input.rawSync().value) {
      Ok(value: final okValue) => letNumOrNone(NoStackOverflowWrapper(okValue)),
      Err() => const None(),
    };
  }
  return switch (input is NoStackOverflowWrapper ? input.value : input) {
    final num value => Some(value),
    final String string => Option.from(num.tryParse(string.trim())),
    _ => const None(),
  };
}

/// Converts [input] to [int], returning [None] on failure.
///
/// Supported types:
///
/// - Any sync [Monad] chain.
/// - [String]
/// - [num]
/// - [double]
/// - [int]
/// - [String]
@pragma('vm:prefer-inline')
Option<int> letIntOrNone(dynamic input) {
  return letNumOrNone(input).map((n) => n.toInt());
}

/// Converts [input] to [double], returning [None] on failure.
///
/// Supported types:
///
/// - Any sync [Monad] chain.
/// - [String]
/// - [num]
/// - [double]
/// - [int]
/// - [String]
@pragma('vm:prefer-inline')
Option<double> letDoubleOrNone(dynamic input) {
  return letNumOrNone(input).map((n) => n.toDouble());
}

/// Converts [input] to [bool], returning [None] on failure.
///
/// Supported types:
///
/// - Any sync [Monad] chain.
/// - [String]
/// - [bool]
Option<bool> letBoolOrNone(dynamic input) {
  if (input is Monad) {
    return switch (input.rawSync().value) {
      Ok(value: final okValue) => letBoolOrNone(NoStackOverflowWrapper(okValue)),
      Err() => const None(),
    };
  }
  return switch (input is NoStackOverflowWrapper ? input.value : input) {
    final bool value => Some(value),
    final String string => Option.from(bool.tryParse(string.trim(), caseSensitive: false)),
    _ => const None(),
  };
}

/// Converts [input] to [Uri], returning [None] on failure.
///
/// Supported types:
///
/// - Any sync [Monad] chain.
/// - [String]
/// - [Uri]
Option<Uri> letUriOrNone(dynamic input) {
  if (input is Monad) {
    return switch (input.rawSync().value) {
      Ok(value: final okValue) => letUriOrNone(NoStackOverflowWrapper(okValue)),
      Err() => const None(),
    };
  }
  return switch (input is NoStackOverflowWrapper ? input.value : input) {
    final Uri value => Some(value),
    final String string => Option.from(Uri.tryParse(string.trim())),
    _ => const None(),
  };
}

/// Converts [input] to [bool], returning [None] on failure.
///
/// Supported types:
///
/// - Any sync [Monad] chain.
/// - [String]
/// - [DateTime]
Option<DateTime> letDateTimeOrNone(dynamic input) {
  if (input is Monad) {
    return switch (input.rawSync().value) {
      Ok(value: final okValue) => letDateTimeOrNone(NoStackOverflowWrapper(okValue)),
      Err() => const None(),
    };
  }
  return switch (input is NoStackOverflowWrapper ? input.value : input) {
    final DateTime value => Some(value),
    final String string => Option.from(DateTime.tryParse(string.trim())),
    _ => const None(),
  };
}

// --------------------------------------------------
// Source: ./lib/src/tools/sequenced_task_batch.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class SequencedTaskBatch<T extends Object> {
  //
  //
  //

  SequencedTaskBatch({
    TaskSequencer<T>? sequencer,
  }) : _sequencer = sequencer ?? TaskSequencer<T>();

  factory SequencedTaskBatch.from(
    SequencedTaskBatch<T> other, {
    TaskSequencer<T>? sequencer,
  }) {
    return SequencedTaskBatch<T>(sequencer: sequencer).._tasks = Queue.from(other._tasks);
  }

  final TaskSequencer<T> _sequencer;
  var _tasks = Queue<Task<T>>.from([]);

  void add(
    @noFuturesAllowed TTaskHandler<T> handler, {
    @noFuturesAllowed TOnTaskError? onError,
    bool? eagerError,
    Duration? minTaskDuration,
  }) {
    final task = Task(
      handler: handler,
      onError: onError,
      eagerError: eagerError,
      minTaskDuration: minTaskDuration,
    );
    addTask(task);
  }

  void addTask(Task<T> task) {
    _ifNotExecuting(() => _tasks.add(task));
  }

  bool removeTask(Task<T> task) {
    return _ifNotExecuting(() => _tasks.remove(task)) ?? false;
  }

  void addAllTasks(Iterable<Task<T>> tasks) {
    _ifNotExecuting(() => _tasks.addAll(tasks));
  }

  bool clearTasks() {
    return _ifNotExecuting(() {
          _tasks.clear();
          return true;
        }) ??
        false;
  }

  bool removeFirstTask() {
    return _ifNotExecuting(() {
          _tasks.removeFirst();
          return true;
        }) ??
        false;
  }

  bool removeLastTask() {
    return _ifNotExecuting(() {
          _tasks.removeLast();
          return true;
        }) ??
        false;
  }

  R? _ifNotExecuting<R>(R Function() caller) {
    assert(_sequencer.isNotExecuting);
    if (_sequencer.isNotExecuting) {
      return caller();
    }
    return null;
  }

  TResolvableOption<T> executeTasks() {
    while (_tasks.isNotEmpty) {
      _executeTask(_tasks.removeFirst()).end();
    }
    return _sequencer.completion;
  }

  TResolvableOption<T> _executeTask(Task<T> task) {
    return _sequencer.then(
      task.handler,
      onPrevError: task.onError,
      eagerError: task.eagerError,
    );
  }
}

// --------------------------------------------------
// Source: ./lib/src/utils/_no_stack_overflow_wrapper.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

@internal
final class NoStackOverflowWrapper<T> {
  final T value;
  const NoStackOverflowWrapper(this.value);
}

// --------------------------------------------------
// Source: ./lib/src/odd/here.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by DevCetra.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:path/path.dart' as p;

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A utility class for capturing the current code location (file, line,
/// column, member).
///
/// This is useful for debugging and logging purposes, especially when dealing
/// with errors or unexpected states.
final class Here {
  //
  //
  //

  final int level;

  //
  //
  //

  const Here(this.level) : assert(level >= 0);

  /// Returns the [Frame] for the current code location, skipping the initial
  /// stack levels specified by [level].
  ///
  /// Returns `null` if no suitable frame is found.
  Option<Frame> call() {
    final frames = Trace.current(level).frames;
    for (var n = 0; n < frames.length; n++) {
      final frame = frames[n];
      final lineNumber = frame.line;
      final columnNumber = frame.column;
      if (lineNumber != null && columnNumber != null) {
        return Some(frame);
      }
    }
    return const None();
  }

  /// A string representing the basepath location of the call.
  Option<String> get basepath => call().map(
        (e) => [
          p.basenameWithoutExtension(e.library),
          if (e.member != null) e.member,
        ].join('/'),
      );

  /// A string representing the location of the call.
  Option<String> get location => call().map((e) => e.location);
}

// --------------------------------------------------
// Source: ./lib/src/odd/debug.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

/// A constatnt that can be used to check if your app is running in a Dart only
/// or Flutter environment. It's `true` if `dart.library.ui` is defined and
/// `false` otherwise.
const kIsDartLibraryUI = bool.fromEnvironment('dart.library.ui');

// --------------------------------------------------
// Source: ./lib/src/odd/lazy.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A class that provides lazy initialization for instances of type [T].
class Lazy<T extends Object> {
  /// Holds the current singleton instance of type [T] or `null` if no
  /// [singleton] instance was created.
  @protected
  Option<Resolvable<T>> currentInstance = const None();

  /// A constructor function that creates instances of type [T].
  final LazyConstructor<T> _constructor;

  Lazy(this._constructor);

  /// Returns the singleton instance [currentInstance], or creating it if necessary.
  @pragma('vm:prefer-inline')
  Resolvable<T> get singleton {
    return (currentInstance.isNone() ? currentInstance = Some(_constructor()) : currentInstance)
        .unwrap();
  }

  /// Returns a new instance of [T] each time, acting as a factory.
  @pragma('vm:prefer-inline')
  Resolvable<T> get factory => _constructor();

  /// Resets the singleton instance, by setting [currentInstance] back to `null`
  /// allowing it to be re-created via [singleton].
  @pragma('vm:prefer-inline')
  void resetSingleton() => currentInstance = const None();
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

typedef LazyConstructor<T extends Object> = Resolvable<T> Function();

// --------------------------------------------------
// Source: ./lib/src/err_model/_err_model.g.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// GENERATED - DO NOT MODIFY BY HAND
// See: https://github.com/dev-cetera/df_generate_dart_models
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: annotate_overrides
// ignore_for_file: overridden_fields

// part of 'err_model.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Generated class for [_ErrModel].
class ErrModel {
  //
  //
  //

  /// No description provided.
  final String? type;

  /// No description provided.
  final String? error;

  /// No description provided.
  final int? statusCode;

  /// No description provided.
  final List<String>? stackTrace;

  /// Constructs a new instance of [ErrModel]
  /// from optional and required parameters.
  const ErrModel({
    required this.type,
    required this.error,
    this.statusCode,
    this.stackTrace,
  });

  /// Creates a copy of this instance, replacing the specified fields.
  ErrModel copyWith({
    String? type,
    String? error,
    int? statusCode,
    List<String>? stackTrace,
  }) {
    return ErrModel(
      type: type ?? this.type,
      error: error ?? this.error,
      statusCode: statusCode ?? this.statusCode,
      stackTrace: stackTrace ?? this.stackTrace,
    );
  }

  /// Creates a copy of this instance, removing the specified fields.
  ErrModel copyWithout({
    bool type = true,
    bool error = true,
    bool statusCode = true,
    bool stackTrace = true,
  }) {
    return ErrModel(
      type: type ? this.type : null,
      error: error ? this.error : null,
      statusCode: statusCode ? this.statusCode : null,
      stackTrace: stackTrace ? this.stackTrace : null,
    );
  }

  /// Returns the value of the [type] field.
  /// If the field is nullable, the return value may be null; otherwise, it
  /// will always return a non-null value.
  @pragma('vm:prefer-inline')
  String get type$ => type!;

  /// Returns the value of the [error] field.
  /// If the field is nullable, the return value may be null; otherwise, it
  /// will always return a non-null value.
  @pragma('vm:prefer-inline')
  String get error$ => error!;

  /// Returns the value of the [statusCode] field.
  /// If the field is nullable, the return value may be null; otherwise, it
  /// will always return a non-null value.
  @pragma('vm:prefer-inline')
  int? get statusCode$ => statusCode;

  /// Returns the value of the [stackTrace] field.
  /// If the field is nullable, the return value may be null; otherwise, it
  /// will always return a non-null value.
  @pragma('vm:prefer-inline')
  List<String>? get stackTrace$ => stackTrace;
}

// --------------------------------------------------
// Source: ./lib/src/err_model/err_model.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~
// import 'package:df_generate_dart_models_core/df_generate_dart_models_core.dart';

// part '_err_model.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

// @GenerateDartModel(
//   fields: {
//     Field(fieldPath: ['type'], fieldType: String, nullable: false),
//     Field(fieldPath: ['error'], fieldType: String, nullable: false),
//     Field(fieldPath: ['statusCode'], fieldType: int, nullable: true),
//     Field(fieldPath: ['stackTrace'], fieldType: List<String>, nullable: true),
//   },
// )
// ignore: unused_element
abstract class _ErrModel {}

// --------------------------------------------------
// Source: ./lib/src/monads/impl/_sync_impl.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// part of '../monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

sealed class SyncImpl<T extends Object> {
  Object get value;
}

// --------------------------------------------------
// Source: ./lib/src/monads/impl/_async_impl.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// part of '../monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

sealed class AsyncImpl<T extends Object> {
  Future<Object> get value;
}

// --------------------------------------------------
// Source: ./lib/src/monads/result/_ok.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// part of '../monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represents the success case of a [Result], containing a
/// [value].
final class Ok<T extends Object> extends Result<T> implements SyncImpl<T> {
  @override
  @pragma('vm:prefer-inline')
  T get value => super.value as T;

  const Ok(T super.value) : super._();

  @override
  @pragma('vm:prefer-inline')
  bool isOk() => true;

  @override
  @pragma('vm:prefer-inline')
  bool isErr() => false;

  @override
  @pragma('vm:prefer-inline')
  Result<T> ifOk(
    @noFuturesAllowed void Function(Ok<T> self, Ok<T> ok) noFuturesAllowed,
  ) {
    return Sync(() {
      noFuturesAllowed(this, this);
      return value;
    }).value;
  }

  @override
  @pragma('vm:prefer-inline')
  Result<T> ifErr(
    @noFuturesAllowed void Function(Ok<T> self, Err<T> err) noFuturesAllowed,
  ) {
    return this;
  }

  @override
  @pragma('vm:prefer-inline')
  None<Err<T>> err() => const None();

  @override
  @pragma('vm:prefer-inline')
  Some<Ok<T>> ok() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  T? orNull() => value;

  @override
  @pragma('vm:prefer-inline')
  Result<R> flatMap<R extends Object>(
    @noFuturesAllowed Result<R> Function(T value) noFuturesAllowed,
  ) {
    return noFuturesAllowed(unwrap());
  }

  @override
  @pragma('vm:prefer-inline')
  Ok<T> mapOk(@noFuturesAllowed Ok<T> Function(Ok<T> ok) noFuturesAllowed) {
    return noFuturesAllowed(this);
  }

  @override
  @pragma('vm:prefer-inline')
  Ok<T> mapErr(@noFuturesAllowed Err<T> Function(Err<T> err) noFuturesAllowed) {
    return this;
  }

  @override
  @pragma('vm:prefer-inline')
  Result<Object> fold(
    @noFuturesAllowed Result<Object>? Function(Ok<T> ok) onOk,
    @noFuturesAllowed Result<Object>? Function(Err<T> err) onErr,
  ) {
    try {
      return onOk(this) ?? this;
    } catch (error, stackTrace) {
      return Err(
        error,
        stackTrace: stackTrace,
      );
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Ok<T> okOr(Result<T> other) => this;

  @override
  @pragma('vm:prefer-inline')
  Result<T> errOr(Result<T> other) => other;

  @override
  @pragma('vm:prefer-inline')
  T unwrap() => value;

  @override
  @pragma('vm:prefer-inline')
  T unwrapOr(T fallback) => value;

  @override
  @pragma('vm:prefer-inline')
  Ok<R> map<R extends Object>(
    @noFuturesAllowed R Function(T value) noFuturesAllowed,
  ) {
    return Ok(noFuturesAllowed(value));
  }

  @override
  Result<R> transf<R extends Object>([
    @noFuturesAllowed R Function(T e)? noFuturesAllowed,
  ]) {
    try {
      final a = unwrap();
      final b = noFuturesAllowed?.call(a) ?? a as R;
      return Ok(b);
    } catch (error, stackTrace) {
      assert(false, error);
      return Err(
        'Cannot transform $T to $R.',
        stackTrace: stackTrace,
      );
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Some<Ok<T>> wrapInSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<Ok<T>> wrapInOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Ok<T>> wrapInResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<Ok<T>> wrapInSync() => Sync.okValue(this);

  @override
  @pragma('vm:prefer-inline')
  Async<Ok<T>> wrapInAsync() => Async.okValue(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<Some<T>> wrapValueInSome() => map((e) => Some(e));

  @override
  @pragma('vm:prefer-inline')
  Ok<Ok<T>> wrapValueInOk() => map((e) => Ok(e));

  @override
  @pragma('vm:prefer-inline')
  Ok<Resolvable<T>> wrapValueInResolvable() => map((e) => Sync.okValue(e));

  @override
  @pragma('vm:prefer-inline')
  Ok<Sync<T>> wrapValueInSync() => map((e) => Sync.okValue(e));

  @override
  @pragma('vm:prefer-inline')
  Ok<Async<T>> wrapValyeInAsync() => map((e) => Async.okValue(e));

  @override
  @visibleForTesting
  @pragma('vm:prefer-inline')
  Ok<void> asVoid() => this;
}

// --------------------------------------------------
// Source: ./lib/src/monads/result/_err.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// part of '../monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represents the failure case of a [Result], containing an
/// error [value].
final class Err<T extends Object> extends Result<T> implements SyncImpl<T>, Exception {
  /// An optional HTTP status code associated with the error.
  final Option<int> statusCode;

  /// The stack trace captured when the [Err] was created.
  final Trace stackTrace;

  @override
  @protected
  @pragma('vm:prefer-inline')
  Object get value => super.value;

  @pragma('vm:prefer-inline')
  Object get error => value;

  /// Creates a new [Err] from [value] and an optional [statusCode].
  Err(
    super.value, {
    int? statusCode,
    StackTrace? stackTrace,
  })  : statusCode = Option.from(statusCode),
        stackTrace = stackTrace != null ? Trace.from(stackTrace) : Trace.current(),
        super._();

  /// Creates an [Err] from an [ErrModel].
  @pragma('vm:prefer-inline')
  factory Err.fromModel(ErrModel model) {
    final error = model.error;
    return Err(
      error ?? 'Error',
      stackTrace: _tryParseStackTrace(model.stackTrace),
      statusCode: model.statusCode,
    );
  }

  static StackTrace? _tryParseStackTrace(List<String>? lines) {
    if (lines == null) return null;
    try {
      return Trace.parse(lines.join('\n')).original;
    } catch (_) {
      return null;
    }
  }

  @override
  @pragma('vm:prefer-inline')
  bool isOk() => false;

  @override
  @pragma('vm:prefer-inline')
  bool isErr() => true;

  @override
  @pragma('vm:prefer-inline')
  Err<T> ifOk(
    @noFuturesAllowed void Function(Err<T> self, Ok<T> ok) noFuturesAllowed,
  ) {
    return this;
  }

  @override
  @pragma('vm:prefer-inline')
  Err<T> ifErr(
    @noFuturesAllowed void Function(Err<T> self, Err<T> err) noFuturesAllowed,
  ) {
    return Sync(() {
      noFuturesAllowed(this, this);
      return this;
    }).value.flatten().err().unwrap();
  }

  @override
  @pragma('vm:prefer-inline')
  Some<Err<T>> err() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  None<Ok<T>> ok() => const None();

  @override
  @pragma('vm:prefer-inline')
  T? orNull() => null;

  @override
  @pragma('vm:prefer-inline')
  Result<R> flatMap<R extends Object>(
    @noFuturesAllowed Result<R> Function(T value) noFuturesAllowed,
  ) {
    return transfErr();
  }

  @override
  @pragma('vm:prefer-inline')
  Err<T> mapOk(@noFuturesAllowed Ok<T> Function(Ok<T> ok) noFuturesAllowed) {
    return this;
  }

  @override
  @pragma('vm:prefer-inline')
  Err<T> mapErr(
    @noFuturesAllowed Err<T> Function(Err<T> err) noFuturesAllowed,
  ) {
    return noFuturesAllowed(this);
  }

  @override
  @pragma('vm:prefer-inline')
  Result<Object> fold(
    @noFuturesAllowed Result<Object>? Function(Ok<T> ok) onOk,
    @noFuturesAllowed Result<Object>? Function(Err<T> err) onErr,
  ) {
    try {
      return onErr(this) ?? this;
    } catch (error, stackTrace) {
      return Err(
        error,
        stackTrace: stackTrace,
      );
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Result<T> okOr(Result<T> other) => other;

  @override
  @pragma('vm:prefer-inline')
  Result<T> errOr(Result<T> other) => this;

  /// Returns an [Option] containing the error if its type matches `E`.
  @pragma('vm:prefer-inline')
  Option<E> matchError<E extends Object>() => value is E ? Some(value as E) : const None();

  /// Transforms the `Err`'s generic type from `T` to `R` while preserving the
  /// contained `error`.
  @pragma('vm:prefer-inline')
  Err<R> transfErr<R extends Object>() {
    return Err(
      value,
      statusCode: statusCode.orNull(),
    );
  }

  /// Converts this [Err] to a data model for serialization.
  ErrModel toModel() {
    final type = 'Err<${T.toString()}>';
    final error = _safeToString(value);
    return ErrModel(
      type: type,
      error: error,
      statusCode: statusCode.orNull(),
      stackTrace: stackTrace.frames.map((e) => e.toString()).toList(),
    );
  }

  /// Converts this [Err] to a JSON map.
  Map<String, dynamic> toJson() {
    final model = toModel();
    return {
      if (model.type != null) 'type': model.type,
      if (model.error != null) 'error': model.error,
      if (model.statusCode != null) 'statusCode': model.statusCode,
      if (model.stackTrace != null) 'stackTrace': model.stackTrace,
    };
  }

  @override
  @protected
  @unsafeOrError
  @pragma('vm:prefer-inline')
  T unwrap() {
    throw this;
  }

  @override
  @protected
  @pragma('vm:prefer-inline')
  T unwrapOr(T fallback) => fallback;

  @override
  @pragma('vm:prefer-inline')
  Err<R> map<R extends Object>(
    @noFuturesAllowed R Function(T value) noFuturesAllowed,
  ) {
    return transfErr();
  }

  @override
  @protected
  @pragma('vm:prefer-inline')
  Err<R> transf<R extends Object>([
    @noFuturesAllowed R Function(T e)? noFuturesAllowed,
  ]) {
    return transfErr<R>();
  }

  @override
  @pragma('vm:prefer-inline')
  Some<Err<T>> wrapInSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<Err<T>> wrapInOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Err<T>> wrapInResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<Err<T>> wrapInSync() => Sync.okValue(this);

  @override
  @pragma('vm:prefer-inline')
  Async<Err<T>> wrapInAsync() => Async.okValue(this);

  @override
  @pragma('vm:prefer-inline')
  Err<Some<T>> wrapValueInSome() => transfErr();

  @override
  @pragma('vm:prefer-inline')
  Err<Ok<T>> wrapValueInOk() => transfErr();

  @override
  @pragma('vm:prefer-inline')
  Err<Resolvable<T>> wrapValueInResolvable() => transfErr();

  @override
  @pragma('vm:prefer-inline')
  Err<Sync<T>> wrapValueInSync() => transfErr();

  @override
  @pragma('vm:prefer-inline')
  Err<Async<T>> wrapValyeInAsync() => transfErr();

  @override
  @visibleForTesting
  @pragma('vm:prefer-inline')
  Err<void> asVoid() => this;

  @override
  @unsafeOrError
  @pragma('vm:prefer-inline')
  String toString() {
    final encoder = const JsonEncoder.withIndent('  ');
    return encoder.convert(toJson());
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

String _safeToString(Object? obj) {
  try {
    return obj.toString();
  } catch (error) {
    assert(false, error);
    return '${obj.runtimeType}@${obj.hashCode.toRadixString(16)}';
  }
}

// --------------------------------------------------
// Source: ./lib/src/monads/result/_result.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// part of '../monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represents the result of an operation: every [Result] is
/// either [Ok] and contains a success value, or [Err] and contains an error
/// value.
sealed class Result<T extends Object> extends Monad<T> implements SyncImpl<T> {
  /// Combines 2 [Result] monads into 1 containing a tuple of their values if
  /// all are [Ok].
  ///
  /// If any are [Err], applies [onErr] function to combine errors.
  ///
  /// See also: [combineResult].
  static Result<(T1, T2)> zip2<T1 extends Object, T2 extends Object>(
    Result<T1> r1,
    Result<T2> r2, [
    @noFuturesAllowed Err<(T1, T2)> Function(Result<T1>, Result<T2>)? onErr,
  ]) {
    final combined = combineResult<Object>(
      [r1, r2],
      onErr: onErr == null ? null : (l) => onErr(l[0].transf<T1>(), l[1].transf<T2>()).transfErr(),
    );
    return combined.map((l) => (l[0] as T1, l[1] as T2));
  }

  /// Combines 3 [Result] monads into 1 containing a tuple of their values if
  /// all are [Ok].
  ///
  /// If any are [Err], applies [onErr] function to combine errors.
  ///
  /// See also: [combineResult].
  static Result<(T1, T2, T3)> zip3<T1 extends Object, T2 extends Object, T3 extends Object>(
    Result<T1> r1,
    Result<T2> r2,
    Result<T3> r3, [
    @noFuturesAllowed Err<(T1, T2, T3)> Function(Result<T1>, Result<T2>, Result<T3>)? onErr,
  ]) {
    final combined = combineResult<Object>(
      [r1, r2, r3],
      onErr: onErr == null
          ? null
          : (l) => onErr(
                l[0].transf<T1>(),
                l[1].transf<T2>(),
                l[2].transf<T3>(),
              ).transfErr(),
    );
    return combined.map((l) => (l[0] as T1, l[1] as T2, l[2] as T3));
  }

  const Result._(super.value);

  /// Returns `this` as a base [Result] type.
  @pragma('vm:prefer-inline')
  Result<T> asResult() => this;

  /// Returns `true` if this [Result] is an [Ok].
  bool isOk();

  /// Returns `true` if this [Result] is an [Err].
  bool isErr();

  /// Performs a side-effect with the contained value if this is an [Ok].
  Result<T> ifOk(
    @noFuturesAllowed void Function(Result<T> self, Ok<T> ok) noFuturesAllowed,
  );

  /// Performs a side-effect with the contained error if this is an [Err].
  Result<T> ifErr(
    @noFuturesAllowed void Function(Result<T> self, Err<T> err) noFuturesAllowed,
  );

  /// Safely gets the [Err] instance.
  /// Returns a [Some] on [Err], or a [None] on [Ok].
  Option<Err<T>> err();

  /// Safely gets the [Ok] instance.
  /// Returns a [Some] on [Ok], or a [None] on [Err].
  Option<Ok<T>> ok();

  /// Returns the contained [Ok] value or `null`.
  T? orNull();

  /// Maps a `Result<T>` to `Result<R>` by applying a function that returns
  /// another [Result].
  Result<R> flatMap<R extends Object>(
    @noFuturesAllowed Result<R> Function(T value) noFuturesAllowed,
  );

  /// Transforms the inner [Ok] instance if this is an [Ok].
  Result<T> mapOk(@noFuturesAllowed Ok<T> Function(Ok<T> ok) noFuturesAllowed);

  /// Transforms the inner [Err] instance if this is an [Err].
  Result<T> mapErr(
    @noFuturesAllowed Err<T> Function(Err<T> err) noFuturesAllowed,
  );

  /// Folds the two cases of this [Result] into a single new [Result].
  Result<Object> fold(
    @noFuturesAllowed Result<Object>? Function(Ok<T> ok) onOk,
    @noFuturesAllowed Result<Object>? Function(Err<T> err) onErr,
  );

  /// Returns this if it's [Ok], otherwise returns the `other` [Result].
  Result<T> okOr(Result<T> other);

  /// Returns this if it's [Err], otherwise returns the `other` [Result].
  Result<T> errOr(Result<T> other);

  @override
  @unsafeOrError
  T unwrap();

  @override
  T unwrapOr(T fallback);

  @override
  Result<R> map<R extends Object>(
    @noFuturesAllowed R Function(T value) noFuturesAllowed,
  );

  @override
  Result<R> transf<R extends Object>([
    @noFuturesAllowed R Function(T e)? noFuturesAllowed,
  ]);

  @override
  @pragma('vm:prefer-inline')
  Some<Result<T>> wrapInSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<Result<T>> wrapInOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Result<T>> wrapInResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<Result<T>> wrapInSync() => Sync.okValue(this);

  @override
  @pragma('vm:prefer-inline')
  Async<Result<T>> wrapInAsync() => Async.okValue(this);

  @override
  @pragma('vm:prefer-inline')
  Result<Some<T>> wrapValueInSome() => map((e) => Some(e));

  @override
  @pragma('vm:prefer-inline')
  Result<Ok<T>> wrapValueInOk() => map((e) => Ok(e));

  @override
  @pragma('vm:prefer-inline')
  Result<Resolvable<T>> wrapValueInResolvable() => map((e) => Sync.okValue(e));

  @override
  @pragma('vm:prefer-inline')
  Result<Sync<T>> wrapValueInSync() => map((e) => Sync.okValue(e));

  @override
  @pragma('vm:prefer-inline')
  Result<Async<T>> wrapValyeInAsync() => map((e) => Async.okValue(e));

  @override
  @visibleForTesting
  @pragma('vm:prefer-inline')
  Result<void> asVoid() => this;

  @override
  @nonVirtual
  @pragma('vm:prefer-inline')
  void end() {}
}

// --------------------------------------------------
// Source: ./lib/src/monads/option/_none.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// part of '../monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represents an [Option] that does not contain a value.
final class None<T extends Object> extends Option<T> implements SyncImpl<T> {
  @override
  @pragma('vm:prefer-inline')
  Unit get value => super.value as Unit;

  const None() : super._(Unit.instance);

  @override
  @pragma('vm:prefer-inline')
  bool isSome() => false;

  @override
  @pragma('vm:prefer-inline')
  bool isNone() => true;

  @override
  @pragma('vm:prefer-inline')
  Err<Some<T>> some() {
    return Err(
      'Called some() on None<$T>.',
    );
  }

  @override
  @pragma('vm:prefer-inline')
  Ok<None<T>> none() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Result<None<T>> ifSome(
    @noFuturesAllowed
    void Function(
      None<T> self,
      Some<T> some,
    ) noFuturesAllowed,
  ) {
    return Ok(this);
  }

  @override
  @pragma('vm:prefer-inline')
  Result<None<T>> ifNone(
    @noFuturesAllowed
    void Function(
      Option<T> self,
      None<T> none,
    ) noFuturesAllowed,
  ) {
    return Sync(() {
      noFuturesAllowed(this, this);
      return this;
    }).value;
  }

  @override
  @pragma('vm:prefer-inline')
  T? orNull() => null;

  @override
  @pragma('vm:prefer-inline')
  None<T> mapSome(
    @noFuturesAllowed Some<T> Function(Some<T> some) noFuturesAllowed,
  ) {
    return this;
  }

  @override
  @pragma('vm:prefer-inline')
  None<R> flatMap<R extends Object>(
    @noFuturesAllowed Option<R> Function(T value) noFuturesAllowed,
  ) {
    return const None();
  }

  @override
  @pragma('vm:prefer-inline')
  None<T> filter(@noFuturesAllowed bool Function(T value) noFuturesAllowed) {
    return const None();
  }

  @override
  @pragma('vm:prefer-inline')
  Result<Option<Object>> fold(
    @noFuturesAllowed Option<Object>? Function(Some<T> some) onSome,
    @noFuturesAllowed Option<Object>? Function(None<T> none) onNone,
  ) {
    try {
      return Ok(onNone(this) ?? this);
    } catch (error, stackTrace) {
      return Err(
        error,
        stackTrace: stackTrace,
      );
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Option<T> someOr(Option<T> other) => other;

  @override
  @pragma('vm:prefer-inline')
  None<T> noneOr(Option<T> other) => this;

  @override
  @protected
  @unsafeOrError
  @pragma('vm:prefer-inline')
  T unwrap() {
    throw Err<T>('Called unwrap() on None<$T>.');
  }

  @override
  @protected
  @pragma('vm:prefer-inline')
  T unwrapOr(T fallback) => fallback;

  @override
  @pragma('vm:prefer-inline')
  None<R> map<R extends Object>(
    @noFuturesAllowed R Function(T value) noFuturesAllowed,
  ) {
    return None<R>();
  }

  @override
  @pragma('vm:prefer-inline')
  Ok<None<R>> transf<R extends Object>([
    @noFuturesAllowed R Function(T e)? noFuturesAllowed,
  ]) {
    return const Ok(None());
  }

  @override
  @pragma('vm:prefer-inline')
  Some<None<T>> wrapInSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<None<T>> wrapInOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<None<T>> wrapInResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<None<T>> wrapInSync() => Sync.okValue(this);

  @override
  @pragma('vm:prefer-inline')
  Async<None<T>> wrapInAsync() => Async.okValue(this);

  @override
  @pragma('vm:prefer-inline')
  None<Some<T>> wrapValueInSome() => const None();

  @override
  @pragma('vm:prefer-inline')
  None<Ok<T>> wrapValueInOk() => const None();

  @override
  @pragma('vm:prefer-inline')
  None<Resolvable<T>> wrapValueInResolvable() => const None();

  @override
  @pragma('vm:prefer-inline')
  None<Sync<T>> wrapValueInSync() => const None();

  @override
  @pragma('vm:prefer-inline')
  None<Async<T>> wrapValyeInAsync() => const None();

  @override
  @visibleForTesting
  @pragma('vm:prefer-inline')
  None<void> asVoid() => this;
}

// --------------------------------------------------
// Source: ./lib/src/monads/option/_option.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// part of '../monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represents an optional value: every [Option] is either
/// [Some] and contains a value, or [None] and does not.
sealed class Option<T extends Object> extends Monad<T> implements SyncImpl<T> {
  /// Combines 2 [Option] monads into 1 containing a tuple of their values if
  /// all are [Some].
  ///
  /// Returns [None] if any are [None].
  ///
  /// See also: [combineOption].
  static Option<(T1, T2)> zip2<T1 extends Object, T2 extends Object>(
    Option<T1> o1,
    Option<T2> o2,
  ) {
    return combineOption<Object>([o1, o2]).map((l) => (l[0] as T1, l[1] as T2));
  }

  /// Combines 3 [Option] monads into 1 containing a tuple of their values if
  /// all are [Some].
  ///
  /// Returns [None] if any are [None].
  ///
  /// See also: [combineOption].
  static Option<(T1, T2, T3)> zip3<T1 extends Object, T2 extends Object, T3 extends Object>(
    Option<T1> o1,
    Option<T2> o2,
    Option<T3> o3,
  ) {
    return combineOption<Object>([
      o1,
      o2,
      o3,
    ]).map((l) => (l[0] as T1, l[1] as T2, l[2] as T3));
  }

  const Option._(super.value);

  /// Creates an [Option] from a nullable value.
  ///
  /// Returns [Some] if the [value] is not `null`, otherwise returns [None].
  factory Option.from(T? value) {
    // This is already safe and idiomatic, no switch needed here.
    if (value != null) {
      return Some(value);
    } else {
      return const None();
    }
  }

  @Deprecated('Use "Option.from(T? value)" instead.')
  factory Option.fromNullable(T? value) => Option.from(value);

  /// Returns `this` as a base [Option] type.
  @pragma('vm:prefer-inline')
  Option<T> asOption() => this;

  /// Returns `true` if this [Option] is a [Some].
  bool isSome();

  /// Returns `true` if this [Option] is a [None].
  bool isNone();

  /// Safely gets the [Some] instance.  Returns an [Ok] on [Some], or an [Err]
  /// on [None].
  Result<Some<T>> some();

  /// Safely gets the [None] instance. Returns an [Ok] on [None], or an [Err]
  /// on [Some].
  Result<None<T>> none();

  /// Performs a side-effect with the contained value if this is a [Some].
  Result<Option<T>> ifSome(
    @noFuturesAllowed
    void Function(
      Option<T> self,
      Some<T> some,
    ) noFuturesAllowed,
  );

  /// Performs a side-effect if this is a [None].
  Result<Option<T>> ifNone(
    @noFuturesAllowed
    void Function(
      Option<T> self,
      None<T> none,
    ) noFuturesAllowed,
  );

  /// Returns the contained value or `null`.
  T? orNull();

  /// Transforms the inner [Some] instance if this is a [Some].
  Option<T> mapSome(
    @noFuturesAllowed Some<T> Function(Some<T> some) noFuturesAllowed,
  );

  /// Maps an `Option<T>` to `Option<R>` by applying a function that returns
  /// another [Option].
  Option<R> flatMap<R extends Object>(
    @noFuturesAllowed Option<R> Function(T value) noFuturesAllowed,
  );

  /// Returns [None] if the predicate [noFuturesAllowed] returns `false`.
  /// Otherwise, returns the original [Option].
  Option<T> filter(@noFuturesAllowed bool Function(T value) noFuturesAllowed);

  /// Folds the two cases of this [Option] into a single [Result].
  ///
  /// The `onSome` and `onNone` functions must return a new [Option].
  Result<Option<Object>> fold(
    @noFuturesAllowed Option<Object>? Function(Some<T> some) onSome,
    @noFuturesAllowed Option<Object>? Function(None<T> none) onNone,
  );

  /// Returns this if it's [Some], otherwise returns the `other` [Option].
  Option<T> someOr(Option<T> other);

  /// Returns this if it's [None], otherwise returns the `other` [Option].
  Option<T> noneOr(Option<T> other);

  @override
  @unsafeOrError
  T unwrap();

  @override
  T unwrapOr(T fallback);

  @override
  Option<R> map<R extends Object>(
    @noFuturesAllowed R Function(T value) noFuturesAllowed,
  );

  @override
  Result<Option<R>> transf<R extends Object>([
    @noFuturesAllowed R Function(T e)? noFuturesAllowed,
  ]);

  @override
  @pragma('vm:prefer-inline')
  Some<Option<T>> wrapInSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<Option<T>> wrapInOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Option<T>> wrapInResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<Option<T>> wrapInSync() => Sync.okValue(this);

  @override
  @pragma('vm:prefer-inline')
  Async<Option<T>> wrapInAsync() => Async.okValue(this);

  @override
  @pragma('vm:prefer-inline')
  Option<Some<T>> wrapValueInSome() => map((e) => Some(e));

  @override
  @pragma('vm:prefer-inline')
  Option<Ok<T>> wrapValueInOk() => map((e) => Ok(e));

  @override
  @pragma('vm:prefer-inline')
  Option<Resolvable<T>> wrapValueInResolvable() => map((e) => Sync.okValue(e));

  @override
  @pragma('vm:prefer-inline')
  Option<Sync<T>> wrapValueInSync() => map((e) => Sync.okValue(e));

  @override
  @pragma('vm:prefer-inline')
  Option<Async<T>> wrapValyeInAsync() => map((e) => Async.okValue(e));

  @override
  @visibleForTesting
  @pragma('vm:prefer-inline')
  Option<void> asVoid() => this;

  @override
  @nonVirtual
  @pragma('vm:prefer-inline')
  void end() {}
}

// --------------------------------------------------
// Source: ./lib/src/monads/option/_some.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// part of '../monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represents an [Option] that contains a [value].
final class Some<T extends Object> extends Option<T> implements SyncImpl<T> {
  @override
  @pragma('vm:prefer-inline')
  T get value => super.value as T;

  const Some(T super.value) : super._();

  @override
  @pragma('vm:prefer-inline')
  bool isSome() => true;

  @override
  @pragma('vm:prefer-inline')
  bool isNone() => false;

  @override
  @pragma('vm:prefer-inline')
  Ok<Some<T>> some() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Err<None<T>> none() {
    return Err(
      'Called none() on Some<$T>.',
    );
  }

  @override
  @pragma('vm:prefer-inline')
  Result<Some<T>> ifSome(
    @noFuturesAllowed
    void Function(
      Some<T> self,
      Some<T> none,
    ) noFuturesAllowed,
  ) {
    return Sync(() {
      noFuturesAllowed(this, this);
      return this;
    }).value;
  }

  @override
  @pragma('vm:prefer-inline')
  Result<Some<T>> ifNone(
    @noFuturesAllowed
    void Function(
      Some<T> self,
      None<T> none,
    ) noFuturesAllowed,
  ) {
    return Ok(this);
  }

  @override
  @pragma('vm:prefer-inline')
  T? orNull() => value;

  @override
  @pragma('vm:prefer-inline')
  Some<T> mapSome(
    @noFuturesAllowed Some<T> Function(Some<T> some) noFuturesAllowed,
  ) {
    return noFuturesAllowed(this);
  }

  @override
  @pragma('vm:prefer-inline')
  Option<R> flatMap<R extends Object>(
    @noFuturesAllowed Option<R> Function(T value) noFuturesAllowed,
  ) {
    return noFuturesAllowed(UNSAFE(() => unwrap()));
  }

  @override
  @pragma('vm:prefer-inline')
  Option<T> filter(@noFuturesAllowed bool Function(T value) noFuturesAllowed) {
    return noFuturesAllowed(value) ? this : const None();
  }

  @override
  @pragma('vm:prefer-inline')
  Result<Option<Object>> fold(
    @noFuturesAllowed Option<Object>? Function(Some<T> some) onSome,
    @noFuturesAllowed Option<Object>? Function(None<T> none) onNone,
  ) {
    try {
      return Ok(onSome(this) ?? this);
    } catch (error) {
      return Err(error);
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Some<T> someOr(Option<T> other) => this;

  @override
  @pragma('vm:prefer-inline')
  Option<T> noneOr(Option<T> other) => other;

  @override
  @unsafeOrError
  @pragma('vm:prefer-inline')
  T unwrap() => value;

  @override
  @pragma('vm:prefer-inline')
  T unwrapOr(T fallback) => value;

  @override
  @pragma('vm:prefer-inline')
  Some<R> map<R extends Object>(
    @noFuturesAllowed R Function(T value) noFuturesAllowed,
  ) {
    return Some(noFuturesAllowed(value));
  }

  @override
  Result<Option<R>> transf<R extends Object>([
    @noFuturesAllowed R Function(T e)? noFuturesAllowed,
  ]) {
    try {
      UNSAFE:
      final value0 = unwrap();
      final value1 = noFuturesAllowed?.call(value0) ?? value0 as R;
      return Ok(Option.from(value1));
    } catch (error, stackTrace) {
      assert(false, error);
      return Err(
        'Cannot transform $T to $R',
        stackTrace: stackTrace,
      );
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Some<Some<T>> wrapInSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<Some<T>> wrapInOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Some<T>> wrapInResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<Some<T>> wrapInSync() => Sync.okValue(this);

  @override
  @pragma('vm:prefer-inline')
  Async<Some<T>> wrapInAsync() => Async.okValue(this);

  @override
  @pragma('vm:prefer-inline')
  Some<Some<T>> wrapValueInSome() => map((e) => Some(e));

  @override
  @pragma('vm:prefer-inline')
  Some<Ok<T>> wrapValueInOk() => map((e) => Ok(e));

  @override
  @pragma('vm:prefer-inline')
  Some<Resolvable<T>> wrapValueInResolvable() => map((e) => Sync.okValue(e));

  @override
  @pragma('vm:prefer-inline')
  Some<Sync<T>> wrapValueInSync() => map((e) => Sync.okValue(e));

  @override
  @pragma('vm:prefer-inline')
  Some<Async<T>> wrapValyeInAsync() => map((e) => Async.okValue(e));

  @override
  @visibleForTesting
  @pragma('vm:prefer-inline')
  Some<void> asVoid() => this;
}

// --------------------------------------------------
// Source: ./lib/src/monads/resolvable/_async.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// part of '../monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represents a [Resolvable] that holds an asynchronous [Result].
///
/// The contained [value] is always a [Future].
///
/// # IMPORTANT:
///
/// Await all Futures in the constructor [Async.new] to ensure errors are
/// properly caught and propagated.
final class Async<T extends Object> extends Resolvable<T> implements AsyncImpl<T> {
  /// Combines 2 [Async] monads into 1 containing a tuple of their values
  /// if all resolve to [Ok].
  ///
  /// If any resolve to [Err], applies [onErr] function to combine errors.
  ///
  /// See also: [combineAsync].
  static Async<(T1, T2)> zip2<T1 extends Object, T2 extends Object>(
    Async<T1> a1,
    Async<T2> a2, [
    @noFuturesAllowed Err<(T1, T2)> Function(Result<T1>, Result<T2>)? onErr,
  ]) {
    final combined = combineAsync<Object>(
      [a1, a2],
      onErr: onErr == null ? null : (l) => onErr(l[0].transf<T1>(), l[1].transf<T2>()).transfErr(),
    );
    return combined.map((l) => (l[0] as T1, l[1] as T2));
  }

  /// Combines 3 [Async] monads into 1 containing a tuple of their values
  /// if all resolve to [Ok].
  ///
  /// If any resolve to [Err], applies [onErr] function to combine errors.
  ///
  /// See also: [combineAsync].
  static Async<(T1, T2, T3)> zip3<T1 extends Object, T2 extends Object, T3 extends Object>(
    Async<T1> a1,
    Async<T2> a2,
    Async<T3> a3, [
    @noFuturesAllowed Err<(T1, T2, T3)> Function(Result<T1>, Result<T2>, Result<T3>)? onErr,
  ]) {
    final combined = combineAsync<Object>(
      [a1, a2, a3],
      onErr: onErr == null
          ? null
          : (l) => onErr(
                l[0].transf<T1>(),
                l[1].transf<T2>(),
                l[2].transf<T3>(),
              ).transfErr(),
    );
    return combined.map((l) => (l[0] as T1, l[1] as T2, l[2] as T3));
  }

  @override
  @pragma('vm:prefer-inline')
  Future<Result<T>> get value => super.value as Future<Result<T>>;

  @unsafeOrError
  Async.result(super.value)
      : assert(!isSubtype<T, Future<Object>>(), '$T must never be a Future.'),
        super.result();

  @unsafeOrError
  Async.ok(super.ok)
      : assert(!isSubtype<T, Future<Object>>(), '$T must never be a Future.'),
        super.ok();

  @unsafeOrError
  Async.okValue(FutureOr<T> okValue)
      : assert(!isSubtype<T, Future<Object>>(), '$T must never be a Future.'),
        super.ok(Future.value(okValue).then((e) => Ok(e)));

  @unsafeOrError
  Async.err(super.err)
      : assert(!isSubtype<T, Future<Object>>(), '$T must never be a Future.'),
        super.err();

  @unsafeOrError
  Async.errValue(FutureOr<({Object error, int? statusCode})> error)
      : assert(!isSubtype<T, Future<Object>>(), '$T must never be a Future.'),
        super.err(Future.value(error).then((e) => Err(e.error, statusCode: e.statusCode)));

  /// Creates an [Async] by executing an asynchronous function
  /// [mustAwaitAllFutures].
  ///
  /// # IMPORTANT:
  ///
  /// Always all futures witin [mustAwaitAllFutures] to ensure errors are be
  /// caught and propagated.
  factory Async(
    @mustBeAnonymous @mustAwaitAllFutures Future<T> Function() mustAwaitAllFutures, {
    @noFuturesAllowed TOnErrorCallback<T>? onError,
    @noFuturesAllowed TVoidCallback? onFinalize,
  }) {
    assert(!isSubtype<T, Future<Object>>(), '$T must never be a Future.');
    return Async.result(() async {
      try {
        return Ok<T>(await mustAwaitAllFutures());
      } on Err catch (err) {
        return err.transfErr<T>();
      } catch (error, stackTrace) {
        try {
          if (onError == null) {
            rethrow;
          }
          return onError(error, stackTrace);
        } catch (error, stackTrace) {
          return Err<T>(
            error,
            stackTrace: stackTrace,
          );
        }
      } finally {
        onFinalize?.call();
      }
    }());
  }

  @override
  @pragma('vm:prefer-inline')
  bool isSync() => false;

  @override
  @pragma('vm:prefer-inline')
  bool isAsync() => true;

  @override
  @pragma('vm:prefer-inline')
  Err<Sync<T>> sync() {
    return Err(
      'Called sync() on Async<$T>.',
    );
  }

  @override
  @pragma('vm:prefer-inline')
  Ok<Async<T>> async() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Async<T> ifSync(
    @noFuturesAllowed
    void Function(
      Async<T> self,
      Sync<T> async,
    ) noFuturesAllowed,
  ) {
    return this;
  }

  @override
  @pragma('vm:prefer-inline')
  Async<T> ifAsync(
    @noFuturesAllowed
    void Function(
      Async<T> self,
      Async<T> async,
    ) noFuturesAllowed,
  ) {
    return Sync(() {
      noFuturesAllowed(this, this);
      return this;
    }).flatten().toAsync();
  }

  @override
  Resolvable<T> ifOk(
    @noFuturesAllowed
    void Function(
      Async<T> self,
      Ok<T> ok,
    ) noFuturesAllowed,
  ) {
    return Async(() async {
      final awaitedValue = await value;
      return switch (awaitedValue) {
        Ok<T> ok => Resolvable(
            () {
              noFuturesAllowed(this, ok);
              return awaitedValue;
            },
          ).flatten(),
        Err() => this,
      };
    }).flatten();
  }

  @override
  Resolvable<T> ifErr(
    @noFuturesAllowed
    void Function(
      Async<T> self,
      Err<T> err,
    ) noFuturesAllowed,
  ) {
    return Async(() async {
      final awaitedValue = await value;
      return switch (awaitedValue) {
        Ok() => this,
        Err<T> err => Sync(() {
            noFuturesAllowed(this, err);
            return awaitedValue;
          }).flatten()
      };
    }).flatten();
  }

  @override
  Async<R> resultMap<R extends Object>(
    @noFuturesAllowed Result<R> Function(Result<T> value) noFuturesAllowed,
  ) {
    return Async(() async {
      final a = await value;
      switch (a) {
        case Ok():
          final b = noFuturesAllowed(a);
          switch (b) {
            case Ok(value: final okValue):
              return okValue;
            case Err():
              throw b;
          }
        case Err():
          throw a;
      }
    });
  }

  @override
  @pragma('vm:prefer-inline')
  Async<R> mapFutureOr<R extends Object>(FutureOr<R> Function(T value) mapper) {
    return Async(() async => mapper((await value).unwrap()));
  }

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Object> fold(
    @noFuturesAllowed Resolvable<Object>? Function(Sync<T> sync) onSync,
    @noFuturesAllowed Resolvable<Object>? Function(Async<T> async) onAsync,
  ) {
    try {
      return onAsync(this) ?? this;
    } catch (error, stackTrace) {
      return Async.err(
        Err(
          error,
          stackTrace: stackTrace,
        ),
      );
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Async<Object> foldResult(
    @noFuturesAllowed Result<Object>? Function(Ok<T> ok) onOk,
    @noFuturesAllowed Result<Object>? Function(Err<T> err) onErr,
  ) {
    return this.resultMap((e) => e.fold(onOk, onErr));
  }

  @override
  @pragma('vm:prefer-inline')
  Sync<T> toSync() {
    throw Err<T>('Called toSync() on Async<$T>.');
  }

  @override
  @pragma('vm:prefer-inline')
  Async<T> toAsync() => this;

  @override
  @pragma('vm:prefer-inline')
  Future<T?> orNull() => value.then((e) => e.orNull());

  @override
  @pragma('vm:prefer-inline')
  Resolvable<T> syncOr(Resolvable<T> other) => other;

  @override
  @pragma('vm:prefer-inline')
  Async<T> asyncOr(Resolvable<T> other) => this;

  @override
  @pragma('vm:prefer-inline')
  Async<T> okOr(Resolvable<T> other) {
    return Async(() async {
      final awaitedValue = await value;
      switch (awaitedValue) {
        case Ok(value: final okValue):
          return okValue;
        case Err():
          return (await other.value).unwrap();
      }
    });
  }

  @override
  @pragma('vm:prefer-inline')
  Async<T> errOr(Resolvable<T> other) {
    return Async(() async {
      final awaitedValue = await value;
      switch (awaitedValue) {
        case Err():
          return awaitedValue.unwrap();
        case Ok():
          return (await other.value).unwrap();
      }
    });
  }

  @override
  @pragma('vm:prefer-inline')
  Future<Option<Ok<T>>> ok() => value.then((e) => e.ok());

  @override
  @pragma('vm:prefer-inline')
  Future<Option<Err<T>>> err() => value.then((e) => e.err());

  @override
  @unsafeOrError
  @pragma('vm:prefer-inline')
  Future<T> unwrap() => value.then((e) => e.unwrap());

  @override
  FutureOr<T> unwrapOr(T fallback) => value.then((e) => e.unwrapOr(fallback));

  /// Prefer using [then] for [Async].
  @override
  @pragma('vm:prefer-inline')
  Async<R> map<R extends Object>(
    @noFuturesAllowed R Function(T value) noFuturesAllowed,
  ) {
    return then(noFuturesAllowed);
  }

  @override
  @pragma('vm:prefer-inline')
  Async<R> then<R extends Object>(
    @noFuturesAllowed R Function(T value) noFuturesAllowed,
  ) {
    return Async.result(value.then((e) => e.map(noFuturesAllowed)));
  }

  @override
  @pragma('vm:prefer-inline')
  Async<R> whenComplete<R extends Object>(
    @noFuturesAllowed Resolvable<R> Function(Sync<T> resolved) noFuturesAllowed,
  ) {
    return Async(() async {
      final result = (await value);
      result.unwrap(); // unwrap to throw if value has an Err.
      return Resolvable(() => noFuturesAllowed(Sync<T>.result(result)));
    }).flatten().toAsync();
  }

  @override
  Async<R> transf<R extends Object>([
    @noFuturesAllowed R Function(T e)? noFuturesAllowed,
  ]) {
    return Async(() async {
      final okOrErr = (await value).transf<R>(noFuturesAllowed);
      switch (okOrErr) {
        case Ok(value: final okValue):
          return okValue;
        case Err():
          throw okOrErr;
      }
    });
  }

  @override
  @pragma('vm:prefer-inline')
  Some<Async<T>> wrapInSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<Async<T>> wrapInOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Async<T>> wrapInResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<Async<T>> wrapInSync() => Sync.okValue(this);

  @override
  @pragma('vm:prefer-inline')
  Async<Async<T>> wrapInAsync() => Async.okValue(this);

  @override
  @pragma('vm:prefer-inline')
  Async<Some<T>> wrapValueInSome() => map((e) => Some(e));

  @override
  @pragma('vm:prefer-inline')
  Async<Ok<T>> wrapValueInOk() => map((e) => Ok(e));

  @override
  @pragma('vm:prefer-inline')
  Async<Resolvable<T>> wrapValueInResolvable() => map((e) => Sync.okValue(e));

  @override
  @pragma('vm:prefer-inline')
  Async<Sync<T>> wrapValueInSync() => map((e) => Sync.okValue(e));

  @override
  @pragma('vm:prefer-inline')
  Async<Async<T>> wrapValyeInAsync() => map((e) => Async.okValue(e));

  @override
  @visibleForTesting
  @pragma('vm:prefer-inline')
  Async<void> asVoid() => this;

  @override
  @pragma('vm:prefer-inline')
  Future<void> end() {
    return value.then((e) => e.end()).catchError((_) {});
  }
}

// --------------------------------------------------
// Source: ./lib/src/monads/resolvable/_resolvable.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// part of '../monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represents a value which can be resolved either synchronously
/// [Sync] or asynchronously [Async].
///
/// The [value] of a [Sync] is never a [Future] while the value of an [Async]
/// is always a [Future].
sealed class Resolvable<T extends Object> extends Monad<T> {
  @override
  @pragma('vm:prefer-inline')
  FutureOr<Result<T>> get value => super.value as FutureOr<Result<T>>;

  @protected
  @unsafeOrError
  const Resolvable.result(FutureOr<Result<T>> super.value);

  @protected
  @unsafeOrError
  const Resolvable.ok(FutureOr<Ok<T>> super.value);

  @protected
  @unsafeOrError
  const Resolvable.err(FutureOr<Err<T>> super.value);

  /// Combines 2 [Resolvable] monads into 1 containing a tuple of their values
  /// if all resolve to [Ok].
  ///
  /// If any resolve to [Err], applies [onErr] function to combine errors.
  ///
  /// See also: [combineResolvable].
  static Resolvable<(T1, T2)> zip2<T1 extends Object, T2 extends Object>(
    Resolvable<T1> r1,
    Resolvable<T2> r2, [
    @noFuturesAllowed Err<(T1, T2)> Function(Result<T1>, Result<T2>)? onErr,
  ]) {
    final combined = combineResolvable<Object>(
      [r1, r2],
      onErr: onErr == null ? null : (l) => onErr(l[0].transf<T1>(), l[1].transf<T2>()).transfErr(),
    );
    return combined.map((l) => (l[0] as T1, l[1] as T2));
  }

  /// Combines 3 [Resolvable] monads into 1 containing a tuple of their values
  /// if all resolve to [Ok].
  ///
  /// If any resolve to [Err], applies [onErr] function to combine errors.
  ///
  /// See also: [combineResolvable].
  static Resolvable<(T1, T2, T3)> zip3<T1 extends Object, T2 extends Object, T3 extends Object>(
    Resolvable<T1> r1,
    Resolvable<T2> r2,
    Resolvable<T3> r3, [
    @noFuturesAllowed Err<(T1, T2, T3)> Function(Result<T1>, Result<T2>, Result<T3>)? onErr,
  ]) {
    final combined = combineResolvable<Object>(
      [r1, r2, r3],
      onErr: onErr == null
          ? null
          : (l) => onErr(
                l[0].transf<T1>(),
                l[1].transf<T2>(),
                l[2].transf<T3>(),
              ).transfErr(),
    );
    return combined.map((l) => (l[0] as T1, l[1] as T2, l[2] as T3));
  }

  /// Creates a [Sync] or [Async] depending on the return type of
  /// [mustAwaitAllFutures].
  ///
  /// # IMPORTANT:
  ///
  /// Always all futures witin [mustAwaitAllFutures] to ensure errors are be
  /// caught and propagated.
  factory Resolvable(
    @mustBeAnonymous @mustAwaitAllFutures FutureOr<T> Function() mustAwaitAllFutures, {
    @noFuturesAllowed TOnErrorCallback<T>? onError,
    @noFuturesAllowed TVoidCallback? onFinalize,
  }) {
    final result = mustAwaitAllFutures();
    if (result is Future<T>) {
      return Async(() => result, onError: onError, onFinalize: onFinalize);
    } else {
      return Sync(() => result, onError: onError, onFinalize: onFinalize);
    }
  }

  /// Returns `this` as a base [Resolvable] type.
  @pragma('vm:prefer-inline')
  Resolvable<T> asResolvable() => this;

  /// Returns `true` if this is a [Sync] instance.
  bool isSync();

  /// Returns `true` if this is an [Async] instance.
  bool isAsync();

  /// Safely gets the [Sync] instance.
  /// Returns an [Ok] on [Sync], or an [Err] on [Async].
  Result<Sync<T>> sync();

  /// Safely gets the [Async] instance.
  /// Returns an [Ok] on [Async], or an [Err] on [Sync].
  Result<Async<T>> async();

  /// Performs a side-effect if this is [Sync].
  Resolvable<T> ifSync(
    @noFuturesAllowed
    void Function(
      Resolvable<T> self,
      Sync<T> sync,
    ) noFuturesAllowed,
  );

  /// Performs a side-effect if this is [Async].
  Resolvable<T> ifAsync(
    @noFuturesAllowed
    void Function(
      Resolvable<T> self,
      Async<T> async,
    ) noFuturesAllowed,
  );

  /// Performs a side-effect if this is [Ok].
  Resolvable<T> ifOk(
    @noFuturesAllowed
    void Function(
      Resolvable<T> self,
      Ok<T> ok,
    ) noFuturesAllowed,
  );

  /// Performs a side-effect if this is [Err].
  Resolvable<T> ifErr(
    @noFuturesAllowed
    void Function(
      Resolvable<T> self,
      Err<T> err,
    ) noFuturesAllowed,
  );

  /// Maps the inner [Result] of this [Resolvable] using `mapper`.
  Resolvable<R> resultMap<R extends Object>(
    @noFuturesAllowed Result<R> Function(Result<T> value) noFuturesAllowed,
  );

  /// Maps the contained [Ok] value using a function that returns a `FutureOr`.
  Resolvable<R> mapFutureOr<R extends Object>(
    FutureOr<R> Function(T value) mapper,
  );

  /// Handles [Sync] and [Async] cases to produce a new [Resolvable].
  Resolvable<Object> fold(
    @noFuturesAllowed Resolvable<Object>? Function(Sync<T> sync) onSync,
    @noFuturesAllowed Resolvable<Object>? Function(Async<T> async) onAsync,
  );

  /// Exhaustively handles the inner [Ok] and [Err] cases, returning a new
  /// [Resolvable].
  Resolvable<Object> foldResult(
    @noFuturesAllowed Result<Object>? Function(Ok<T> ok) onOk,
    @noFuturesAllowed Result<Object>? Function(Err<T> err) onErr,
  );

  /// Ensures that resolving this value takes at least a specified [duration].
  /// If [duration] is null, this method returns the original value immediately.
  Resolvable<T> withMinDuration(Duration? duration) {
    if (duration == null) {
      return this;
    }
    return Async<Result<T>>(() async {
      return _withMinDuration(value, duration);
    }).flatten();
  }

  FutureOr<R> _withMinDuration<R extends Object>(
    FutureOr<R> input,
    Duration? duration,
  ) {
    if (duration == null) {
      return input;
    }
    return Future.wait([
      Future.value(input),
      Future<void>.delayed(duration),
    ]).then((e) => e.first as R);
  }

  /// Unsafely converts this [Resolvable] to a [Sync]. Throws if it's an [Async].
  Sync<T> toSync();

  /// Converts this [Resolvable] to an [Async].
  Async<T> toAsync();

  /// Returns the contained [Ok] value or `null`, resolving any [Future].
  Future<T?> orNull();

  /// Returns this if it's [Sync], otherwise returns `other`.
  Resolvable<T> syncOr(Resolvable<T> other);

  /// Returns this if it's [Async], otherwise returns `other`.
  Resolvable<T> asyncOr(Resolvable<T> other);

  /// Returns this if it contains an [Ok], otherwise returns `other`.
  Resolvable<T> okOr(Resolvable<T> other);

  /// Returns this if it contains an [Err], otherwise returns `other`.
  Resolvable<T> errOr(Resolvable<T> other);

  /// Safely gets the [Ok] instance, resolving any [Future].
  FutureOr<Option<Ok<T>>> ok();

  /// Safely gets the [Err] instance, resolving any [Future].
  FutureOr<Option<Err<T>>> err();

  @override
  @unsafeOrError
  FutureOr<T> unwrap();

  @override
  FutureOr<T> unwrapOr(T fallback);

  /// Prefer using [then] for [Resolvable].
  @protected
  @override
  Resolvable<R> map<R extends Object>(
    @noFuturesAllowed R Function(T value) noFuturesAllowed,
  );

  Resolvable<R> then<R extends Object>(
    @noFuturesAllowed R Function(T value) noFuturesAllowed,
  );

  Resolvable<R> whenComplete<R extends Object>(
    @noFuturesAllowed Resolvable<R> Function(Sync<T> resolved) noFuturesAllowed,
  );

  @override
  Resolvable<R> transf<R extends Object>([
    @noFuturesAllowed R Function(T e)? noFuturesAllowed,
  ]);

  @override
  @pragma('vm:prefer-inline')
  Some<Resolvable<T>> wrapInSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<Resolvable<T>> wrapInOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Resolvable<T>> wrapInResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<Resolvable<T>> wrapInSync() => Sync.okValue(this);

  @override
  @pragma('vm:prefer-inline')
  Async<Resolvable<T>> wrapInAsync() => Async.okValue(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Some<T>> wrapValueInSome() => map((e) => Some(e));

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Ok<T>> wrapValueInOk() => map((e) => Ok(e));

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Resolvable<T>> wrapValueInResolvable() => map((e) => Sync.okValue(e));

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Sync<T>> wrapValueInSync() => map((e) => Sync.okValue(e));

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Async<T>> wrapValyeInAsync() => map((e) => Async.okValue(e));

  @override
  @visibleForTesting
  @pragma('vm:prefer-inline')
  Resolvable<void> asVoid() => this;
}

// --------------------------------------------------
// Source: ./lib/src/monads/resolvable/_sync.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// part of '../monad/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represents a [Resolvable] that holds a synchronous [Result].
///
/// The contained [value] is never a [Future].
///
/// # IMPORTANT:
///
/// Do not use any Futures in the constructor [Sync.new] to ensure errors are
/// properly caught and propagated.
final class Sync<T extends Object> extends Resolvable<T> implements SyncImpl<T> {
  /// Combines 2 [Sync] monads into 1 containing a tuple of their values
  /// if all resolve to [Ok].
  ///
  /// If any resolve to [Err], applies [onErr] function to combine errors.
  ///
  /// See also: [combineSync].
  static Sync<(T1, T2)> zip2<T1 extends Object, T2 extends Object>(
    Sync<T1> s1,
    Sync<T2> s2, [
    @noFuturesAllowed Err<(T1, T2)> Function(Result<T1>, Result<T2>)? onErr,
  ]) {
    final combined = combineSync<Object>(
      [s1, s2],
      onErr: onErr == null ? null : (l) => onErr(l[0].transf<T1>(), l[1].transf<T2>()).transfErr(),
    );
    return combined.map((l) => (l[0] as T1, l[1] as T2));
  }

  /// Combines 3 [Sync] monads into 1 containing a tuple of their values
  /// if all resolve to [Ok].
  ///
  /// If any resolve to [Err], applies [onErr] function to combine errors.
  ///
  /// See also: [combineSync].
  static Sync<(T1, T2, T3)> zip3<T1 extends Object, T2 extends Object, T3 extends Object>(
    Sync<T1> s1,
    Sync<T2> s2,
    Sync<T3> s3, [
    @noFuturesAllowed Err<(T1, T2, T3)> Function(Result<T1>, Result<T2>, Result<T3>)? onErr,
  ]) {
    final combined = combineSync<Object>(
      [s1, s2, s3],
      onErr: onErr == null
          ? null
          : (l) => onErr(
                l[0].transf<T1>(),
                l[1].transf<T2>(),
                l[2].transf<T3>(),
              ).transfErr(),
    );
    return combined.map((l) => (l[0] as T1, l[1] as T2, l[2] as T3));
  }

  @override
  @pragma('vm:prefer-inline')
  Result<T> get value => super.value as Result<T>;

  Sync.result(Result<T> super.value)
      : assert(!isSubtype<T, Future<Object>>(), '$T must never be a Future.'),
        super.result();

  Sync.ok(Ok<T> super.ok)
      : assert(!isSubtype<T, Future<Object>>(), '$T must never be a Future.'),
        super.ok();

  Sync.okValue(T okValue)
      : assert(!isSubtype<T, Future<Object>>(), '$T must never be a Future.'),
        super.ok(Ok(okValue));

  Sync.err(Err<T> super.err)
      : assert(!isSubtype<T, Future<Object>>(), '$T must never be a Future.'),
        super.err();

  Sync.errValue(Object error, {int? statusCode})
      : assert(!isSubtype<T, Future<Object>>(), '$T must never be a Future.'),
        super.err(Err(error, statusCode: statusCode));

  /// Creates a [Sync] executing a synchronous function [noFuturesAllowed].
  ///
  /// # IMPORTANT:
  ///
  /// Do not use any Futures in [noFuturesAllowed] to ensure errors are be
  /// caught and propagated.
  factory Sync(
    @mustBeAnonymous @noFuturesAllowed T Function() noFuturesAllowed, {
    @noFuturesAllowed TOnErrorCallback<T>? onError,
    @noFuturesAllowed TVoidCallback? onFinalize,
  }) {
    assert(!isSubtype<T, Future<Object>>(), '$T must never be a Future.');
    return Sync.result(() {
      try {
        return Ok(noFuturesAllowed());
      } on Err catch (err) {
        return err.transfErr<T>();
      } catch (error, stackTrace) {
        try {
          if (onError == null) {
            rethrow;
          }
          return onError(error, stackTrace);
        } catch (error, stackTrace) {
          return Err<T>(
            error,
            stackTrace: stackTrace,
          );
        }
      } finally {
        onFinalize?.call();
      }
    }());
  }

  @override
  @pragma('vm:prefer-inline')
  bool isSync() => true;

  @override
  @pragma('vm:prefer-inline')
  bool isAsync() => false;

  @override
  @pragma('vm:prefer-inline')
  Ok<Sync<T>> sync() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Err<Async<T>> async() {
    return Err(
      'Called async() on Sync<$T>.',
    );
  }

  @override
  @pragma('vm:prefer-inline')
  Sync<T> ifSync(
    @noFuturesAllowed
    void Function(
      Sync<T> self,
      Sync<T> sync,
    ) noFuturesAllowed,
  ) {
    return Sync(() {
      noFuturesAllowed(this, this);
      return this;
    }).flatten().sync().unwrap();
  }

  @override
  @pragma('vm:prefer-inline')
  Sync<T> ifAsync(
    @noFuturesAllowed
    void Function(
      Sync<T> self,
      Async<T> async,
    ) noFuturesAllowed,
  ) {
    return this;
  }

  @override
  Resolvable<T> ifOk(
    @noFuturesAllowed
    void Function(
      Sync<T> self,
      Ok<T> ok,
    ) noFuturesAllowed,
  ) {
    return switch (value) {
      Ok<T> ok => Resolvable(() {
          noFuturesAllowed(this, ok);
          return value;
        }).flatten(),
      Err() => this,
    };
  }

  @override
  Resolvable<T> ifErr(
    @noFuturesAllowed
    void Function(
      Sync<T> self,
      Err<T> err,
    ) noFuturesAllowed,
  ) {
    return switch (value) {
      Ok() => this,
      Err<T> err => Sync(
          () {
            noFuturesAllowed(this, err);
            return value;
          },
        ).flatten(),
    };
  }

  @override
  @pragma('vm:prefer-inline')
  Sync<R> resultMap<R extends Object>(
    @noFuturesAllowed Result<R> Function(Result<T> value) noFuturesAllowed,
  ) {
    return Sync(() => noFuturesAllowed(value).unwrap());
  }

  @override
  @pragma('vm:prefer-inline')
  Resolvable<R> mapFutureOr<R extends Object>(
    FutureOr<R> Function(T value) mapper,
  ) {
    return Resolvable(() => mapper(value.unwrap()));
  }

  @override
  Resolvable<Object> fold(
    @noFuturesAllowed Resolvable<Object>? Function(Sync<T> sync) onSync,
    @noFuturesAllowed Resolvable<Object>? Function(Async<T> async) onAsync,
  ) {
    try {
      return onSync(this) ?? this;
    } catch (error, stackTrace) {
      return Sync.err(
        Err(
          error,
          stackTrace: stackTrace,
        ),
      );
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Sync<Object> foldResult(
    @noFuturesAllowed Result<Object>? Function(Ok<T> ok) onOk,
    @noFuturesAllowed Result<Object>? Function(Err<T> err) onErr,
  ) {
    return Sync.result(value.fold(onOk, onErr));
  }

  @override
  @pragma('vm:prefer-inline')
  Sync<T> toSync() => this;

  @override
  @pragma('vm:prefer-inline')
  Async<T> toAsync() => Async.result(value);

  @override
  @pragma('vm:prefer-inline')
  Future<T?> orNull() => Future.value(value.orNull());

  @override
  @pragma('vm:prefer-inline')
  Sync<T> syncOr(Resolvable<T> other) => this;

  @override
  @pragma('vm:prefer-inline')
  Resolvable<T> asyncOr(Resolvable<T> other) => other;

  @override
  @pragma('vm:prefer-inline')
  Resolvable<T> okOr(Resolvable<T> other) {
    switch (value) {
      case Ok():
        return this;
      case Err():
        return other;
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Resolvable<T> errOr(Resolvable<T> other) {
    switch (value) {
      case Err():
        return this;
      case Ok():
        return other;
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Option<Ok<T>> ok() => value.ok();

  @override
  @pragma('vm:prefer-inline')
  Option<Err<T>> err() => value.err();

  @override
  @unsafeOrError
  @pragma('vm:prefer-inline')
  T unwrap() => value.unwrap();

  @override
  T unwrapOr(T fallback) => value.unwrapOr(fallback);

  @override
  @pragma('vm:prefer-inline')
  Sync<R> map<R extends Object>(
    @noFuturesAllowed R Function(T value) noFuturesAllowed,
  ) {
    return Sync(() => value.map((e) => noFuturesAllowed(e)).unwrap());
  }

  /// Prefer using [map] for [Sync].
  @protected
  @override
  @pragma('vm:prefer-inline')
  Sync<R> then<R extends Object>(
    @noFuturesAllowed R Function(T value) noFuturesAllowed,
  ) {
    return map(noFuturesAllowed);
  }

  @override
  @pragma('vm:prefer-inline')
  Resolvable<R> whenComplete<R extends Object>(
    @noFuturesAllowed Resolvable<R> Function(Sync<T> resolved) noFuturesAllowed,
  ) {
    return Sync(() {
      value.unwrap(); // unwrap to throw if value has an Err.
      return Resolvable(() => noFuturesAllowed(this));
    }).flatten();
  }

  @override
  Sync<R> transf<R extends Object>([
    @noFuturesAllowed R Function(T e)? noFuturesAllowed,
  ]) {
    return Sync(() {
      final okOrErr = value.transf<R>(noFuturesAllowed);
      if (okOrErr.isErr()) {
        throw okOrErr;
      }
      return okOrErr.unwrap();
    });
  }

  @override
  @pragma('vm:prefer-inline')
  Some<Sync<T>> wrapInSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<Sync<T>> wrapInOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Sync<T>> wrapInResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<Sync<T>> wrapInSync() => Sync.okValue(this);

  @override
  @pragma('vm:prefer-inline')
  Async<Sync<T>> wrapInAsync() => Async.okValue(this);

  @override
  @pragma('vm:prefer-inline')
  Sync<Some<T>> wrapValueInSome() => map((e) => Some(e));

  @override
  @pragma('vm:prefer-inline')
  Sync<Ok<T>> wrapValueInOk() => map((e) => Ok(e));

  @override
  @pragma('vm:prefer-inline')
  Sync<Resolvable<T>> wrapValueInResolvable() => map((e) => Sync.okValue(e));

  @override
  @pragma('vm:prefer-inline')
  Sync<Sync<T>> wrapValueInSync() => map((e) => Sync.okValue(e));

  @override
  @pragma('vm:prefer-inline')
  Sync<Async<T>> wrapValyeInAsync() => map((e) => Async.okValue(e));

  @override
  @visibleForTesting
  @pragma('vm:prefer-inline')
  Sync<void> asVoid() => this;

  @override
  @pragma('vm:prefer-inline')
  void end() {}
}

// --------------------------------------------------
// Source: ./lib/src/monads/monad/monad.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import '/_common.dart';

// part '../option/_option.dart';
// part '../option/_some.dart';
// part '../option/_none.dart';
// part '../result/_result.dart';
// part '../result/_ok.dart';
// part '../result/_err.dart';
// part '../resolvable/_resolvable.dart';
// part '../resolvable/_async.dart';
// part '../resolvable/_sync.dart';

// part '../impl/_sync_impl.dart';
// part '../impl/_async_impl.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// The foundational sealed class for all monadic types like [Option], [Result],
/// and [Resolvable].
sealed class Monad<T extends Object> implements Equatable {
  final FutureOr<Object> value;

  const Monad(this.value);

  /// Reduces any nested [Monad] structure into a single [TResolvableOption].
  ///
  /// This flattens all [Monad] layers (`Option`, `Result`, `Resolvable`) into
  /// a final container that is always a `Resolvable` holding an `Option`.
  /// An [Err] state at any level will result in a failed `Resolvable`.
  TResolvableOption<R> reduce<R extends Object>() {
    return switch (this) {
      Some(value: final someValue) => Resolvable(() => Some(someValue as R)),
      Some(value: Monad<Object> monadValue) => monadValue.reduce<R>(),
      None() => syncNone<R>(),
      Ok(value: final someValue) => Resolvable(() => Some(someValue as R)),
      Ok(value: Monad<Object> monadValue) => monadValue.reduce<R>(),
      Err(error: final error) => Sync.err(Err(error)),
      Sync(value: final result) => result.reduce<R>(),
      Async(value: final futureResult) => Async<Option<R>>(() async {
          final result = await futureResult;
          final innerResolvable = result.reduce<R>();
          return (await innerResolvable.value).unwrap();
        }),
    };
  }

  /// The low-level primitive for reducing a [Monad] chain. It recursively
  /// unwraps all [Monad] layers to return the innermost raw value, forcing the
  /// caller to handle terminal states via callbacks.
  ///
  /// - [onErr]: A function that is called when an [Err] is encountered.
  /// - [onNone]: A function that is called when a [None] is encountered.
  FutureOr<Object> raw({
    required FutureOr<Object> Function(Err<Object> err) onErr,
    required FutureOr<Object> Function() onNone,
  }) {
    FutureOr<Object> dive(Object obj) {
      return switch (obj) {
        Err() => onErr(obj),
        None() => onNone(),
        Monad(value: final okValue) =>
          okValue is Future<Object> ? okValue.then(dive) : dive(okValue),
        Object() => obj,
      };
    }

    return dive(this);
  }

  /// Safely reduces any [Monad] chain to a single [Sync].
  ///
  /// It provides a direct way to get a raw synchronous value while collapsing
  /// all failure, empty, or asynchronous states into an [Err].
  ///
  /// ### Example
  /// ```dart
  /// final success = Ok(Some(42)).rawSync();      // Contains Ok(42)
  /// final empty = Ok(None<int>()).rawSync();   // Contains Err(...)
  /// final failed = Err('fail').rawSync();      // Contains Err('fail')
  /// final isAsync = Async(() => 1).rawSync(); // Contains Err(...)
  /// ```
  Sync rawSync() {
    return Sync(() {
      final value = raw(
        onErr: (err) => err,
        onNone: () => Err('The Monad resolved to a None (empty) state!'),
      );
      if (value is Future) {
        throw Err(
          'The Monad contains an asynchronous value! Use rawAsync instead.',
        );
      }
      if (value is Err) {
        throw value;
      }
      return value;
    });
  }

  /// Reduces any [Monad] chain to a single [Async].
  ///
  /// It provides a direct way to get a raw value while collapsing
  /// all failure and empty states into an [Err].
  ///
  /// ### Example
  /// ```dart
  /// final result = await Async(() => 'hello').rawAsync().value; // Ok('hello')
  /// final emptyResult = await Some(None<int>()).rawAsync().value; // Err(...)
  /// ```
  Async rawAsync() {
    return Async(() async {
      final value = await raw(
        onErr: (err) => err,
        onNone: () => Err('The Monad resolved to a None (empty) state!'),
      );
      if (value is Err) {
        throw value;
      }
      return value;
    });
  }

  /// **Strongly discouraged:** Unsafely returns the contained value.
  ///
  /// This method is the equivalent of the `!` (bang) operator for nullable
  /// types. It subverts the safety provided by the [Monad] by throwing an
  /// exception instead of allowing you to handle the failure state through
  /// the type system. A thrown exception from `unwrap()` should be considered a
  /// critical programming error.
  ///
  /// ---
  /// ### ⚠️ DANGER
  ///
  /// This method will throw an [Err] if the [Monad] is in a failure state
  /// ([Err] or [None]).
  ///
  /// ---
  /// ### Prefer Safer Alternatives:
  ///
  /// #### 1. To handle both success and failure cases:
  /// Use pattern matching with a `switch` expression. This is the most
  /// idiomatic and safest way to handle all possibilities.
  ///
  /// ```dart
  /// // For a Result<T>
  /// switch (myResult) {
  ///   case Ok(value: final data):
  ///     print('Success: $data');
  ///   case Err(error: final e):
  ///     print('Failure: $e');
  /// }
  ///
  /// // For an Option<T>
  /// switch (myOption) {
  ///   case Some(value: final data):
  ///     print('Found: $data');
  ///   case None():
  ///     print('Not found.');
  /// }
  /// ```
  ///
  /// #### 2. To provide a fallback value:
  /// Use [unwrapOr] to safely get the value or a default if it's absent.
  ///
  /// ```dart
  /// final user = findUser(id).unwrapOr(GuestUser());
  /// ```
  ///
  /// #### 3. To perform a side-effect only on success:
  /// Use `ifOk()` or `ifSome()` to run code without breaking the chain.
  ///
  /// ```dart
  //.   myResult.ifOk((ok) => logSuccess(ok.value));
  /// ```
  ///
  /// #### When is it okay to use `unwrap()`?
  /// The only acceptable time is within a test or a trusted context where a
  /// failure is a logic bug that *should* crash the test or program.
  /// Even then, it is best to wrap it in an `UNSAFE` block to signal this
  /// explicit breach of safety.
  ///
  /// ```dart
  /// final value = UNSAFE(() => Ok(1).unwrap()); // Signals deliberate unsafe access
  /// ```
  @unsafeOrError
  FutureOr<T> unwrap();

  /// Returns the contained value, or the `fallback` if the [Monad] is in an
  /// [Err] or [None] state.
  FutureOr<T> unwrapOr(T fallback);

  /// Transforms the contained value using the mapper function
  /// [noFuturesAllowed] while preserving the [Monad]'s structure.
  Monad<R> map<R extends Object>(
    @noFuturesAllowed R Function(T value) noFuturesAllowed,
  );

  /// Transforms the [Monad]'s generic type from `T` to `R`.
  ///
  /// Uses the transformer function [noFuturesAllowed] if provided, otherwise
  /// attempts a direct cast.
  Monad transf<R extends Object>([
    @noFuturesAllowed R Function(T e)? noFuturesAllowed,
  ]);

  /// Wraps this [Monad] in a [Some].
  Some<Monad<T>> wrapInSome();

  /// Wraps this [Monad] in  [Ok].
  Ok<Monad<T>> wrapInOk();

  /// Wraps this [Monad] in [Resolvable].
  Resolvable<Monad<T>> wrapInResolvable();

  /// Wraps this [Monad] in [Sync].
  Sync<Monad<T>> wrapInSync();

  /// Wraps this [Monad] in [Async].
  Async<Monad<T>> wrapInAsync();

  /// Wraps this [value] in  [Some].
  Monad<Some<T>> wrapValueInSome();

  /// Wraps this [value] in  [Ok].
  Monad<Ok<T>> wrapValueInOk();

  /// Wraps this [value] in  [Resolvable].
  Monad<Resolvable<T>> wrapValueInResolvable();

  /// Wraps this [value] in  [Sync].
  Monad<Sync<T>> wrapValueInSync();

  /// Wraps this [value] in  [Async].
  Monad<Async<T>> wrapValyeInAsync();

  /// Transforms the contained value to `void`.
  Monad<void> asVoid();

  /// Suppresses the linter error `must_use_monad`.
  FutureOr<void> end();

  @override
  @pragma('vm:prefer-inline')
  List<Object?> get props => [value];

  @override
  @pragma('vm:prefer-inline')
  bool? get stringify => false;
}

// --------------------------------------------------
// Source: ./lib/src/_src.g.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// GENERATED - DO NOT MODIFY BY HAND
// See: https://github.com/dev-cetera/df_generate_dart_indexes
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

export './unit/unit.dart';
export './unit/to_unit_on_monad_extensions.dart';
export './tools/safe_completer.dart';
export './tools/concurrent_task_batch.dart';
export './tools/task_sequencer.dart';
export './tools/to_safe_stream_extension.dart';
export 'tools/let_or_none/let_or_none_collections.dart';
export 'tools/let_or_none/let_or_none_map.dart';
export 'tools/let_or_none/let_or_none.dart';
export './tools/sequenced_task_batch.dart';
export './odd/here.dart';
export './odd/debug.dart';
export './odd/lazy.dart';
export './err_model/err_model.dart';
export './monads/monad/monad.dart';
export './ergonomics/monad_typedefs.dart';
export './ergonomics/ergonomic_extensions/iterable_extensions.dart';
export './ergonomics/ergonomic_extensions/string_extension.dart';
export './ergonomics/ergonomic_extensions/map_extensions.dart';
export './ergonomics/resolvable_extensions.dart';
export './ergonomics/typedefs.dart';
export './ergonomics/swap/swap_err.dart';
export './ergonomics/swap/swap_async.dart';
export './ergonomics/swap/swap_result.dart';
export './ergonomics/swap/swap_ok.dart';
export './ergonomics/swap/swap_resolvable.dart';
export './ergonomics/swap/swap_some.dart';
export './ergonomics/swap/swap_sync.dart';
export './ergonomics/swap/swap_none.dart';
export './ergonomics/swap/swap_option.dart';
export './ergonomics/flatten/flatten_option.dart';
export './ergonomics/flatten/flatten_resolvable.dart';
export './ergonomics/flatten/flatten_result.dart';
export './ergonomics/flatten/flatten_resolvable_result.dart';
export './ergonomics/combine_monads.dart';
export './ergonomics/unsafe.dart';
export './ergonomics/map_monad.dart';

// --------------------------------------------------
// Source: ./lib/src/ergonomics/monad_typedefs.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//
// Option Combinations
//
// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Represents an `Option` that contains a `Result`.
typedef TOptionResult<T extends Object> = Option<Result<T>>;

/// Represents an `Option` that contains an `Ok`.
typedef TOptionOk<T extends Object> = Option<Ok<T>>;

/// Represents an `Option` that contains an `Err`.
typedef TOptionErr<T extends Object> = Option<Err<T>>;

/// Represents an `Option` that contains a `Resolvable`.
typedef TOptionResolvable<T extends Object> = Option<Resolvable<T>>;

/// Represents an `Option` that contains a `Sync`.
typedef TOptionSync<T extends Object> = Option<Sync<T>>;

/// Represents an `Option` that contains an `Async`.
typedef TOptionAsync<T extends Object> = Option<Async<T>>;

/// Represents a nested `Option`.
typedef TOptionOption<T extends Object> = Option<Option<T>>;

/// Represents an `Option` that contains a `Some`.
typedef TOptionSome<T extends Object> = Option<Some<T>>;

/// Represents an `Option` that contains a `None`.
typedef TOptionNone<T extends Object> = Option<None<T>>;

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//
// Result Combinations
//
// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Represents a `Result` that contains an `Option`.
typedef TResultOption<T extends Object> = Result<Option<T>>;

/// Represents a `Result` that contains a `Some`.
typedef TResultSome<T extends Object> = Result<Some<T>>;

/// Represents a `Result` that contains a `None`.
typedef TResultNone<T extends Object> = Result<None<T>>;

/// Represents a `Result` that contains a `Resolvable`.
typedef TResultResolvable<T extends Object> = Result<Resolvable<T>>;

/// Represents a `Result` that contains a `Sync`.
typedef TResultSync<T extends Object> = Result<Sync<T>>;

/// Represents a `Result` that contains an `Async`.
typedef TResultAsync<T extends Object> = Result<Async<T>>;

/// Represents a nested `Result`.
typedef TResultResult<T extends Object> = Result<Result<T>>;

/// Represents a `Result` that contains an `Ok`.
typedef TResultOk<T extends Object> = Result<Ok<T>>;

/// Represents a `Result` that contains an `Err`.
typedef TResultErr<T extends Object> = Result<Err<T>>;

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//
// Resolvable Combinations
//
// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Represents a `Resolvable` that contains an `Option`.
typedef TResolvableOption<T extends Object> = Resolvable<Option<T>>;

/// Represents a `Resolvable` that contains a `Some`.
typedef TResolvableSome<T extends Object> = Resolvable<Some<T>>;

/// Represents a `Resolvable` that contains a `None`.
typedef TResolvableNone<T extends Object> = Resolvable<None<T>>;

/// Represents a `Resolvable` that contains a `Result`.
typedef TResolvableResult<T extends Object> = Resolvable<Result<T>>;

/// Represents a `Resolvable` that contains an `Ok`.
typedef TResolvableOk<T extends Object> = Resolvable<Ok<T>>;

/// Represents a `Resolvable` that contains an `Err`.
typedef TResolvableErr<T extends Object> = Resolvable<Err<T>>;

/// Represents a nested `Resolvable`.
typedef TResolvableResolvable<T extends Object> = Resolvable<Resolvable<T>>;

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//
// Sync Combinations
//
// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Represents a `Sync` that contains an `Option`.
typedef TSyncOption<T extends Object> = Sync<Option<T>>;

/// Represents a `Sync` that contains a `Some`.
typedef TSyncSome<T extends Object> = Sync<Some<T>>;

/// Represents a `Sync` that contains a `None`.
typedef TSyncNone<T extends Object> = Sync<None<T>>;

/// Represents a `Sync` that contains a `Result`.
typedef TSyncResult<T extends Object> = Sync<Result<T>>;

/// Represents a `Sync` that contains an `Ok`.
typedef TSyncOk<T extends Object> = Sync<Ok<T>>;

/// Represents a `Sync` that contains an `Err`.
typedef TSyncErr<T extends Object> = Sync<Err<T>>;

/// Represents a `Sync` that contains a `Resolvable`.
typedef TSyncResolvable<T extends Object> = Sync<Resolvable<T>>;

/// Represents a nested `Sync`.
typedef TSyncSync<T extends Object> = Sync<Sync<T>>;

/// Represents a `Sync` that contains an `Async`.
typedef TSyncAsync<T extends Object> = Sync<Async<T>>;

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//
// Async Combinations
//
// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Represents an `Async` that contains an `Option`.
typedef TAsyncOption<T extends Object> = Async<Option<T>>;

/// Represents an `Async` that contains a `Some`.
typedef TAsyncSome<T extends Object> = Async<Some<T>>;

/// Represents an `Async` that contains a `None`.
typedef TAsyncNone<T extends Object> = Async<None<T>>;

/// Represents an `Async` that contains a `Result`.
typedef TAsyncResult<T extends Object> = Async<Result<T>>;

/// Represents an `Async` that contains an `Ok`.
typedef TAsyncOk<T extends Object> = Async<Ok<T>>;

/// Represents an `Async` that contains an `Err`.
typedef TAsyncErr<T extends Object> = Async<Err<T>>;

/// Represents an `Async` that contains a `Resolvable`.
typedef TAsyncResolvable<T extends Object> = Async<Resolvable<T>>;

/// Represents an `Async` that contains a `Sync`.
typedef TAsyncSync<T extends Object> = Async<Sync<T>>;

/// Represents a nested `Async`.
typedef TAsyncAsync<T extends Object> = Async<Async<T>>;

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//
// Some Combinations
//
// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Represents a `Some` that contains a `Result`.
typedef TSomeResult<T extends Object> = Some<Result<T>>;

/// Represents a `Some` that contains an `Ok`.
typedef TSomeOk<T extends Object> = Some<Ok<T>>;

/// Represents a `Some` that contains an `Err`.
typedef TSomeErr<T extends Object> = Some<Err<T>>;

/// Represents a `Some` that contains a `Resolvable`.
typedef TSomeResolvable<T extends Object> = Some<Resolvable<T>>;

/// Represents a `Some` that contains a `Sync`.
typedef TSomeSync<T extends Object> = Some<Sync<T>>;

/// Represents a `Some` that contains an `Async`.
typedef TSomeAsync<T extends Object> = Some<Async<T>>;

/// Represents a `Some` that contains an `Option`.
typedef TSomeOption<T extends Object> = Some<Option<T>>;

/// Represents a nested `Some`.
typedef TSomeSome<T extends Object> = Some<Some<T>>;

/// Represents a `Some` that contains a `None`.
typedef TSomeNone<T extends Object> = Some<None<T>>;

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//
// Ok Combinations
//
// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Represents an `Ok` that contains an `Option`.
typedef TOkOption<T extends Object> = Ok<Option<T>>;

/// Represents an `Ok` that contains a `Some`.
typedef TOkSome<T extends Object> = Ok<Some<T>>;

/// Represents an `Ok` that contains a `None`.
typedef TOkNone<T extends Object> = Ok<None<T>>;

/// Represents an `Ok` that contains a `Resolvable`.
typedef TOkResolvable<T extends Object> = Ok<Resolvable<T>>;

/// Represents an `Ok` that contains a `Sync`.
typedef TOkSync<T extends Object> = Ok<Sync<T>>;

/// Represents an `Ok` that contains an `Async`.
typedef TOkAsync<T extends Object> = Ok<Async<T>>;

/// Represents an `Ok` that contains a `Result`.
typedef TOkResult<T extends Object> = Ok<Result<T>>;

/// Represents a nested `Ok`.
typedef TOkOk<T extends Object> = Ok<Ok<T>>;

/// Represents an `Ok` that contains an `Err`.
typedef TOkErr<T extends Object> = Ok<Err<T>>;

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//
// Err Combinations
//
// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Represents an `Err` that contains an `Option`.
typedef TErrOption<T extends Object> = Err<Option<T>>;

/// Represents an `Err` that contains a `Some`.
typedef TErrSome<T extends Object> = Err<Some<T>>;

/// Represents an `Err` that contains a `None`.
typedef TErrNone<T extends Object> = Err<None<T>>;

/// Represents an `Err` that contains a `Resolvable`.
typedef TErrResolvable<T extends Object> = Err<Resolvable<T>>;

/// Represents an `Err` that contains a `Sync`.
typedef TErrSync<T extends Object> = Err<Sync<T>>;

/// Represents an `Err` that contains an `Async`.
typedef TErrAsync<T extends Object> = Err<Async<T>>;

/// Represents an `Err` that contains a `Result`.
typedef TErrResult<T extends Object> = Err<Result<T>>;

/// Represents an `Err` that contains an `Ok`.
typedef TErrOk<T extends Object> = Err<Ok<T>>;

/// Represents a nested `Err`.
typedef TErrErr<T extends Object> = Err<Err<T>>;

// --------------------------------------------------
// Source: ./lib/src/ergonomics/ergonomic_extensions/iterable_extensions.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//
// General Iterable Extensions
//
// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $IterableExtension<T extends Object> on Iterable<T> {
  /// Returns this [Iterable] wrapped in a [Some] if it's not empty,
  /// otherwise returns [None].
  Option<Iterable<T>> get noneIfEmpty => isEmpty ? const None() : Some(this);

  /// Returns the first element as a [Some], or [None] if the [Iterable] is empty.
  Option<T> get firstOrNone {
    final it = iterator;
    return it.moveNext() ? Some(it.current) : const None();
  }

  /// Returns the last element as a [Some], or [None] if the [Iterable] is empty.
  Option<T> get lastOrNone => isEmpty ? const None() : Some(last);

  /// Returns the single element as a [Some], or [None] if the [Iterable] does
  /// not contain exactly one element.
  Option<T> get singleOrNone {
    final it = iterator;
    if (it.moveNext()) {
      final result = it.current;
      if (!it.moveNext()) {
        return Some(result);
      }
    }
    return const None();
  }

  /// Returns the first element satisfying [test] as a [Some], or [None].
  Option<T> firstWhereOrNone(bool Function(T element) test) {
    for (final element in this) {
      if (test(element)) return Some(element);
    }
    return const None();
  }

  /// Returns the last element satisfying [test] as a [Some], or [None].
  Option<T> lastWhereOrNone(bool Function(T element) test) {
    late T result;
    var found = false;
    for (final element in this) {
      if (test(element)) {
        result = element;
        found = true;
      }
    }
    return found ? Some(result) : const None();
  }

  /// Returns the single element satisfying [test] as a [Some], or [None].
  Option<T> singleWhereOrNone(bool Function(T element) test) {
    late T result;
    var found = false;
    for (final element in this) {
      if (test(element)) {
        if (found) return const None(); // Found more than one
        result = element;
        found = true;
      }
    }
    return found ? Some(result) : const None();
  }

  /// Reduces the collection to a single value by iteratively combining elements.
  /// Returns the result as a [Some], or [None] if the [Iterable] is empty.
  Option<T> reduceOrNone(T Function(T value, T element) combine) {
    if (isEmpty) return const None();
    return Some(reduce(combine));
  }

  /// Returns the element at the given [index] as a [Some], or [None] if the
  /// index is out of bounds.
  Option<T> elementAtOrNone(int index) {
    if (index < 0) return const None();
    var i = 0;
    for (final element in this) {
      if (i == index) return Some(element);
      i++;
    }
    return const None();
  }
}

extension $NoneIfEmptyOnListExtension<T extends Object> on List<T> {
  /// Returns this list wrapped in a [Some] if it's not empty, otherwise
  /// returns [None].
  Option<List<T>> get noneIfEmpty => isEmpty ? const None() : Some(this);
}

extension $NoneIfEmptyOnSetExtension<T extends Object> on Set<T> {
  /// Returns this set wrapped in a [Some] if it's not empty, otherwise returns
  /// [None].
  Option<Set<T>> get noneIfEmpty => isEmpty ? const None() : Some(this);
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//
// Monadic Iterable Extensions
//
// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $IterableOptionExtension<T extends Object> on Iterable<Option<T>> {
  /// Filters for [Some] elements, returning an iterable of the [Some] instances.
  Iterable<Some<T>> whereSome() => where((e) => e.isSome()).map((e) => e.some().unwrap());

  /// Filters for [None] elements, returning an iterable of the [None] instances.
  Iterable<None<T>> whereNone() => where((e) => e.isNone()).map((e) => e.none().unwrap());

  /// Returns a new [Iterable] containing only the values from [Some] elements.
  Iterable<T> get values => where((e) => e.isSome()).map((e) => e.unwrap());

  /// Turns an `Iterable<Option<T>>` into an `Option<List<T>>`.
  /// If all elements are [Some], it returns a `Some<List<T>>`. If any element
  /// is a [None], it returns [None].
  Option<List<T>> sequenceList() {
    final buffer = <T>[];
    for (final e in this) {
      if (e.isNone()) return const None();
      buffer.add(e.unwrap());
    }
    return Some(buffer);
  }

  /// Turns an `Iterable<Option<T>>` into an `Option<Set<T>>`.
  /// If all elements are [Some], it returns a `Some<Set<T>>`. If any element
  /// is a [None], it returns [None].
  Option<Set<T>> sequenceSet() {
    final buffer = <T>{};
    for (final e in this) {
      if (e.isNone()) return const None();
      buffer.add(e.unwrap());
    }
    return Some(buffer);
  }

  /// Partitions the iterable into `someParts` and `noneParts` in a single pass.
  OptionPartition<T> partition() {
    final someParts = <Some<T>>[];
    final noneParts = <None<T>>[];
    for (final option in this) {
      switch (option) {
        case Some():
          someParts.add(option);
        case None():
          noneParts.add(option);
      }
    }
    return (someParts: someParts, noneParts: noneParts);
  }
}

extension $IterableFutureOptionExtension<T extends Object> on Iterable<Future<Option<T>>> {
  /// Awaits all futures and then filters for [Some] elements.
  Future<Iterable<Some<T>>> whereSome() => Future.wait(this).then((e) => e.whereSome());

  /// Awaits all futures and then filters for [None] elements.
  Future<Iterable<None<T>>> whereNone() => Future.wait(this).then((e) => e.whereNone());
}

extension $IterableSomeExtension<T extends Object> on Iterable<Some<T>> {
  /// Extracts the value from every [Some] element in the iterable.
  Iterable<T> unwrapAll() => map((e) => e.value);
}

extension $FutureIterableSomeExtension<T extends Object> on Future<Iterable<Some<T>>> {
  /// Awaits and then extracts the value from every [Some] element.
  Future<Iterable<T>> unwrapAll() => then((e) => e.unwrapAll());
}

extension $IterableResultExtension<T extends Object> on Iterable<Result<T>> {
  /// Filters for [Ok] elements, returning an iterable of the [Ok] instances.
  Iterable<Ok<T>> whereOk() => where((e) => e.isOk()).map((e) => e.ok().unwrap());

  /// Filters for [Err] elements, returning an iterable of the [Err] instances.
  Iterable<Err<T>> whereErr() => where((e) => e.isErr()).map((e) => e.err().unwrap());

  /// Returns a new [Iterable] containing only the values from [Ok] elements.
  Iterable<T> get values => where((e) => e.isOk()).map((e) => e.unwrap());

  /// Turns an `Iterable<Result<T>>` into an `Option<List<T>>`.
  /// If all elements are [Ok], it returns a `Some<List<T>>`. If any element
  /// is an [Err], it returns [None], discarding the specific error.
  Option<List<T>> sequenceList() {
    final buffer = <T>[];
    for (final e in this) {
      if (e.isErr()) {
        return const None();
      }
      buffer.add(e.unwrap());
    }
    return Some(buffer);
  }

  /// Turns an `Iterable<Result<T>>` into an `Option<Set<T>>`.
  /// If all elements are [Ok], it returns a `Some<Set<T>>`. If any element
  /// is an [Err], it returns [None], discarding the specific error.
  Option<Set<T>> sequenceSet() {
    final buffer = <T>{};
    for (final e in this) {
      if (e.isErr()) {
        return const None();
      }
      buffer.add(e.unwrap());
    }
    return Some(buffer);
  }

  /// Partitions the iterable into `okParts` and `errParts` in a single pass.
  ResultPartition<T> partition() {
    final okParts = <Ok<T>>[];
    final errParts = <Err<T>>[];
    for (final result in this) {
      switch (result) {
        case Ok():
          okParts.add(result);
        case Err():
          errParts.add(result);
      }
    }
    return (okParts: okParts, errParts: errParts);
  }
}

extension $IterableFutureResultExtension<T extends Object> on Iterable<Future<Result<T>>> {
  /// Awaits all futures and then filters for [Ok] elements.
  Future<Iterable<Ok<T>>> whereOk() => Future.wait(this).then((e) => e.whereOk());

  /// Awaits all futures and then filters for [Err] elements.
  Future<Iterable<Err<T>>> whereErr() => Future.wait(this).then((e) => e.whereErr());
}

extension $IterableOkExtension<T extends Object> on Iterable<Ok<T>> {
  /// Extracts the value from every [Ok] element in the iterable.
  Iterable<T> unwrapAll() => map((e) => e.value);
}

extension $FutureIterableOkExtension<T extends Object> on Future<Iterable<Ok<T>>> {
  /// Awaits and then extracts the value from every [Ok] element.
  Future<Iterable<T>> unwrapAll() => then((e) => e.unwrapAll());
}

extension $IterableResolvableExtension<T extends Object> on Iterable<Resolvable<T>> {
  /// Filters for [Sync] elements, returning an iterable of the [Sync] instances.
  Iterable<Sync<T>> whereSync() => where((e) => e.isSync()).map((e) => e.sync().unwrap());

  /// Filters for [Async] elements, returning an iterable of the [Async] instances.
  Iterable<Async<T>> whereAsync() => where((e) => e.isAsync()).map((e) => e.async().unwrap());

  /// Converts every [Resolvable] in the iterable to an [Async].
  Iterable<Async<T>> mapToAsync() => map((e) => e.toAsync());

  /// Partitions the iterable into `syncParts` and `asyncParts` in a single pass.
  ResolvablePartition<T> partition() {
    final syncParts = <Sync<T>>[];
    final asyncParts = <Async<T>>[];
    for (final resolvable in this) {
      if (resolvable.isSync()) {
        syncParts.add(resolvable as Sync<T>);
      } else {
        asyncParts.add(resolvable as Async<T>);
      }
    }
    return (syncParts: syncParts, asyncParts: asyncParts);
  }
}

extension $IterableSyncExtension<T extends Object> on Iterable<Sync<T>> {
  /// Extracts the inner [Result] from each [Sync] element.
  Iterable<Result<T>> mapToResults() => map((e) => e.value);

  Sync<List<T>> resolveInSequence() {
    final values = <T>[];
    final series = TaskSequencer<T>();
    for (final e in this) {
      series.then((_) {
        return e.map((e) {
          values.add(e);
          return e;
        }).wrapValueInSome();
      }).end();
    }
    return series.completion.then((_) => values).sync().unwrap();
  }
}

extension $IterableAsyncExtension<T extends Object> on Iterable<Async<T>> {
  /// Extracts the inner `Future<Result>` from each [Async] element.
  Iterable<Future<Result<T>>> mapToResults() => map((e) => e.value);
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//
// Partition Typedefs
//
// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// The result of partitioning an `Iterable<Option<T>>`.
typedef OptionPartition<T extends Object> = ({
  Iterable<Some<T>> someParts,
  Iterable<None<T>> noneParts
});

/// The result of partitioning an `Iterable<Result<T>>`.
typedef ResultPartition<T extends Object> = ({Iterable<Ok<T>> okParts, Iterable<Err<T>> errParts});

/// The result of partitioning an `Iterable<Resolvable<T>>`.
typedef ResolvablePartition<T extends Object> = ({
  Iterable<Sync<T>> syncParts,
  Iterable<Async<T>> asyncParts
});

// --------------------------------------------------
// Source: ./lib/src/ergonomics/ergonomic_extensions/string_extension.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $StringExtension on String {
  // Returns this string wrapped in a [Some] if it's not empty,
  /// otherwise returns [None].
  Option<String> get noneIfEmpty {
    return Option.from(isEmpty ? null : this);
  }

  /// Returns the first character as a [Some], or [None] if the string is empty.
  Option<String> get firstOrNone => isEmpty ? const None() : Some(this[0]);

  /// Returns the last character as a [Some], or [None] if the string is empty.
  Option<String> get lastOrNone => isEmpty ? const None() : Some(this[length - 1]);

  /// Returns the character at the given [index] as a [Some], or [None] if the
  /// index is out of bounds.
  Option<String> elementAtOrNone(int index) {
    if (index < 0 || index >= length) {
      return const None();
    }
    return Some(this[index]);
  }
}

// --------------------------------------------------
// Source: ./lib/src/ergonomics/ergonomic_extensions/map_extensions.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//
// General Map Extensions
//
// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $MapGeneralExtensions<K, V extends Object> on Map<K, V> {
  /// Returns this map wrapped in a [Some] if it's not empty,
  /// otherwise returns [None].
  Option<Map<K, V>> get noneIfEmpty {
    return isEmpty ? const None() : Some(this);
  }

  /// Safely gets the value for a given [key], returning an [Option].
  Option<V> getOption(K key) {
    // V does not need to extend Object here because this[key] can be null.
    // Option.from() correctly handles creating a Some<V> or a None<V>.
    return Option.from(this[key]);
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//
// Monadic Map Extensions
//
// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $MapOfOptionsExtensions<K, V extends Object> on Map<K, Option<V>> {
  /// Creates a new map containing only the entries where the value is a [Some].
  /// The values in the new map are instances of [Some<V>].
  Map<K, Some<V>> whereSome() => Map.fromEntries(
        entries.where((e) => e.value.isSome()).map((e) => MapEntry(e.key, e.value.some().unwrap())),
      );

  /// Creates a new map containing only the entries where the value is a [None].
  Map<K, None<V>> whereNone() => Map.fromEntries(
        entries.where((e) => e.value.isNone()).map((e) => MapEntry(e.key, e.value.none().unwrap())),
      );

  /// Returns a new map containing only the unwrapped values from [Some] entries.
  Map<K, V> get someValues => Map.fromEntries(
        entries.where((e) => e.value.isSome()).map(
              (e) => MapEntry(e.key, e.value.unwrap()),
            ),
      );

  /// Turns a `Map<K, Option<V>>` into an `Option<Map<K, V>>`.
  /// If all values are [Some], it returns a `Some<Map<K, V>>`. If any value
  /// is a [None], it returns [None].
  Option<Map<K, V>> sequence() {
    final buffer = <K, V>{};
    for (final entry in entries) {
      switch (entry.value) {
        case Some(value: final v):
          buffer[entry.key] = v;
        case None():
          return const None();
      }
    }
    return Some(buffer);
  }

  /// Partitions the map into a record containing two maps: one for [Some]
  /// values and one for [None] values.
  MapOptionPartition<K, V> partition() {
    final someParts = <K, V>{};
    final noneKeys = <K>[];
    for (final entry in entries) {
      switch (entry.value) {
        case Some(value: final v):
          someParts[entry.key] = v;
        case None():
          noneKeys.add(entry.key);
      }
    }
    return (someParts: someParts, noneKeys: noneKeys);
  }
}

extension $MapOfResultsExtensions<K, V extends Object> on Map<K, Result<V>> {
  /// Creates a new map containing only the entries where the value is an [Ok].
  /// The values in the new map are instances of [Ok<V>].
  Map<K, Ok<V>> whereOk() => Map.fromEntries(
        entries.where((e) => e.value.isOk()).map((e) => MapEntry(e.key, e.value.ok().unwrap())),
      );

  /// Creates a new map containing only the entries where the value is an [Err].
  /// The values in the new map are instances of [Err<V>].
  Map<K, Err<V>> whereErr() => Map.fromEntries(
        entries.where((e) => e.value.isErr()).map((e) => MapEntry(e.key, e.value.err().unwrap())),
      );

  /// Returns a new map containing only the unwrapped values from [Ok] entries.
  Map<K, V> get okValues => Map.fromEntries(
        entries.where((e) => e.value.isOk()).map(
              (e) => MapEntry(e.key, e.value.unwrap()),
            ),
      );

  /// Turns a `Map<K, Result<V>>` into a `Result<Map<K, V>>`.
  /// If all values are [Ok], it returns an `Ok<Map<K, V>>`. If any value
  /// is an [Err], it returns the first [Err] encountered.
  Result<Map<K, V>> sequence() {
    final buffer = <K, V>{};
    for (final entry in entries) {
      switch (entry.value) {
        case Ok(value: final v):
          buffer[entry.key] = v;
        case Err err:
          return err.transfErr();
      }
    }
    return Ok(buffer);
  }

  /// Partitions the map into a record containing two maps: one for [Ok]
  /// values and one for [Err] values.
  MapResultPartition<K, V> partition() {
    final okParts = <K, V>{};
    final errParts = <K, Err<V>>{};
    for (final entry in entries) {
      switch (entry.value) {
        case Ok(value: final v):
          okParts[entry.key] = v;
        case Err err:
          errParts[entry.key] = err.transfErr();
      }
    }
    return (okParts: okParts, errParts: errParts);
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░
//
// Partition Typedefs
//
// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// The result of partitioning a `Map<K, Option<V>>`.
typedef MapOptionPartition<K, V extends Object> = ({
  Map<K, V> someParts,
  List<K> noneKeys,
});

/// The result of partitioning a `Map<K, Result<V>>`.
typedef MapResultPartition<K, V extends Object> = ({
  Map<K, V> okParts,
  Map<K, Err<V>> errParts,
});

// --------------------------------------------------
// Source: ./lib/src/ergonomics/resolvable_extensions.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $ToResolvableExtension<T extends Object> on FutureOr<T> {
  @pragma('vm:prefer-inline')
  Resolvable<T> toResolvable({
    @noFuturesAllowed TOnErrorCallback<T>? onError,
    @noFuturesAllowed TVoidCallback? onFinalize,
  }) {
    return Resolvable(() => this, onError: onError, onFinalize: onFinalize);
  }
}

extension $ToAsyncExtension<T extends Object> on Future<T> {
  @pragma('vm:prefer-inline')
  Async<T> toAsync({
    @noFuturesAllowed TOnErrorCallback<T>? onError,
    @noFuturesAllowed TVoidCallback? onFinalize,
  }) {
    assert(
      !isSubtype<T, Future<Object>>(),
      'Do not call toAsync on nested futures: $T.',
    );
    return Async(() => this, onError: onError, onFinalize: onFinalize);
  }
}

extension $ToSync<T extends Object> on T {
  @pragma('vm:prefer-inline')
  Sync<T> toSync({
    @noFuturesAllowed TOnErrorCallback<T>? onError,
    @noFuturesAllowed TVoidCallback? onFinalize,
  }) {
    assert(
      !isSubtype<T, Future<Object>>(),
      'Do not call toSync on futures: $T.',
    );
    return Sync(() => this, onError: onError, onFinalize: onFinalize);
  }
}

extension $SyncOptionExtension<T extends Object> on Sync<Option<T>> {
  @unsafeOrError
  @pragma('vm:prefer-inline')
  T unwrapSync() => unwrap().unwrap();
}

extension $AsyncOptionExtension<T extends Object> on Async<Option<T>> {
  @unsafeOrError
  @pragma('vm:prefer-inline')
  Future<T> unwrapAsync() => unwrap().then((e) => e.unwrap());
}

extension $ResolvableOptionExtension<T extends Object> on Resolvable<Option<T>> {
  @unsafeOrError
  @pragma('vm:prefer-inline')
  T unwrapSync() => sync().unwrap().unwrapSync();

  @unsafeOrError
  @pragma('vm:prefer-inline')
  Future<T> unwrapAsync() => async().unwrap().unwrapAsync();
}

// --------------------------------------------------
// Source: ./lib/src/ergonomics/typedefs.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

typedef TOnErrorCallback<T extends Object> = Err<T> Function(Object? error, StackTrace stackTrace);
typedef TVoidCallback = void Function();

const OK_UNIT = Ok(UNIT);
const SOME_UNIT = Some(UNIT);
const NONE_UNIT = None<Unit>();

@pragma('vm:prefer-inline')
Sync<Unit> syncUnit() => Sync.okValue(Unit());

@pragma('vm:prefer-inline')
Sync<None<T>> syncNone<T extends Object>() => Sync.okValue(const None());

@pragma('vm:prefer-inline')
Sync<Some<T>> syncSome<T extends Object>(T value) => Sync.okValue(Some(value));

@pragma('vm:prefer-inline')
Async<Unit> asyncUnit() => Async.okValue(Unit());

@pragma('vm:prefer-inline')
Async<None<T>> asyncNone<T extends Object>() => Async.okValue(const None());

@pragma('vm:prefer-inline')
Async<Some<T>> asyncSome<T extends Object>(FutureOr<T> value) {
  assert(!isSubtype<T, Future<Object>>(), '$T must never be a Future.');
  return Async(() async => Some(await value));
}

@pragma('vm:prefer-inline')
Resolvable<None<T>> resolvableNone<T extends Object>() => syncNone();

@pragma('vm:prefer-inline')
Resolvable<Some<T>> resolvableSome<T extends Object>(T value) => syncSome(value);

@pragma('vm:prefer-inline')
Resolvable<Unit> resolvableUnit() => syncUnit();

// --------------------------------------------------
// Source: ./lib/src/ergonomics/swap/swap_err.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $ErrSyncSwapExtension<T extends Object> on Err<Sync<T>> {
  @pragma('vm:prefer-inline')
  Sync<Err<T>> swap() => transfErr<T>().wrapInSync();
}

extension $ErrAsyncSwapExtension<T extends Object> on Err<Async<T>> {
  @pragma('vm:prefer-inline')
  Async<Err<T>> swap() => transfErr<T>().wrapInAsync();
}

extension $ErrResolvableSwapExtension<T extends Object> on Err<Resolvable<T>> {
  @pragma('vm:prefer-inline')
  Resolvable<Err<T>> swap() => transfErr<T>().wrapInSync();
}

extension $ErrOptionSwapExtension<T extends Object> on Err<Option<T>> {
  @pragma('vm:prefer-inline')
  Option<Err<T>> swap() => Some(transfErr<T>());
}

extension $ErrSomeSwapExtension<T extends Object> on Err<Some<T>> {
  @pragma('vm:prefer-inline')
  Some<Err<T>> swap() => Some(transfErr<T>());
}

extension $ErrNoneSwapExtension<T extends Object> on Err<None<T>> {
  @pragma('vm:prefer-inline')
  None<Err<T>> swap() => const None();
}

extension $ErrResultSwapExtension<T extends Object> on Err<Result<T>> {
  @pragma('vm:prefer-inline')
  Result<Err<T>> swap() => Ok(transfErr<T>());
}

extension $ErrOkSwapExtension<T extends Object> on Err<Ok<T>> {
  @pragma('vm:prefer-inline')
  Ok<Err<T>> swap() => Ok(transfErr<T>());
}

// --------------------------------------------------
// Source: ./lib/src/ergonomics/swap/swap_async.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $AsyncSomeSwapExtension<T extends Object> on Async<Some<T>> {
  @pragma('vm:prefer-inline')
  Some<Async<T>> swap() => Some(map((e) => e.unwrap()));
}

extension $AsyncNoneSwapExtension<T extends Object> on Async<None<T>> {
  @pragma('vm:prefer-inline')
  None<Async<T>> swap() => const None();
}

extension $AsyncOkSwapExtension<T extends Object> on Async<Ok<T>> {
  @pragma('vm:prefer-inline')
  Ok<Async<T>> swap() => Ok(map((e) => e.unwrap()));
}

// --------------------------------------------------
// Source: ./lib/src/ergonomics/swap/swap_result.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $ResultSyncSwapExtension<T extends Object> on Result<Sync<T>> {
  @pragma('vm:prefer-inline')
  Sync<Result<T>> swap() {
    if (this is Ok<Sync<T>>) {
      return (this as Ok<Sync<T>>).swap();
    }
    return (this as Err<Sync<T>>).swap();
  }
}

extension $ResultAsyncSwapExtension<T extends Object> on Result<Async<T>> {
  @pragma('vm:prefer-inline')
  Async<Result<T>> swap() {
    if (this is Ok<Async<T>>) {
      return (this as Ok<Async<T>>).swap();
    }
    return (this as Err<Async<T>>).swap();
  }
}

extension $ResultResolvableSwapExtension<T extends Object> on Result<Resolvable<T>> {
  @pragma('vm:prefer-inline')
  Resolvable<Result<T>> swap() {
    if (this is Ok<Resolvable<T>>) {
      return (this as Ok<Resolvable<T>>).swap();
    }
    return (this as Err<Resolvable<T>>).swap();
  }
}

extension $ResultOptionSwapExtension<T extends Object> on Result<Option<T>> {
  @pragma('vm:prefer-inline')
  Option<Result<T>> swap() {
    if (this is Ok<Option<T>>) {
      return (this as Ok<Option<T>>).swap();
    }
    return (this as Err<Option<T>>).swap();
  }
}

extension $ResultSomeSwapExtension<T extends Object> on Result<Some<T>> {
  @pragma('vm:prefer-inline')
  Some<Result<T>> swap() {
    if (this is Ok<Some<T>>) {
      return (this as Ok<Some<T>>).swap();
    }
    return (this as Err<Some<T>>).swap();
  }
}

extension $ResultNoneSwapExtension<T extends Object> on Result<None<T>> {
  @pragma('vm:prefer-inline')
  Option<Result<T>> swap() {
    if (this is Ok<None<T>>) {
      return (this as Ok<None<T>>).swap();
    }
    return (this as Err<None<T>>).swap();
  }
}

extension $ResultOkSwapExtension<T extends Object> on Result<Ok<T>> {
  @pragma('vm:prefer-inline')
  Ok<Result<T>> swap() {
    if (this is Ok<Ok<T>>) {
      return this as Ok<Ok<T>>;
    }
    return (this as Err<Ok<T>>).swap();
  }
}

extension $ResultErrSwapExtension<T extends Object> on Result<Err<T>> {
  @pragma('vm:prefer-inline')
  Result<T> swap() {
    if (this is Ok<Err<T>>) {
      return (this as Ok<Err<T>>).unwrap();
    }
    return (this as Err<Err<T>>).transfErr();
  }
}

// --------------------------------------------------
// Source: ./lib/src/ergonomics/swap/swap_ok.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $OkSyncSwapExtension<T extends Object> on Ok<Sync<T>> {
  @pragma('vm:prefer-inline')
  Sync<Ok<T>> swap() => unwrap().map((e) => Ok(e));
}

extension $OkAsyncSwapExtension<T extends Object> on Ok<Async<T>> {
  @pragma('vm:prefer-inline')
  Async<Ok<T>> swap() => unwrap().map((e) => Ok(e));
}

extension $OkResolvableSwapExtension<T extends Object> on Ok<Resolvable<T>> {
  @pragma('vm:prefer-inline')
  Resolvable<Ok<T>> swap() => unwrap().then((e) => Ok(e));
}

extension $OkOptionSwapExtension<T extends Object> on Ok<Option<T>> {
  @pragma('vm:prefer-inline')
  Option<Ok<T>> swap() => unwrap().map((e) => Ok(e));
}

extension $OkSomeSwapExtension<T extends Object> on Ok<Some<T>> {
  @pragma('vm:prefer-inline')
  Some<Ok<T>> swap() => unwrap().map((e) => Ok(e));
}

extension $OkNoneSwapExtension<T extends Object> on Ok<None<T>> {
  @pragma('vm:prefer-inline')
  None<Ok<T>> swap() => const None();
}

extension $OkResultSwapExtension<T extends Object> on Ok<Result<T>> {
  @pragma('vm:prefer-inline')
  Result<Ok<T>> swap() => unwrap().map((e) => Ok(e));
}

extension $OkErrSwapExtension<T extends Object> on Ok<Err<T>> {
  @pragma('vm:prefer-inline')
  Err<Ok<T>> swap() => unwrap().transfErr<Ok<T>>();
}

// --------------------------------------------------
// Source: ./lib/src/ergonomics/swap/swap_resolvable.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $ResolvableSomeSwapExtension<T extends Object> on Resolvable<Some<T>> {
  @pragma('vm:prefer-inline')
  Some<Resolvable<T>> swap() {
    if (this is Sync<Some<T>>) {
      return (this as Sync<Some<T>>).swap();
    }
    return (this as Async<Some<T>>).swap();
  }
}

extension $ResolvableNoneSwapExtension<T extends Object> on Resolvable<None<T>> {
  @pragma('vm:prefer-inline')
  None<Resolvable<T>> swap() => const None();
}

extension $ResolvableOkSwapExtension<T extends Object> on Resolvable<Ok<T>> {
  @pragma('vm:prefer-inline')
  Ok<Resolvable<T>> swap() {
    return Ok(then((e) => e.unwrap()));
  }
}

// --------------------------------------------------
// Source: ./lib/src/ergonomics/swap/swap_some.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $SomeSyncSwapExtension<T extends Object> on Some<Sync<T>> {
  @pragma('vm:prefer-inline')
  Sync<Some<T>> swap() => unwrap().map((e) => Some(e));
}

extension $SomeAsyncSwapExtension<T extends Object> on Some<Async<T>> {
  @pragma('vm:prefer-inline')
  Async<Some<T>> swap() => unwrap().then((e) => Some(e));
}

extension $SomeResolvableSwapExtension<T extends Object> on Some<Resolvable<T>> {
  @pragma('vm:prefer-inline')
  Resolvable<Some<T>> swap() => unwrap().then((e) => Some(e));
}

extension $SomeOptionSwapExtension<T extends Object> on Some<Option<T>> {
  @pragma('vm:prefer-inline')
  Option<Some<T>> swap() => unwrap().map((e) => Some(e));
}

extension $SomeNoneSwapExtension<T extends Object> on Some<None<T>> {
  @pragma('vm:prefer-inline')
  None<Some<T>> swap() => const None();
}

extension $SomeResultSwapExtension<T extends Object> on Some<Result<T>> {
  @pragma('vm:prefer-inline')
  Result<Some<T>> swap() => unwrap().map((e) => Some(e));
}

extension $SomeOkSwapExtension<T extends Object> on Some<Ok<T>> {
  @pragma('vm:prefer-inline')
  Ok<Some<T>> swap() => Ok(Some(unwrap().unwrap()));
}

extension $SomeErrSwapExtension<T extends Object> on Some<Err<T>> {
  @pragma('vm:prefer-inline')
  Err<Some<T>> swap() => unwrap().transfErr<Some<T>>();
}

// --------------------------------------------------
// Source: ./lib/src/ergonomics/swap/swap_sync.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $SyncAsyncSwapExtension<T extends Object> on Sync<Async<T>> {
  @pragma('vm:prefer-inline')
  Async<Sync<T>> swap() {
    switch (value) {
      case Ok(value: final asyncValue):
        return Async(() async {
          final innerResult = await asyncValue.value;
          return Sync.result(innerResult);
        });
      case final Err<Async<T>> err:
        final failedSync = Sync.err(err.transfErr<T>());
        return Async.okValue(failedSync);
    }
  }
}

extension $SyncResolvableSwapExtension<T extends Object> on Sync<Resolvable<T>> {
  @pragma('vm:prefer-inline')
  Resolvable<Sync<T>> swap() {
    switch (value) {
      case Ok(value: final resolvableValue):
        switch (resolvableValue) {
          case Sync(value: final syncValue):
            return Sync.okValue(Sync.result(syncValue));
          case Async(value: final asyncValue):
            return Async<Sync<T>>(() async {
              final result = await asyncValue;
              return Sync.result(result);
            });
        }
      case final Err<Resolvable<T>> err:
        final failedSync = Sync.err(err.transfErr<T>());
        return Sync.okValue(failedSync);
    }
  }
}

extension $SyncOptionSwapExtension<T extends Object> on Sync<Option<T>> {
  @pragma('vm:prefer-inline')
  Option<Sync<T>> swap() {
    switch (value) {
      case Ok(value: final optionValue):
        switch (optionValue) {
          case Some(value: final someValue):
            return Sync.okValue(someValue).wrapInSome();
          case None():
            return const None();
        }
      case final Err<Option<T>> err:
        return Sync.err(err.transfErr<T>()).wrapInSome();
    }
  }
}

extension $SyncSomeSwapExtension<T extends Object> on Sync<Some<T>> {
  @pragma('vm:prefer-inline')
  Some<Sync<T>> swap() => map((e) => e.unwrap()).wrapInSome();
}

extension $SyncNoneSwapExtension<T extends Object> on Sync<None<T>> {
  @pragma('vm:prefer-inline')
  None<Sync<T>> swap() => const None();
}

extension $SyncResultSwapExtension<T extends Object> on Sync<Result<T>> {
  @pragma('vm:prefer-inline')
  Result<Sync<T>> swap() {
    switch (value) {
      case Ok(value: final resultValue):
        switch (resultValue) {
          case Ok(value: final okValue):
            return Sync.okValue(okValue).wrapInOk();
          case final Err<T> err:
            return err.transfErr<Sync<T>>();
        }
      case final Err<Result<T>> err:
        return err.transfErr<Sync<T>>();
    }
  }
}

extension $SyncOkSwapExtension<T extends Object> on Sync<Ok<T>> {
  @pragma('vm:prefer-inline')
  Ok<Sync<T>> swap() => Ok(Sync.okValue(value.unwrap().unwrap()));
}

extension $SyncErrSwapExtension<T extends Object> on Sync<Err<T>> {
  @pragma('vm:prefer-inline')
  Err<Sync<T>> swap() => value.unwrap().transfErr<Sync<T>>();
}

// --------------------------------------------------
// Source: ./lib/src/ergonomics/swap/swap_none.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $NoneSyncSwapExtension<T extends Object> on None<Sync<T>> {
  @pragma('vm:prefer-inline')
  Sync<None<T>> swap() => None<T>().wrapInSync();
}

extension $NoneAsyncSwapExtension<T extends Object> on None<Async<T>> {
  @pragma('vm:prefer-inline')
  Async<None<T>> swap() => None<T>().wrapInAsync();
}

extension $NoneResolvableSwapExtension<T extends Object> on None<Resolvable<T>> {
  @pragma('vm:prefer-inline')
  Resolvable<None<T>> swap() => None<T>().wrapInResolvable();
}

extension $NoneOptionSwapExtension<T extends Object> on None<Option<T>> {
  @pragma('vm:prefer-inline')
  Option<None<T>> swap() => const Some(None());
}

extension $NoneSomeSwapExtension<T extends Object> on None<Some<T>> {
  @pragma('vm:prefer-inline')
  Some<None<T>> swap() => const Some(None());
}

extension $NoneResultSwapExtension<T extends Object> on None<Result<T>> {
  @pragma('vm:prefer-inline')
  Result<None<T>> swap() => const Ok(None());
}

extension $NoneOkSwapExtension<T extends Object> on None<Ok<T>> {
  @pragma('vm:prefer-inline')
  Ok<None<T>> swap() => const Ok(None());
}

extension $NoneErrSwapExtension<T extends Object> on None<Err<T>> {
  @pragma('vm:prefer-inline')
  Err<None<T>> swap() {
    return Err(const None());
  }
}

// --------------------------------------------------
// Source: ./lib/src/ergonomics/swap/swap_option.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $OptionSyncSwapExtension<T extends Object> on Option<Sync<T>> {
  @pragma('vm:prefer-inline')
  Sync<Option<T>> swap() {
    if (this is Some<Sync<T>>) {
      return (this as Some<Sync<T>>).swap();
    }
    return (this as None<Sync<T>>).swap();
  }
}

extension $OptionAsyncSwapExtension<T extends Object> on Option<Async<T>> {
  @pragma('vm:prefer-inline')
  Async<Option<T>> swap() {
    if (this is Some<Async<T>>) {
      return (this as Some<Async<T>>).swap();
    }
    return (this as None<Async<T>>).swap();
  }
}

extension $OptionResolvableSwapExtension<T extends Object> on Option<Resolvable<T>> {
  @pragma('vm:prefer-inline')
  Resolvable<Option<T>> swap() {
    if (this is Some<Resolvable<T>>) {
      return (this as Some<Resolvable<T>>).swap();
    }
    return (this as None<Resolvable<T>>).swap();
  }
}

extension $OptionSomeSwapExtension<T extends Object> on Option<Some<T>> {
  @pragma('vm:prefer-inline')
  Some<Option<T>> swap() {
    if (this is Some<Some<T>>) {
      return this as Some<Some<T>>;
    }
    return (this as None<Some<T>>).swap();
  }
}

extension $OptionNoneSwapExtension<T extends Object> on Option<None<T>> {
  @pragma('vm:prefer-inline')
  None<Option<T>> swap() {
    return const None();
  }
}

extension $OptionResultSwapExtension<T extends Object> on Option<Result<T>> {
  @pragma('vm:prefer-inline')
  Result<Option<T>> swap() {
    if (this is Some<Result<T>>) {
      return (this as Some<Result<T>>).swap();
    }
    return (this as None<Result<T>>).swap();
  }
}

extension $OptionOkSwapExtension<T extends Object> on Option<Ok<T>> {
  @pragma('vm:prefer-inline')
  Ok<Option<T>> swap() {
    if (this is Some<Result<T>>) {
      return (this as Some<Ok<T>>).swap();
    }
    return (this as None<Ok<T>>).swap();
  }
}

extension $OptionErrSwapExtension<T extends Object> on Option<Err<T>> {
  @pragma('vm:prefer-inline')
  Err<Option<T>> swap() {
    if (this is Some<Result<T>>) {
      return (this as Some<Err<T>>).swap();
    }
    return (this as None<Err<T>>).swap();
  }
}

// --------------------------------------------------
// Source: ./lib/src/ergonomics/flatten/flatten_option.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $FlattenOption2<T extends Object> on Option<Option<T>> {
  @pragma('vm:prefer-inline')
  Option<T> flatten() => flatten2();

  @protected
  Option<T> flatten2() {
    switch (this) {
      case Some(value: final innerResult):
        return innerResult;
      case None():
        return const None();
    }
  }
}

extension $FlattenOption3<T extends Object> on Option<Option<Option<T>>> {
  @pragma('vm:prefer-inline')
  Option<T> flatten() => flatten3();

  @protected
  @pragma('vm:prefer-inline')
  Option<T> flatten3() => flatten2().flatten2();
}

extension $FlattenOption4<T extends Object> on Option<Option<Option<Option<T>>>> {
  @pragma('vm:prefer-inline')
  Option<T> flatten() => flatten4();

  @protected
  @pragma('vm:prefer-inline')
  Option<T> flatten4() => flatten3().flatten2();
}

extension $FlattenOption5<T extends Object> on Option<Option<Option<Option<Option<T>>>>> {
  @pragma('vm:prefer-inline')
  Option<T> flatten() => flatten5();

  @protected
  @pragma('vm:prefer-inline')
  Option<T> flatten5() => flatten4().flatten2();
}

extension $FlattenOption6<T extends Object> on Option<Option<Option<Option<Option<Option<T>>>>>> {
  @pragma('vm:prefer-inline')
  Option<T> flatten() => flatten6();

  @protected
  @pragma('vm:prefer-inline')
  Option<T> flatten6() => flatten5().flatten2();
}

extension $FlattenOption7<T extends Object>
    on Option<Option<Option<Option<Option<Option<Option<T>>>>>>> {
  @pragma('vm:prefer-inline')
  Option<T> flatten() => flatten7();

  @protected
  @pragma('vm:prefer-inline')
  Option<T> flatten7() => flatten6().flatten2();
}

extension $FlattenOption8<T extends Object>
    on Option<Option<Option<Option<Option<Option<Option<Option<T>>>>>>>> {
  @pragma('vm:prefer-inline')
  Option<T> flatten() => flatten8();

  @protected
  @pragma('vm:prefer-inline')
  Option<T> flatten8() => flatten7().flatten2();
}

extension $FlattenOption9<T extends Object>
    on Option<Option<Option<Option<Option<Option<Option<Option<Option<T>>>>>>>>> {
  @pragma('vm:prefer-inline')
  Option<T> flatten() => flatten9();

  @protected
  @pragma('vm:prefer-inline')
  Option<T> flatten9() => flatten8().flatten2();
}

// --------------------------------------------------
// Source: ./lib/src/ergonomics/flatten/flatten_resolvable.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $FlattenResolvable2<T extends Object> on Resolvable<Resolvable<T>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten2();

  @protected
  Resolvable<T> flatten2() {
    switch (this) {
      // Case 1: The outer container is a Sync.
      case Sync(value: final outerResult):
        switch (outerResult) {
          // Case 1a: The outer Sync contains an Ok.
          case Ok(value: final innerResolvable):
            // The inner value is the next Resolvable, which we return directly.
            return innerResolvable;
          // Case 1b: The outer Sync contains an Err.
          case final Err<Resolvable<T>> err:
            // Propagate the error, wrapped in a Sync.
            return Sync.err(err.transfErr());
        }

      // Case 2: The outer container is an Async.
      case Async(value: final outerFutureResult):
        return Async(() async {
          final outerResult = await outerFutureResult;
          // After awaiting, we have a Result. Switch on it.
          switch (outerResult) {
            // Case 2a: The outer Async contained an Ok.
            case Ok(value: final innerResolvable):
              // Await the inner Resolvable and return its value.
              return await innerResolvable.unwrap();
            // Case 2b: The outer Async contained an Err.
            case final Err<Resolvable<T>> err:
              // Re-throw the error to be caught by the Async constructor.
              throw err;
          }
        });
    }
  }
}

extension $FlattenResolvable3<T extends Object> on Resolvable<Resolvable<Resolvable<T>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten3();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten3() => flatten2().flatten2();
}

extension $FlattenResolvable4<T extends Object>
    on Resolvable<Resolvable<Resolvable<Resolvable<T>>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten4();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten4() => flatten3().flatten2();
}

extension $FlattenResolvable5<T extends Object>
    on Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<T>>>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten5();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten5() => flatten4().flatten2();
}

extension $FlattenResolvable6<T extends Object>
    on Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<T>>>>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten6();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten6() => flatten5().flatten2();
}

extension $FlattenResolvable7<T extends Object>
    on Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<T>>>>>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten7();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten7() => flatten6().flatten2();
}

extension $FlattenResolvable8<T extends Object> on Resolvable<
    Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<T>>>>>>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten8();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten8() => flatten7().flatten2();
}

extension $FlattenResolvable9<T extends Object> on Resolvable<
    Resolvable<
        Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<T>>>>>>>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten9();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten9() => flatten8().flatten2();
}

// --------------------------------------------------
// Source: ./lib/src/ergonomics/flatten/flatten_result.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $FlattenResult2<T extends Object> on Result<Result<T>> {
  @pragma('vm:prefer-inline')
  Result<T> flatten() => flatten2();

  @protected
  Result<T> flatten2() {
    switch (this) {
      case Ok(value: final innerResult):
        return innerResult;
      case Err err:
        return err.transfErr();
    }
  }
}

extension $FlattenResult3<T extends Object> on Result<Result<Result<T>>> {
  @pragma('vm:prefer-inline')
  Result<T> flatten() => flatten3();

  @protected
  @pragma('vm:prefer-inline')
  Result<T> flatten3() => flatten2().flatten2();
}

extension $FlattenResult4<T extends Object> on Result<Result<Result<Result<T>>>> {
  @pragma('vm:prefer-inline')
  Result<T> flatten() => flatten4();

  @protected
  @pragma('vm:prefer-inline')
  Result<T> flatten4() => flatten3().flatten2();
}

extension $FlattenResult5<T extends Object> on Result<Result<Result<Result<Result<T>>>>> {
  @pragma('vm:prefer-inline')
  Result<T> flatten() => flatten5();

  @protected
  @pragma('vm:prefer-inline')
  Result<T> flatten5() => flatten4().flatten2();
}

extension $FlattenResult6<T extends Object> on Result<Result<Result<Result<Result<Result<T>>>>>> {
  @pragma('vm:prefer-inline')
  Result<T> flatten() => flatten6();

  @protected
  @pragma('vm:prefer-inline')
  Result<T> flatten6() => flatten5().flatten2();
}

extension $FlattenResult7<T extends Object>
    on Result<Result<Result<Result<Result<Result<Result<T>>>>>>> {
  @pragma('vm:prefer-inline')
  Result<T> flatten() => flatten7();

  @protected
  @pragma('vm:prefer-inline')
  Result<T> flatten7() => flatten6().flatten2();
}

extension $FlattenResult8<T extends Object>
    on Result<Result<Result<Result<Result<Result<Result<Result<T>>>>>>>> {
  @pragma('vm:prefer-inline')
  Result<T> flatten() => flatten8();

  @protected
  @pragma('vm:prefer-inline')
  Result<T> flatten8() => flatten7().flatten2();
}

extension $FlattenResult9<T extends Object>
    on Result<Result<Result<Result<Result<Result<Result<Result<Result<T>>>>>>>>> {
  @pragma('vm:prefer-inline')
  Result<T> flatten() => flatten9();

  @protected
  @pragma('vm:prefer-inline')
  Result<T> flatten9() => flatten8().flatten2();
}

// --------------------------------------------------
// Source: ./lib/src/ergonomics/flatten/flatten_resolvable_result.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $FlattenResolvableResult2<T extends Object> on Resolvable<Result<T>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten2();

  @protected
  Resolvable<T> flatten2() {
    switch (value) {
      case Future<Result<Result<T>>> value:
        return Async(() async {
          return (await value).flatten2().unwrap();
        });
      default:
        return Sync(() {
          return (value as Result<Result<T>>).flatten2().unwrap();
        });
    }
  }
}

extension $FlattenResolvableResulte3<T extends Object> on Resolvable<Result<Result<T>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten3();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten3() => flatten2().flatten2();
}

extension $FlattenResolvableResulte4<T extends Object> on Resolvable<Result<Result<Result<T>>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten4();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten4() => flatten3().flatten2();
}

extension $FlattenResolvableResulte5<T extends Object>
    on Resolvable<Result<Result<Result<Result<T>>>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten5();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten5() => flatten4().flatten2();
}

extension $FlattenResolvableResulte6<T extends Object>
    on Resolvable<Result<Result<Result<Result<Result<T>>>>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten6();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten6() => flatten5().flatten2();
}

extension $FlattenResolvableResulte7<T extends Object>
    on Resolvable<Result<Result<Result<Result<Result<Result<T>>>>>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten7();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten7() => flatten6().flatten2();
}

extension $FlattenResolvableResulte8<T extends Object>
    on Resolvable<Result<Result<Result<Result<Result<Result<Result<T>>>>>>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten8();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten8() => flatten7().flatten2();
}

extension $FlattenResolvableResulte9<T extends Object>
    on Resolvable<Result<Result<Result<Result<Result<Result<Result<Result<T>>>>>>>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten9();

  @protected
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten9() => flatten8().flatten2();
}

// --------------------------------------------------
// Source: ./lib/src/ergonomics/combine_monads.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: must_use_unsafe_wrapper_or_error

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Combines an iterable of [Resolvable]s into one containing a list of their
/// values.
///
/// The result is an [Async] if any of the [resolvables] are `Async`.
/// If any resolvable contains an [Err], applies [onErr] to combine errors.
Resolvable<List<T>> combineResolvable<T extends Object>(
  Iterable<Resolvable<T>> resolvables, {
  @noFuturesAllowed Err<List<T>> Function(List<Result<T>> allResults)? onErr,
}) {
  if (resolvables.isEmpty) {
    return Sync.okValue([]);
  }

  // If any resolvable is async, the result must be async.
  if (resolvables.any((r) => r.isAsync())) {
    final asyncs = resolvables.map((r) => r.toAsync());
    return combineAsync(asyncs, onErr: onErr);
  } else {
    // All are sync, so we can proceed synchronously.
    final syncs = resolvables.map((r) => r as Sync<T>);
    return combineSync(syncs, onErr: onErr);
  }
}

/// Combines an iterable of [Sync]s into one containing a list of their values.
///
/// If any [Sync] contains an [Err], applies the [onErr] function to combine
/// errors.
Sync<List<T>> combineSync<T extends Object>(
  Iterable<Sync<T>> syncs, {
  @noFuturesAllowed Err<List<T>> Function(List<Result<T>> allResults)? onErr,
}) {
  if (syncs.isEmpty) {
    return Sync.okValue([]);
  }

  return Sync(() {
    final results = syncs.map((s) => s.value).toList();
    final combined = combineResult(results, onErr: onErr);
    switch (combined) {
      case Ok(value: final value):
        return value;
      case Err err:
        throw err;
    }
  });
}

/// Combines an iterable of [Async]s into one containing a list of their values.
///
/// The inputs are awaited concurrently. If any resolves to an [Err], applies
/// the [onErr] function to combine errors.
Async<List<T>> combineAsync<T extends Object>(
  Iterable<Async<T>> asyncs, {
  @noFuturesAllowed Err<List<T>> Function(List<Result<T>> allResults)? onErr,
}) {
  if (asyncs.isEmpty) {
    return Async.okValue([]);
  }

  return Async(() async {
    final results = await Future.wait(asyncs.map((a) => a.value));
    final combined = combineResult(results, onErr: onErr);
    switch (combined) {
      case Ok(value: final value):
        return value;
      case Err err:
        throw err;
    }
  });
}

/// Combines an iterable of [Option]s into one containing a list of their values.
///
/// If any [Option] is a [None], the result is a [None].
Option<List<T>> combineOption<T extends Object>(Iterable<Option<T>> options) {
  final values = <T>[];
  for (final option in options) {
    switch (option) {
      case Some(value: final value):
        values.add(value);
      case None():
        return const None();
    }
  }
  return Some(values);
}

/// Combines an iterable of [Result]s into one containing a list of their values.
///
/// If any [Result] is an [Err], applies the [onErr] function to combine errors.
Result<List<T>> combineResult<T extends Object>(
  Iterable<Result<T>> results, {
  @noFuturesAllowed Err<List<T>> Function(List<Result<T>> allResults)? onErr,
}) {
  final successes = <T>[];
  final asList = results.toList();
  for (final result in asList) {
    switch (result) {
      case Ok(value: final value):
        successes.add(value);
      case final Err err:
        if (onErr != null) {
          return onErr(asList);
        } else {
          return err.transfErr();
        }
    }
  }
  return Ok(successes);
}

// --------------------------------------------------
// Source: ./lib/src/ergonomics/unsafe.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Executes a block of code that is considered UNSAFE, allowing the use of
/// methods like `unwrap()`. This function provides no actual safety guarantees;
/// it only serves as a marker for linter rules and to signal to developers
/// that the contained code can throw exceptions from monad operations.
///
/// Use this to explicitly acknowledge that you are handling a potentially
/// failing operation outside the monadic context.
T UNSAFE<T>(@mustBeAnonymous @noFuturesAllowed T Function() block) {
  assert(!isSubtype<T, Future<Object>>(), '$T must never be a Future.');
  try {
    return block();
  } catch (e, _) {
    // We may want to do something here at some point.
    rethrow;
  }
}

// --------------------------------------------------
// Source: ./lib/src/ergonomics/map_monad.dart
// --------------------------------------------------
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/_common.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension $MapMonad2<T extends Object> on Monad<Monad<Object>> {
  @pragma('vm:prefer-inline')
  TResolvableOption<Object> map2<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad3<T extends Object> on Monad<Monad<Monad<Object>>> {
  @pragma('vm:prefer-inline')
  TResolvableOption<Object> map3<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map2((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad4<T extends Object> on Monad<Monad<Monad<Monad<Object>>>> {
  @pragma('vm:prefer-inline')
  TResolvableOption<Object> map4<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map3((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad5<T extends Object> on Monad<Monad<Monad<Monad<Monad<Object>>>>> {
  @pragma('vm:prefer-inline')
  TResolvableOption<Object> map5<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map4((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad6<T extends Object> on Monad<Monad<Monad<Monad<Monad<Monad<Object>>>>>> {
  @pragma('vm:prefer-inline')
  TResolvableOption<Object> map6<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map5((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad7<T extends Object> on Monad<Monad<Monad<Monad<Monad<Monad<Monad<Object>>>>>>> {
  @pragma('vm:prefer-inline')
  TResolvableOption<Object> map7<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map6((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad8<T extends Object>
    on Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Object>>>>>>>> {
  @pragma('vm:prefer-inline')
  TResolvableOption<Object> map8<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map7((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad9<T extends Object>
    on Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Object>>>>>>>>> {
  @pragma('vm:prefer-inline')
  TResolvableOption<Object> map9<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map8((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad10<T extends Object>
    on Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Object>>>>>>>>>> {
  @pragma('vm:prefer-inline')
  TResolvableOption<Object> map10<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map9((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad11<T extends Object>
    on Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Object>>>>>>>>>>> {
  @pragma('vm:prefer-inline')
  TResolvableOption<Object> map11<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map10((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad12<T extends Object>
    on Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Object>>>>>>>>>>>> {
  @pragma('vm:prefer-inline')
  TResolvableOption<Object> map12<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map11((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad13<T extends Object> on Monad<
    Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Object>>>>>>>>>>>>> {
  @pragma('vm:prefer-inline')
  TResolvableOption<Object> map13<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map12((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad14<T extends Object> on Monad<
    Monad<
        Monad<
            Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Object>>>>>>>>>>>>>> {
  @pragma('vm:prefer-inline')
  TResolvableOption<Object> map14<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map13((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad15<T extends Object> on Monad<
    Monad<
        Monad<
            Monad<
                Monad<
                    Monad<
                        Monad<
                            Monad<Monad<Monad<Monad<Monad<Monad<Monad<Monad<Object>>>>>>>>>>>>>>> {
  @pragma('vm:prefer-inline')
  TResolvableOption<Object> map15<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map14((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad16<T extends Object> on Monad<
    Monad<
        Monad<
            Monad<
                Monad<
                    Monad<
                        Monad<
                            Monad<
                                Monad<
                                    Monad<
                                        Monad<Monad<Monad<Monad<Monad<Monad<Object>>>>>>>>>>>>>>>> {
  @pragma('vm:prefer-inline')
  TResolvableOption<Object> map16<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map15((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad17<T extends Object> on Monad<
    Monad<
        Monad<
            Monad<
                Monad<
                    Monad<
                        Monad<
                            Monad<
                                Monad<
                                    Monad<
                                        Monad<
                                            Monad<
                                                Monad<
                                                    Monad<
                                                        Monad<Monad<Monad<Object>>>>>>>>>>>>>>>>> {
  @pragma('vm:prefer-inline')
  TResolvableOption<Object> map17<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map16((e) => mapper(e as T))).reduce();
  }
}

extension $MapMonad18<T extends Object> on Monad<
    Monad<
        Monad<
            Monad<
                Monad<
                    Monad<
                        Monad<
                            Monad<
                                Monad<
                                    Monad<
                                        Monad<
                                            Monad<
                                                Monad<
                                                    Monad<
                                                        Monad<
                                                            Monad<
                                                                Monad<
                                                                    Monad<Object>>>>>>>>>>>>>>>>>> {
  @pragma('vm:prefer-inline')
  TResolvableOption<Object> map18<R extends Object>(R Function(T) mapper) {
    return map((e) => e.map17((e) => mapper(e as T))).reduce();
  }
}

// --------------------------------------------------
// Source: ./lazy_tests/test_safe_sequencer_no_deadlock.dart
// --------------------------------------------------
// import 'package:df_safer_dart/df_safer_dart.dart';

// void main() async {
//   print('Starting sequence...');
//   await sequencer.pushTask(handlerA).end();
//   print('Sequence finished.');

//   // The final execution order should be sequential, not interleaved.
//   print('Execution Order: $executionOrder');
//   // Expected: [A starts, A ends, B starts, B ends, C starts and ends]
// }

// final executionOrder = <String>[];
// final sequencer = SeriesTaskExecutor<int>();

// Resolvable<Option<int>> handlerA(Result<Option<int>> previous) {
//   executionOrder.add('A starts');
//   // Re-entrant call: Schedule B to run after A is done.
//   return sequencer.pushTask(handlerB).map((e) {
//     executionOrder.add('A ends');
//     return e;
//   });
// }

// Resolvable<Option<int>> handlerB(Result<Option<int>> previous) {
//   executionOrder.add('B starts');
//   // Re-entrant call: Schedule C to run after B is done.
//   return sequencer.pushTask(handlerC).map((e) {
//     executionOrder.add('B ends');
//     return e;
//   });
// }

// Resolvable<Option<int>> handlerC(Result<Option<int>> previous) {
//   executionOrder.add('C starts and ends');
//   return Resolvable(() => const Some(3));
// }

// --------------------------------------------------
// Source: ./lazy_tests/test_safe_sequencer_0.dart
// --------------------------------------------------
// import 'package:df_safer_dart/df_safer_dart.dart';

void main() {
  final seq = TaskSequencer();
  seq.then((_) {
    return doWait().toResolvable();
  }).end();
  seq.then((_) {
    return doNotWait().toResolvable();
  }).end();
  seq.then((_) {
    return doWait().toResolvable();
  }).end();
  seq.then((_) {
    return doNotWait().toResolvable();
  }).end();
}

Future<None> doWait() async {
  await Future<void>.delayed(const Duration(milliseconds: 100));
  print('A');
  return const None();
}

None doNotWait() {
  print('B');
  return const None();
}

// --------------------------------------------------
// Source: ./lazy_tests/test_values.dart
// --------------------------------------------------
// import 'package:df_safer_dart/df_safer_dart.dart';

void main() {
  print(const Ok<int>(1).value); // 1
  print(const Ok<int>(1).value.runtimeType); // int
  print(Err<int>('Oh no!').error); // Oh no!
  print(Err<int>('Oh no!').error.runtimeType); // String
  print(Option.from('Hello World!').value); // Hello World!
  print(Option.from('Hello World!').value.runtimeType); // String
  print(const Some('Hello World!').value); // Hello World!
  print(const Some('Hello World!').value.runtimeType); // String
  print(const None<String>().value); // Unit()
  print(const None<String>().value.runtimeType); // Unit
}

// --------------------------------------------------
// Source: ./lazy_tests/test_task_sequencer_1.dart
// --------------------------------------------------
// import 'package:df_safer_dart/df_safer_dart.dart';

void main() {
  final seq = TaskSequencer();
  seq.then((_) {
    print(1);
    return seq.then((_) {
      print(2);
      seq.then((_) {
        print(3);
        return syncNone();
      }).end();
      return seq.then((_) {
        print(4);
        return seq.then((_) {
          print(5);
          return seq.then((_) {
            print(6);
            return seq.then((_) {
              print(7);
              return syncNone();
            });
          });
        });
      });
    });
  }).end();

  seq.then((_) {
    print(8);
    return seq.then((_) {
      print(9);
      return seq.then((_) {
        print(10);
        return seq.then((_) {
          print(11);
          return syncNone();
        });
      });
    });
  }).end();

  seq.then((_) {
    print(12);
    return syncNone();
  }).end();

  seq.then((_) {
    print(13);
    return syncNone();
  }).end();
}

// --------------------------------------------------
// Source: ./lazy_tests/test_safe_sequencer_errors.dart
// --------------------------------------------------
// ignore_for_file: must_use_unsafe_wrapper_or_error
// import 'package:df_safer_dart/df_safer_dart.dart';

void main() {
  UNSAFE:
  TaskSequencer(eagerError: true)
    ..then((prev) {
      print(prev);
      return Sync.okValue(const Some(1));
    })
    ..then((prev) {
      print(prev);
      throw Err('Oh no!');
    })
    ..then(
      (prev) {
        return Sync.okValue(const Some(2));
      },
      eagerError: false,
      onPrevError: (err) {
        print('ERROR!!!');
        return syncNone();
      },
    )
    ..then((prev) {
      print(prev);
      return Sync.okValue(const Some(3));
    }).end();
}

// --------------------------------------------------
// Source: ./more_examples/async_example/lib/main.dart
// --------------------------------------------------
// import 'package:df_safer_dart/df_safer_dart.dart';
// import 'dart:convert';

typedef KeyValueMap = Map<String, dynamic>;

// A network call that can fail. Async handles both success and exceptions.
Async<String> fetchUserData(int userId) => Async(() async {
  await Future<void>.delayed(
    const Duration(milliseconds: 10),
  ); // Simulate network latency
  if (userId == 1) {
    return '{"config":{"notifications":{"sound":"chime.mp3"}}}';
  }
  if (userId == 2) {
    return '{"config":{}}';
  }
  if (userId == 3) {
    return '{"config": "bad_data"}';
  }
  throw Exception(
    'User Not Found',
  ); // This will be caught by Async and become an Err
});

// A parser that can fail. Sync automatically catches the jsonDecode exception.
Sync<KeyValueMap> parseJson(String json) =>
    Sync(() => jsonDecode(json) as KeyValueMap);

// A helper to safely extract a typed value. It cannot fail, it can only be absent,
// so it returns an Option.
Option<T> getFromMap<T extends Object>(KeyValueMap map, String key) {
  final value = map[key];
  return letAsOrNone<T>(value); // A safe-cast helper from the library
}

/// This is the logic pipeline. It reads like a description of the happy path.
/// There are no try-catch blocks and no null checks.
Async<Option<String>> getUserNotificationSound(int userId) {
  return fetchUserData(userId) // Starts with Async<String>
      .map(
        // The .unwrap() here will throw if parseJson created an Err.
        // The Async monad's .map will catch that throw and turn the
        // whole chain into an Err state.
        (jsonString) => parseJson(jsonString).unwrap(),
      )
      .map(
        // This .map only runs if fetching and parsing were successful.
        (data) =>
            // Start the Option chain to safely drill into the data.
            // .flatMap is used to chain functions that return another Option.
            getFromMap<KeyValueMap>(data, 'config')
                .flatMap(
                  (config) => getFromMap<KeyValueMap>(config, 'notifications'),
                )
                .flatMap(
                  (notifications) => getFromMap<String>(notifications, 'sound'),
                ),
      );
}

void main() async {
  for (var id in [1, 2, 3, 4, 5]) {
    print('Processing User ID: $id');

    // Execute the pipeline. `await value` opens the Async box.
    final finalResult = await getUserNotificationSound(id).value;

    switch (finalResult) {
      case Ok(value: final optionSound):
        switch (optionSound) {
          // Success! The value is an Option<String>.
          // Now open the Option box.
          case Some(value: final sound):
            print('  -> Success: Sound setting is "$sound"\n');
          case None():
            print('  -> Success: Sound setting was not specified.\n');
        }
      case Err err:
        // The entire pipeline failed at some point.
        print('  -> Failure: An error occurred: ${err.error}\n');
    }
  }
}

// --------------------------------------------------
// Source: ./more_examples/flutter_exmple/lib/main.dart
// --------------------------------------------------
// import 'package:df_safer_dart/df_safer_dart.dart';
// import 'package:flutter/material.dart';

void main() {
  final err = Err('test');
  print(err);
  runApp(const MaterialApp(home: SizedBox.shrink()));
}

// --------------------------------------------------
// Source: ./more_examples/result_example/lib/main.dart
// --------------------------------------------------
// import 'package:df_safer_dart/df_safer_dart.dart';

// A function that parses a string to an integer, with ZERO try-catch blocks.
// It returns a Sync, which holds a Result<int>.
Sync<int> parseInt(String value) {
  // The Sync monad executes this function.
  // - If int.parse() succeeds, it returns Ok(result).
  // - If int.parse() throws a FormatException, Sync catches it and returns Err(exception).
  return Sync(() => int.parse(value));
}

void main() {
  final syncResult =
      parseInt('100') // This returns a Sync<int> holding an Ok(100)
          .map((number) => number * 2); // .map only runs on the Ok value

  final result1 = syncResult.value; // This returns a Result<int>

  switch (result1) {
    case Ok(value: final number):
      print('Result: $number');
    case Err():
      print('Failed to parse');
  }
  final result2 = parseInt('Hello!').map((number) => number * 2).value;

  switch (result2) {
    case Ok(value: final number):
      print('Result: $number');
    case Err err:
      print('Failed to parse: ${err.error}');
  }
}

// --------------------------------------------------
// Source: ./more_examples/option_example/lib/main.dart
// --------------------------------------------------
// import 'package:df_safer_dart/df_safer_dart.dart';

// A function that might not find a user.
Option<String> findUsername(int id) {
  final users = {1: 'Alice', 2: 'Bob'};
  final username = users[id];
  // Option.from handles the null check for us.
  return Option.from(username);
}

void main() {
  // Chaining operations:
  final result =
      findUsername(1) // This returns Some('Alice')
          .map((name) => name.toUpperCase()); // .map only runs if it's a Some

  // Prints "Username is: ALICE"
  switch (result) {
    case Some(value: final name):
      print('Username is: $name');
    case None():
      print('User not found.');
  }
}

