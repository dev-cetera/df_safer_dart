// Consolidated Imports
import 'package:df_safer_dart/df_safer_dart.dart';
import 'dart:io';
import 'package:path/path.dart' as p;
import 'package:stack_trace/stack_trace.dart';
import 'dart:async' show FutureOr;
import 'package:meta/meta.dart';
import 'dart:async' show Completer, FutureOr;
import 'dart:convert';
import 'dart:collection';
import 'dart:convert' show jsonDecode;
import 'package:equatable/equatable.dart';

// Source: ./example/example.dart
// ignore_for_file: inference_failure_on_instance_creation, strict_raw_type

// import 'package:df_safer_dart/df_safer_dart.dart';

// -----------------------------------------------------------------------------
// THE SCENARIO: A REAL-WORLD PROBLEM
// -----------------------------------------------------------------------------
//
// We need to process a series of user IDs, and for each one, fetch its config,
// parse the JSON, and extract a deeply nested, optional setting:
// `config.notifications.sound`.
//
// This demonstrates how to handle a sequence of fully independent, asynchronous,
// failable pipelines in a purely monadic way, without `await`, `try-catch`,
// `null`, or even `Future`.

// -----------------------------------------------------------------------------
// THE MONADIC PIPELINE
// -----------------------------------------------------------------------------

/// This is the logic pipeline for a single user. It reads like a description of
/// the "happy path," while all potential errors and absent values are handled
/// automatically by the monads.
///
/// It returns an `Async` monad, which encapsulates the entire asynchronous flow.
Async<Option<String>> getUserNotificationSound(int userId) {
  return fetchUserData(userId)
      // 1. `map` chains the next operation. If `fetchUserData` produced an `Err`,
      //    this entire block is skipped, propagating the `Err` state.
      .map(
        // 2. We `unwrap` the synchronous `parseJson` result. If parsing
        //    fails, `unwrap` throws, which the `Async` monad immediately
        //    catches and converts into a failed result for the whole chain.
        (json) => parseJson(json).unwrap(),
      )
      // 3. This is the key monadic pattern for safely accessing nested data.
      .map(
        (data) =>
            // a. Start with the top-level data as `Some`.
            Some(data)
                // b. `flatMap` safely accesses the `config` key.
                //    If `config` is missing or not a Map, `letAsOrNone`
                //    returns `None`, and the rest of the chain is skipped.
                .flatMap((d) => letAsOrNone<Map>(d['config']))
                // c. Chain another `flatMap` to access `notifications`.
                .flatMap((config) => letAsOrNone<Map>(config['notifications']))
                // d. Finally, access `sound`.
                .flatMap(
                  (notifications) =>
                      letAsOrNone<String>(notifications['sound']),
                ),
      );
}

/// Async - Use Case: An operation over time that might fail.
Async<String> fetchUserData(int userId) => Async(() async {
  await Future.delayed(const Duration(milliseconds: 10));
  if (userId == 1) return '{"config":{"notifications":{"sound":"chime.mp3"}}}';
  if (userId == 2) return '{"config":{"notifications":{}}}';
  if (userId == 3) return '{"config":{}}';
  if (userId == 4) return '{"config": "bad_data"}';
  throw Err('User Not Found');
});

/// Sync - Use Case: An immediate operation that might fail (e.g., parsing).
Sync<Map<String, dynamic>> parseJson(String json) =>
    Sync(() => json.decodeJson<Map<String, dynamic>>().unwrap());

// -----------------------------------------------------------------------------
// MAIN EXECUTION (The Pure Monadic Way with `Sequential`)
// -----------------------------------------------------------------------------

void main() {
  print('--- Monadic Pipeline Results using Sequential ---');

  // `Sequential` is the library's tool for managing a series of monadic
  // operations without ever exposing a `Future`.
  final processor = Sequential();
  final userIds = [1, 2, 3, 4, 5];

  // We add each user's processing pipeline to the sequential queue.
  // The `_` in `add((_) => ...)` indicates we don't care about the result
  // of the *previous* operation in the queue, as our tasks are independent.
  for (final id in userIds) {
    processor.add((_) {
      // 1. Run the main pipeline for the current user ID.
      return getUserNotificationSound(id)
          // 2. Chain a final `map` to format the result for display.
          //    This map only runs if the pipeline was successful.
          .map((option) => formatResult(Ok(option)))
          // 3. Use `match` to handle the final `Result` (Ok or Err).
          //    This is the final "exit" from the monad for this one operation.
          .match(
            (successString) {
              print('User $id -> $successString');
              return NONE;
            },
            (err) {
              print('User $id -> ${formatResult(err.transf())}');
              return NONE;
            },
          );
    });
  }
}

/// Helper to safely format the final `Result<Option<String>>`.
String formatResult(Result<Option<String>> result) {
  return result.match(
    (option) => option.match(
      (sound) => '${option.runtimeType}: $sound',
      () => option.runtimeType.toString(),
    ),
    (err) => err.toString(),
  );
}

// Source: ./dart_consolidate.dart
// import 'dart:io';

void main(List<String> arguments) async {
  final sourceDirPath = arguments.firstOrNull ?? '.';
  final sourceDir = Directory(sourceDirPath);

  if (!await sourceDir.exists()) {
    print('Directory does not exist: $sourceDirPath');
    return;
  }

  final outputFile = File('consolidated_output.dart.txt');
  final sink = outputFile.openWrite();
  final imports = <String>{}; // Set to store unique non-local imports

  // Process all files and collect imports
  await _processDirectory(sourceDir, sink, imports);

  // Write imports at the top
  sink.writeln('// Consolidated Imports');
  for (var import in imports) {
    sink.writeln(import);
  }
  sink.writeln();

  // Reprocess files to write their content with commented imports and part directives
  await _writeFileContents(sourceDir, sink);

  await sink.flush();
  await sink.close();
  print('Consolidation complete. Output written to ${outputFile.path}');
}

Future<void> _processDirectory(Directory dir, IOSink sink, Set<String> imports) async {
  await for (final entity in dir.list(recursive: true, followLinks: false)) {
    if (entity is File && entity.path.endsWith('.dart')) {
      await _collectImports(entity, imports);
    }
  }
}

Future<void> _collectImports(File file, Set<String> imports) async {
  final lines = await file.readAsLines();
  for (var line in lines) {
    final trimmedLine = line.trim();
    if (trimmedLine.startsWith('import ')) {
      if (trimmedLine.startsWith("import 'package:") || trimmedLine.startsWith("import 'dart:")) {
        imports.add(line); // Store non-local imports
      }
    }
  }
}

Future<void> _writeFileContents(Directory dir, IOSink sink) async {
  await for (final entity in dir.list(recursive: true, followLinks: false)) {
    if (entity is File && entity.path.endsWith('.dart')) {
      await _processFile(entity, sink);
    }
  }
}

Future<void> _processFile(File file, IOSink sink) async {
  // Write comment with original file path
  sink.writeln('// Source: ${file.path}');

  final lines = await file.readAsLines();
  for (var line in lines) {
    final trimmedLine = line.trim();
    // Comment out import statements and part directives
    if (trimmedLine.startsWith('import ') ||
        trimmedLine.startsWith('part ') ||
        trimmedLine.startsWith('part of ')) {
      sink.writeln('// $line');
    } else {
      sink.writeln(line);
    }
  }
  // Add a newline after each file's content
  sink.writeln();
}

// Source: ./.github/scripts/update_changelog.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'dart:io';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

void main(List<String> args) {
  final version = args.isNotEmpty ? args[0] : '0.1.0';
  final comitMesssage = args.length > 1 ? args[1].replaceFirst('+', '') : '';
  final changelogPath = 'CHANGELOG.md';
  final file = File(changelogPath);
  if (!file.existsSync()) {
    print('$changelogPath does not exist.');
    exit(1);
  }
  var contents = file.readAsStringSync();
  contents = contents.replaceAll('# Changelog', '').trim();
  final sections = extractSections(contents);
  final versionExist = sections.where((e) => e.version == version).isNotEmpty;
  if (versionExist) {
    sections.where((e) => e.version == version).forEach((e) {
      e.addUpdate(comitMesssage);
    });
  } else {
    sections.add(
      _VersionSection(
        version: version,
        releasedAt: DateTime.now().toUtc(),
        updates: {comitMesssage},
      ),
    );
  }
  contents =
      '# Changelog\n\n${(sections.toList()..sort((a, b) {
        return compareVersions(b.version, a.version);
      })).map((e) => e.toString()).join('\n')}';

  file.writeAsStringSync(contents);
  print('Changelog updated with version $version.');
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

Set<_VersionSection> extractSections(String contents) {
  final headerPattern = RegExp(r'## \[\d+\.\d+\.\d+(\+\d+)?\]');
  final allVersionMatches = headerPattern.allMatches(contents).toList();
  final results = <_VersionSection>{};
  for (var i = 0; i < allVersionMatches.length; i++) {
    final start = allVersionMatches[i].end;
    final end = i + 1 < allVersionMatches.length ? allVersionMatches[i + 1].start : contents.length;
    final sectionContents = contents.substring(start, end).trim();
    final lines = sectionContents.split('\n').where((line) => line.isNotEmpty).toList();
    final version = allVersionMatches[i]
        .group(0)!
        .substring(4, allVersionMatches[i].group(0)!.length - 1);
    var releasedAt = DateTime.now().toUtc();
    final updates = <String>{};
    final old = lines
        .map((e) => e.trim())
        .where((e) => e.isNotEmpty)
        .map((e) => e.startsWith('-') ? e.substring(1) : e)
        .map((e) => e.trim())
        .where((e) => e.isNotEmpty);
    for (var line in old) {
      if (line.contains('Released @')) {
        releasedAt = parseReleaseDate(line);
      } else {
        updates.add(line);
      }
    }
    results.add(_VersionSection(version: version, releasedAt: releasedAt, updates: updates));
  }

  return results;
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

class _VersionSection {
  //
  //
  //

  String version;
  DateTime releasedAt;
  Set<String> updates;

  //
  //
  //

  _VersionSection({required this.version, required this.releasedAt, Set<String>? updates})
    : this.updates = updates ?? {};

  //
  //
  //

  void addUpdate(String update) {
    updates.add(update);
    releasedAt = DateTime.now().toUtc();
  }

  //
  //
  //

  @override
  String toString() {
    final updatesString = updates.map((update) => '- $update').join('\n');
    return '## [$version]\n\n- Released @ ${releasedAt.month}/${releasedAt.year} (UTC)\n$updatesString\n';
  }
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

int compareVersions(String version1, String version2) {
  List<int> parseVersion(String version) {
    // Split by the '+' first to handle the build number
    final parts = version.split('+');
    final versionParts = parts[0].split('.').map(int.tryParse).map((e) => e ?? 0).toList();
    // Add the build number as the last part (if it exists)
    if (parts.length > 1) {
      versionParts.add(int.tryParse(parts[1]) ?? 0);
    }
    return versionParts;
  }

  final v1 = parseVersion(version1);
  final v2 = parseVersion(version2);
  final maxLength = v1.length > v2.length ? v1.length : v2.length;
  for (var i = 0; i < maxLength; i++) {
    final part1 = i < v1.length ? v1[i] : 0;
    final part2 = i < v2.length ? v2[i] : 0;
    if (part1 > part2) return 1;
    if (part1 < part2) return -1;
  }
  return 0;
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

DateTime parseReleaseDate(String line) {
  if (line.contains('Released @')) {
    final temp = line.split('Released @').last.trim().replaceAll(' (UTC)', '');
    final parts = temp.split('/');
    if (parts.length == 2) {
      final month = int.tryParse(parts[0]) ?? 1;
      final year = int.tryParse(parts[1]) ?? DateTime.now().year;
      return DateTime.utc(year, month);
    }
  }

  return DateTime.now().toUtc();
}

// Source: ./lib/df_safer_dart.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

/// A package inspired by functional programming designed to enhance the structure, safety, and debuggability of your applications.
library;

export 'src/_src.g.dart';

// Source: ./lib/_lib.g.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// GENERATED - DO NOT MODIFY BY HAND
// See: https://github.com/dev-cetera/df_generate_dart_indexes
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

export './df_safer_dart.dart';
export './src/swap/swap_err.dart';
export './src/swap/swap_async.dart';
export './src/swap/swap_result.dart';
export './src/swap/swap_ok.dart';
export './src/swap/swap_resolvable.dart';
export './src/swap/swap_some.dart';
export './src/swap/swap_sync.dart';
export './src/swap/swap_none.dart';
export './src/swap/swap_option.dart';
export './src/etc/typedefs.dart';
export './src/etc/here.dart';
export './src/etc/sequential.dart';
export './src/etc/lazy.dart';
export './src/etc/finisher.dart';
export './src/utils/safer_map.dart';
export './src/utils/safer_string.dart';
export './src/utils/safer_iterable.dart';
export './src/utils/let_or_non_collections.dart';
export './src/utils/let_or_none.dart';
export './src/utils/let_or_non_map.dart';
export './src/flatten/flatten_option.dart';
export './src/flatten/flatten_resolvable.dart';
export './src/flatten/flatten_result.dart';
export './src/err_model/err_model.dart';
export './src/monads/monad.dart';

// Source: ./lib/src/swap/swap_err.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension ErrSyncSwapX<T extends Object> on Err<Sync<T>> {
  @pragma('vm:prefer-inline')
  Sync<Err<T>> swap() => transfErr<Err<T>>().asSync();
}

extension ErrAsyncSwapX<T extends Object> on Err<Async<T>> {
  @pragma('vm:prefer-inline')
  Async<Err<T>> swap() => transfErr<Err<T>>().asAsync();
}

extension ErrResolvableSwapX<T extends Object> on Err<Resolvable<T>> {
  @pragma('vm:prefer-inline')
  Resolvable<Err<T>> swap() => transfErr<Err<T>>().asSync();
}

extension ErrOptionSwapX<T extends Object> on Err<Option<T>> {
  @pragma('vm:prefer-inline')
  Option<Err<T>> swap() => Some(transfErr<T>());
}

extension ErrSomeSwapX<T extends Object> on Err<Some<T>> {
  @pragma('vm:prefer-inline')
  Some<Err<T>> swap() => Some(transfErr<T>());
}

extension ErrNoneSwapX<T extends Object> on Err<None<T>> {
  @pragma('vm:prefer-inline')
  None<Err<T>> swap() => const None();
}

extension ErrResultSwapX<T extends Object> on Err<Result<T>> {
  @pragma('vm:prefer-inline')
  Result<Err<T>> swap() => Ok(transfErr<T>());
}

extension ErrOkSwapX<T extends Object> on Err<Ok<T>> {
  @pragma('vm:prefer-inline')
  Ok<Err<T>> swap() => Ok(transfErr<T>());
}

// Source: ./lib/src/swap/swap_async.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension AsyncSomeSwapX<T extends Object> on Async<Some<T>> {
  @pragma('vm:prefer-inline')
  Some<Async<T>> swap() => Some(map((e) => e.unwrap()));
}

extension AsyncNoneSwapX<T extends Object> on Async<None<T>> {
  @pragma('vm:prefer-inline')
  None<Async<T>> swap() => const None();
}

extension AsyncOkSwapX<T extends Object> on Async<Ok<T>> {
  @pragma('vm:prefer-inline')
  Ok<Async<T>> swap() => Ok(map((e) => e.unwrap()));
}

// Source: ./lib/src/swap/swap_result.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension ResultSyncSwapX<T extends Object> on Result<Sync<T>> {
  @pragma('vm:prefer-inline')
  Sync<Result<T>> swap() {
    if (this is Ok<Sync<T>>) {
      return (this as Ok<Sync<T>>).swap();
    }
    return (this as Err<Sync<T>>).swap();
  }
}

extension ResultAsyncSwapX<T extends Object> on Result<Async<T>> {
  @pragma('vm:prefer-inline')
  Async<Result<T>> swap() {
    if (this is Ok<Async<T>>) {
      return (this as Ok<Async<T>>).swap();
    }
    return (this as Err<Async<T>>).swap();
  }
}

extension ResultResolvableSwapX<T extends Object> on Result<Resolvable<T>> {
  @pragma('vm:prefer-inline')
  Resolvable<Result<T>> swap() {
    if (this is Ok<Resolvable<T>>) {
      return (this as Ok<Resolvable<T>>).swap();
    }
    return (this as Err<Resolvable<T>>).swap();
  }
}

extension ResultOptionSwapX<T extends Object> on Result<Option<T>> {
  @pragma('vm:prefer-inline')
  Option<Result<T>> swap() {
    if (this is Ok<Option<T>>) {
      return (this as Ok<Option<T>>).swap();
    }
    return (this as Err<Option<T>>).swap();
  }
}

extension ResultSomeSwapX<T extends Object> on Result<Some<T>> {
  @pragma('vm:prefer-inline')
  Some<Result<T>> swap() {
    if (this is Ok<Some<T>>) {
      return (this as Ok<Some<T>>).swap();
    }
    return (this as Err<Some<T>>).swap();
  }
}

extension ResultNoneSwapX<T extends Object> on Result<None<T>> {
  @pragma('vm:prefer-inline')
  Option<Result<T>> swap() {
    if (this is Ok<None<T>>) {
      return (this as Ok<None<T>>).swap();
    }
    return (this as Err<None<T>>).swap();
  }
}

extension ResultOkSwapX<T extends Object> on Result<Ok<T>> {
  @pragma('vm:prefer-inline')
  Ok<Result<T>> swap() {
    if (this is Ok<Ok<T>>) {
      return this as Ok<Ok<T>>;
    }
    return (this as Err<Ok<T>>).swap();
  }
}

extension ResultErrSwapX<T extends Object> on Result<Err<T>> {
  @pragma('vm:prefer-inline')
  Result<T> swap() {
    if (this is Ok<Err<T>>) {
      return (this as Ok<Err<T>>).unwrap();
    }
    return (this as Err<Err<T>>).transfErr();
  }
}

// Source: ./lib/src/swap/swap_ok.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension OkSyncSwapX<T extends Object> on Ok<Sync<T>> {
  @pragma('vm:prefer-inline')
  Sync<Ok<T>> swap() => unwrap().map((e) => Ok(e));
}

extension OkAsyncSwapX<T extends Object> on Ok<Async<T>> {
  @pragma('vm:prefer-inline')
  Async<Ok<T>> swap() => unwrap().map((e) => Ok(e));
}

extension OkResolvableSwapX<T extends Object> on Ok<Resolvable<T>> {
  @pragma('vm:prefer-inline')
  Resolvable<Ok<T>> swap() => unwrap().map((e) => Ok(e));
}

extension OkOptionSwapX<T extends Object> on Ok<Option<T>> {
  @pragma('vm:prefer-inline')
  Option<Ok<T>> swap() => unwrap().map((e) => Ok(e));
}

extension OkSomeSwapX<T extends Object> on Ok<Some<T>> {
  @pragma('vm:prefer-inline')
  Some<Ok<T>> swap() => unwrap().map((e) => Ok(e));
}

extension OkNoneSwapX<T extends Object> on Ok<None<T>> {
  @pragma('vm:prefer-inline')
  None<Ok<T>> swap() => const None();
}

extension OkResultSwapX<T extends Object> on Ok<Result<T>> {
  @pragma('vm:prefer-inline')
  Result<Ok<T>> swap() => unwrap().map((e) => Ok(e));
}

extension OkErrSwapX<T extends Object> on Ok<Err<T>> {
  @pragma('vm:prefer-inline')
  Err<Ok<T>> swap() => unwrap().transfErr<Ok<T>>();
}

// Source: ./lib/src/swap/swap_resolvable.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension ResolvableSomeSwapX<T extends Object> on Resolvable<Some<T>> {
  @pragma('vm:prefer-inline')
  Some<Resolvable<T>> swap() {
    if (this is Sync<Some<T>>) {
      return (this as Sync<Some<T>>).swap();
    }
    return (this as Async<Some<T>>).swap();
  }
}

extension ResolvableNoneSwapX<T extends Object> on Resolvable<None<T>> {
  @pragma('vm:prefer-inline')
  None<Resolvable<T>> swap() => const None();
}

extension ResolvableOkSwapX<T extends Object> on Resolvable<Ok<T>> {
  @pragma('vm:prefer-inline')
  Ok<Resolvable<T>> swap() {
    return Ok(map((e) => e.unwrap()));
  }
}

// Source: ./lib/src/swap/swap_some.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension SomeSyncSwapX<T extends Object> on Some<Sync<T>> {
  @pragma('vm:prefer-inline')
  Sync<Some<T>> swap() => unwrap().map((e) => Some(e));
}

extension SomeAsyncSwapX<T extends Object> on Some<Async<T>> {
  @pragma('vm:prefer-inline')
  Async<Some<T>> swap() => unwrap().map((e) => Some(e));
}

extension SomeResolvableSwapX<T extends Object> on Some<Resolvable<T>> {
  @pragma('vm:prefer-inline')
  Resolvable<Some<T>> swap() => unwrap().map((e) => Some(e));
}

extension SomeOptionSwapX<T extends Object> on Some<Option<T>> {
  @pragma('vm:prefer-inline')
  Option<Some<T>> swap() => unwrap().map((e) => Some(e));
}

extension SomeNoneSwapX<T extends Object> on Some<None<T>> {
  @pragma('vm:prefer-inline')
  None<Some<T>> swap() => const None();
}

extension SomeResultSwapX<T extends Object> on Some<Result<T>> {
  @pragma('vm:prefer-inline')
  Result<Some<T>> swap() => unwrap().map((e) => Some(e));
}

extension SomeOkSwapX<T extends Object> on Some<Ok<T>> {
  @pragma('vm:prefer-inline')
  Ok<Some<T>> swap() => Ok(Some(unwrap().unwrap()));
}

extension SomeErrSwapX<T extends Object> on Some<Err<T>> {
  @pragma('vm:prefer-inline')
  Err<Some<T>> swap() => unwrap().transfErr<Some<T>>();
}

// Source: ./lib/src/swap/swap_sync.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension SyncAsyncSwapX<T extends Object> on Sync<Async<T>> {
  @pragma('vm:prefer-inline')
  Async<Sync<T>> swap() {
    return value.match(
      (value) => Async(() async {
        final innerResult = await value.value;
        return Sync.value(innerResult);
      }),
      (err) {
        final failedSync = Sync.value(err.transfErr<T>());
        return Async.value(Future.value(Ok(failedSync)));
      },
    );
  }
}

extension SyncResolvableSwapX<T extends Object> on Sync<Resolvable<T>> {
  @pragma('vm:prefer-inline')
  Resolvable<Sync<T>> swap() {
    return value.match(
      (value) {
        if (value.isSync()) {
          final sync = value.unwrapSync();
          return Sync.value(Ok(Sync.value(sync.value)));
        } else {
          final async = value.unwrapAsync();
          return Async<Sync<T>>(() async {
            final result = await async.value;
            return Sync.value(result);
          });
        }
      },
      (err) {
        final failedSync = Sync.value(err.transfErr<T>());
        return Sync.value(Ok(failedSync));
      },
    );
  }
}

extension SyncOptionSwapX<T extends Object> on Sync<Option<T>> {
  @pragma('vm:prefer-inline')
  Option<Sync<T>> swap() {
    return value.match(
      (value) => value.match(
        (value) => Sync.value(Ok(value)).asSome(),
        () => const None(),
      ),
      (err) => Sync.value(err.transfErr<T>()).asSome(),
    );
  }
}

extension SyncSomeSwapX<T extends Object> on Sync<Some<T>> {
  @pragma('vm:prefer-inline')
  Some<Sync<T>> swap() => map((e) => e.unwrap()).asSome();
}

extension SyncNoneSwapX<T extends Object> on Sync<None<T>> {
  @pragma('vm:prefer-inline')
  None<Sync<T>> swap() => const None();
}

extension SyncResultSwapX<T extends Object> on Sync<Result<T>> {
  @pragma('vm:prefer-inline')
  Result<Sync<T>> swap() {
    return value.match(
      (value) => value.match(
        (value) => Sync.value(Ok(value)).asOk(),
        (err) => err.transfErr<Sync<T>>(),
      ),
      (err) => err.transfErr<Sync<T>>(),
    );
  }
}

extension SyncOkSwapX<T extends Object> on Sync<Ok<T>> {
  @pragma('vm:prefer-inline')
  Ok<Sync<T>> swap() => Ok(Sync.value(Ok(value.unwrap().unwrap())));
}

extension SyncErrSwapX<T extends Object> on Sync<Err<T>> {
  @pragma('vm:prefer-inline')
  Err<Sync<T>> swap() => value.unwrap().transfErr<Sync<T>>();
}

// Source: ./lib/src/swap/swap_none.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension NoneSyncSwapX<T extends Object> on None<Sync<T>> {
  @pragma('vm:prefer-inline')
  Sync<None<T>> swap() => Ok(None<T>()).asSync();
}

extension NoneAsyncSwapX<T extends Object> on None<Async<T>> {
  @pragma('vm:prefer-inline')
  Async<None<T>> swap() => Ok(None<T>()).asAsync();
}

extension NoneResolvableSwapX<T extends Object> on None<Resolvable<T>> {
  @pragma('vm:prefer-inline')
  Resolvable<None<T>> swap() => Ok(None<T>()).asSync();
}

extension NoneOptionSwapX<T extends Object> on None<Option<T>> {
  @pragma('vm:prefer-inline')
  Option<None<T>> swap() => const Some(None());
}

extension NoneSomeSwapX<T extends Object> on None<Some<T>> {
  @pragma('vm:prefer-inline')
  Some<None<T>> swap() => const Some(None());
}

extension NoneResultSwapX<T extends Object> on None<Result<T>> {
  @pragma('vm:prefer-inline')
  Result<None<T>> swap() => const Ok(None());
}

extension NoneOkSwapX<T extends Object> on None<Ok<T>> {
  @pragma('vm:prefer-inline')
  Ok<None<T>> swap() => const Ok(None());
}

extension NoneErrSwapX<T extends Object> on None<Err<T>> {
  @pragma('vm:prefer-inline')
  Err<None<T>> swap() {
    return Err(const None());
  }
}

// Source: ./lib/src/swap/swap_option.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension OptionSyncSwapX<T extends Object> on Option<Sync<T>> {
  @pragma('vm:prefer-inline')
  Sync<Option<T>> swap() {
    if (this is Some<Sync<T>>) {
      return (this as Some<Sync<T>>).swap();
    }
    return (this as None<Sync<T>>).swap();
  }
}

extension OptionAsyncSwapX<T extends Object> on Option<Async<T>> {
  @pragma('vm:prefer-inline')
  Async<Option<T>> swap() {
    if (this is Some<Async<T>>) {
      return (this as Some<Async<T>>).swap();
    }
    return (this as None<Async<T>>).swap();
  }
}

extension OptionResolvableSwapX<T extends Object> on Option<Resolvable<T>> {
  @pragma('vm:prefer-inline')
  Resolvable<Option<T>> swap() {
    if (this is Some<Resolvable<T>>) {
      return (this as Some<Resolvable<T>>).swap();
    }
    return (this as None<Resolvable<T>>).swap();
  }
}

extension OptionSomeSwapX<T extends Object> on Option<Some<T>> {
  @pragma('vm:prefer-inline')
  Some<Option<T>> swap() {
    if (this is Some<Some<T>>) {
      return this as Some<Some<T>>;
    }
    return (this as None<Some<T>>).swap();
  }
}

extension OptionNoneSwapX<T extends Object> on Option<None<T>> {
  @pragma('vm:prefer-inline')
  Option<T> swap() {
    return const None();
  }
}

extension OptionResultSwapX<T extends Object> on Option<Result<T>> {
  @pragma('vm:prefer-inline')
  Result<Option<T>> swap() {
    if (this is Some<Result<T>>) {
      return (this as Some<Result<T>>).swap();
    }
    return (this as None<Result<T>>).swap();
  }
}

extension OptionOkSwapX<T extends Object> on Option<Ok<T>> {
  @pragma('vm:prefer-inline')
  Ok<Option<T>> swap() {
    if (this is Some<Result<T>>) {
      return (this as Some<Ok<T>>).swap();
    }
    return (this as None<Ok<T>>).swap();
  }
}

extension OptionErrSwapX<T extends Object> on Option<Err<T>> {
  @pragma('vm:prefer-inline')
  Err<Option<T>> swap() {
    if (this is Some<Result<T>>) {
      return (this as Some<Err<T>>).swap();
    }
    return (this as None<Err<T>>).swap();
  }
}

// Source: ./lib/src/etc/typedefs.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

typedef ValueOrNone<T> = (T? value, bool hasValue);
typedef ValueOrErr<T, E> = (T? value, E? err);

// Source: ./lib/src/etc/here.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by DevCetra.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:path/path.dart' as p;
// import 'package:stack_trace/stack_trace.dart';

// import '../_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A utility class for capturing the current code location (file, line,
/// column, member).
///
/// This is useful for debugging and logging purposes, especially when dealing
/// with errors or unexpected states.
final class Here {
  //
  //
  //

  final int initialStackLevel;

  //
  //
  //

  const Here(this.initialStackLevel) : assert(initialStackLevel >= 0);

  /// Returns the [Frame] for the current code location, skipping the initial
  /// stack levels specified by [initialStackLevel].
  ///
  /// Returns `null` if no suitable frame is found.
  Option<Frame> call() {
    final frames = Trace.current().frames;
    for (var i = initialStackLevel; i < frames.length; i++) {
      final frame = frames[i];

      final lineNumber = frame.line;
      final columnNumber = frame.column;
      if (lineNumber != null && columnNumber != null) {
        return Some(frame);
      }
    }
    return const None();
  }

  /// The base path of the code location, typically formatted as
  /// `library/member`.
  ///
  /// This is useful for creating concise identifiers for code locations.
  Option<String> get basepath {
    final frameOpt = call();
    if (frameOpt.isNone()) return const None();
    final frame = frameOpt.unwrap();
    final library = p.basenameWithoutExtension(frame.library);
    final member = frame.member;
    return Some([library, if (member != null) member].join('/'));
  }

  /// The URI of the file in which the code is located.
  ///
  /// This URI will usually have the scheme `dart`, `file`, `http`, or `https`.
  static Option<Uri> get uri {
    return const Here(2)().map((e) => e.uri);
  }

  /// The line number on which the code location is located.
  ///
  /// This can be null, indicating that the line number is unknown or
  /// unimportant.
  static Option<int> get line {
    return const Here(2)().map((e) => Option.fromNullable(e.line)).flatten();
  }

  /// The column number of the code location.
  ///
  /// This can be null, indicating that the column number is unknown or
  /// unimportant.
  static Option<int> get column {
    return const Here(2)().map((e) => Option.fromNullable(e.column)).flatten();
  }

  /// The name of the member in which the code location occurs.
  ///
  /// Anonymous closures are represented as `<fn>` in this member string.
  static Option<String> get member {
    return const Here(2)().map((e) => Option.fromNullable(e.member)).flatten();
  }

  /// Returns a human-friendly description of the library that this stack frame
  /// comes from.
  ///
  /// This will usually be the string form of [uri], but a relative URI will be
  /// used if possible. Data URIs will be truncated.
  static Option<String> get library {
    return const Here(2)().map((e) => e.library);
  }

  /// Returns the name of the package this stack frame comes from, or `null` if
  /// this stack frame doesn't come from a `package:` URL.
  static Option<String> get package {
    return const Here(2)().map((e) => Option.fromNullable(e.package)).flatten();
  }

  /// A human-friendly description of the code location.
  static Option<String> get location {
    return const Here(2)().map((e) => e.location);
  }
}

// Source: ./lib/src/etc/sequential.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'dart:async' show FutureOr;

// import '/df_safer_dart.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

@Deprecated('SafeSequential got renamed to Sequential.')
typedef SafeSequential = Sequential;

/// A queue that manages the execution of functions sequentially, allowing for
/// optional throttling.
class Sequential {
  //
  //
  //

  final Duration? _buffer;

  /// The current value or future in the queue.
  Resolvable<Option> get current => _current;
  late var _current = Resolvable<Option>(() => const None());

  /// Indicates whether the queue is empty or processing.
  bool get isEmpty => _isEmpty;
  bool _isEmpty = true;

  //
  //
  //

  /// Creates an [Sequential] with an optional [buffer] for throttling
  /// execution.
  Sequential({Duration? buffer}) : _buffer = buffer;

  /// Adds multiple [unsafe] functions to the queue for sequential execution.
  /// See [add].
  @pragma('vm:prefer-inline')
  List<Resolvable<Option<T>>> addAll<T extends Object>(
    Iterable<TAddFunction<T>> unsafe, {
    Duration? buffer,
  }) {
    return unsafe
        .map((e) => add<T>(e, buffer: buffer))
        .toList(); // Must be a list, not an Iterable so that the map function is immediately executed.
  }

  /// Adds multiple [functions] to the queue for sequential execution. See
  /// [addSafe].
  @pragma('vm:prefer-inline')
  List<Resolvable<Option<T>>> addAllSafe<T extends Object>(
    Iterable<Resolvable<Option<T>>? Function(Result<Option> previous)>
    functions, {
    Duration? buffer,
  }) {
    return functions
        .map((e) => addSafe<T>(e, buffer: buffer))
        .toList(); // Must be a list, not an Iterable so that the map function is immediately executed.
  }

  /// Adds an [unsafe] function to the queue that processes the previous value.
  /// Applies an optional [buffer] duration to throttle the execution.
  Resolvable<Option<T>> add<T extends Object>(
    TAddFunction<T> unsafe, {
    Duration? buffer,
  }) {
    Resolvable<Option<T>> fn(Result<Option> previous) => Resolvable(() {
      final temp = unsafe(previous);
      if (temp is Option<T>?) {
        return temp ?? const None();
      }
      return temp.then((e) => e ?? const None());
    });
    return addSafe<T>(fn, buffer: buffer);
  }

  /// Adds a [function] to the queue that processes the previous value.
  /// Applies an optional [buffer] duration to throttle the execution.
  Resolvable<Option<T>> addSafe<T extends Object>(
    Resolvable<Option<T>>? Function(Result<Option> previous) function, {
    Duration? buffer,
  }) {
    final buffer1 = buffer ?? _buffer;
    if (buffer1 == null) {
      return _enqueue<T>(function);
    } else {
      return _enqueue<T>((previous) {
        return Resolvable(() async {
          return await Future.wait<dynamic>([
            Future<Resolvable<Option<T>>?>.value(function(previous)),
            Future<void>.delayed(buffer1),
          ]).then(
            (e) =>
                (e.first as Resolvable<Option<T>>?) ??
                Resolvable(() => None<T>()),
          );
        }).flatten();
      });
    }
  }

  /// Eenqueue a [function] without buffering.
  Resolvable<Option<T>> _enqueue<T extends Object>(
    Resolvable<Option<T>>? Function(Result<Option> previous) function,
  ) {
    _isEmpty = false;
    // ignore: invalid_use_of_visible_for_testing_member
    final value = _current.value;
    if (value is Future<Result<Option<Object>>>) {
      _current = Async(() async {
        final temp = function(await value);
        if (temp == null) {
          return _current;
        }
        _isEmpty = true;
        return temp;
      }).flatten();
    } else {
      _current =
          function(value)?.map((e) {
            _isEmpty = true;
            return e;
          }) ??
          _current;
    }
    return _current.transf((e) => e.transf((e) => e as T).unwrap());
  }

  /// Retrieves the last value in the queue.
  Resolvable<None> get last => add((_) => null).map((_) => const None());
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

typedef TFutureOrOption<T extends Object> = FutureOr<Option<T>?>;
typedef TAddFunction<T extends Object> =
    TFutureOrOption<T> Function(Result<Option> previous);

// Source: ./lib/src/etc/lazy.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'package:meta/meta.dart';

// import '../monads/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A class that provides lazy initialization for instances of type [T].
class Lazy<T extends Object> {
  /// Holds the current singleton instance of type [T] or `null` if no
  /// [singleton] instance was created.
  @protected
  Option<Resolvable<T>> currentInstance = const None();

  /// A constructor function that creates instances of type [T].
  final LazyConstructor<T> _constructor;

  Lazy(this._constructor);

  /// Returns the singleton instance [currentInstance], or creating it if necessary.
  @pragma('vm:prefer-inline')
  Resolvable<T> get singleton {
    return (currentInstance.isNone()
            ? currentInstance = Some(_constructor())
            : currentInstance)
        .unwrap();
  }

  /// Returns a new instance of [T] each time, acting as a factory.
  @pragma('vm:prefer-inline')
  Resolvable<T> get factory => _constructor();

  /// Resets the singleton instance, by setting [currentInstance] back to `null`
  /// allowing it to be re-created via [singleton].
  @pragma('vm:prefer-inline')
  void resetSingleton() => currentInstance = const None();
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

typedef LazyConstructor<T extends Object> = Resolvable<T> Function();

// Source: ./lib/src/etc/finisher.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'dart:async' show Completer, FutureOr;

// import '../monads/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

@Deprecated('SafeFinisher got renamed to Finisher.')
typedef SafeFinisher = Finisher;

/// A utility class for managing completion of both synchronous and asynchronous
/// values.
///
/// [Finisher] is similar to a [Completer], but it handles both synchronous
/// and asynchronous results seamlessly.
class Finisher<T extends Object> {
  //
  //
  //

  final _completer = Completer<T>();
  Option<FutureOr<T>> _value = const None();
  bool _isResolving = false;

  //
  //
  //

  /// Completes the operation with the provided [resolvable].
  Resolvable<T> resolve(Resolvable<T> resolvable) {
    if (_isResolving) {
      return Sync.value(Err('SafeFinisher<$T> is already resolving!'));
    }
    _isResolving = true;
    if (isCompleted) {
      return Sync.value(Err('SafeFinisher<$T> is already completed!'));
    }

    return resolvable.resultMap((e) {
      if (e.isOk()) {
        final a = e.unwrap();
        _value = Some(a);
        _completer.complete(a);
        return e;
      } else {
        final err = e.err().unwrap();
        _completer.completeError(err);
        return err;
      }
    });
  }

  /// Completes the operation with the provided [value].
  @pragma('vm:prefer-inline')
  Resolvable<T> finish(FutureOr<T> value) => resolve(Resolvable(() => value));

  /// Returns a [Resolvable] that will complete when this [Finisher] is
  /// completed.
  @pragma('vm:prefer-inline')
  Resolvable<T> resolvable() {
    return Resolvable(
      () => (_value.isSome() ? _value.unwrap() : _completer.future),
    );
  }

  /// Checks if the value has been set or if the [Finisher] is completed.
  @pragma('vm:prefer-inline')
  bool get isCompleted => _completer.isCompleted || _value.isSome();

  /// Transforms the type of the value managed by this [Finisher].
  Finisher<R> transf<R extends Object>([R Function(T e)? transformer]) {
    final finisher = Finisher<R>();
    resolvable().map((e) {
      try {
        final result = transformer != null ? transformer(e) : (e as R);
        finisher.resolve(Sync<R>.value(Ok(result)));
      } catch (e) {
        finisher.resolve(Sync.value(Err('Failed to transform type $T to $R.')));
      }
      return e;
    });
    return finisher;
  }
}

// Source: ./lib/src/utils/helpers.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '/src/_src.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

const NONE = None<Never>();

const SYNC_NONE = Sync.value(Ok(None<Never>()));

const Resolvable<None<Never>> RESOLVABLE_NONE = SYNC_NONE;

@pragma('vm:prefer-inline')
Sync<None<T>> syncNone<T extends Object>() => const Sync.value(Ok(None()));

@pragma('vm:prefer-inline')
Async<None<T>> asyncNone<T extends Object>() =>
    Async.value(Future.value(Ok(None<T>())));

@pragma('vm:prefer-inline')
Resolvable<None<T>> resolvableNone<T extends Object>() => syncNone();

// Source: ./lib/src/utils/safer_map.dart
// import '../monads/monad.dart';

extension SaferMap<K, V extends Object> on Map<K, V> {
  Option<V> getOption(K key) {
    if (containsKey(key)) {
      return Some(this[key]!);
    }
    return const None();
  }

  Option<T> getAndCast<T extends Object>(K key) {
    if (containsKey(key)) {
      final value = this[key];
      if (value is T) {
        return Some(value);
      }
    }
    return const None();
  }
}

// Source: ./lib/src/utils/safer_string.dart
// import '../monads/monad.dart';

// import 'dart:convert';

extension SaferString on String {
  Option<int> toIntOrNone() {
    return Option.fromNullable(int.tryParse(this));
  }

  Option<double> toDoubleOrNone() {
    return Option.fromNullable(double.tryParse(this));
  }

  Option<bool> toBoolOrNone() {
    return Option.fromNullable(bool.tryParse(this, caseSensitive: false));
  }

  Result<T> decodeJson<T extends Object>() {
    try {
      return Ok(jsonDecode(this) as T);
    } catch (e) {
      return Err(e);
    }
  }
}

// Source: ./lib/src/utils/safer_iterable.dart
// import '../monads/monad.dart';

extension SaferIterable<E extends Object> on Iterable<E> {
  Option<E> get firstOrNone {
    final it = iterator;
    if (it.moveNext()) {
      return Some(it.current);
    }
    return const None();
  }

  Option<E> get lastOrNone {
    final it = iterator;
    if (!it.moveNext()) {
      return const None();
    }
    E result;
    do {
      result = it.current;
    } while (it.moveNext());
    return Some(result);
  }

  Option<E> get singleOrNone {
    final it = iterator;
    if (it.moveNext()) {
      final result = it.current;
      if (!it.moveNext()) {
        return Some(result);
      }
    }
    return const None();
  }

  Option<E> firstWhereOrNone(bool Function(E element) test) {
    for (final element in this) {
      if (test(element)) return Some(element);
    }
    return const None();
  }

  Option<E> lastWhereOrNone(bool Function(E element) test) {
    Option<E> result = const None();
    for (final element in this) {
      if (test(element)) {
        result = Some(element);
      }
    }
    return result;
  }

  Option<E> singleWhereOrNone(bool Function(E element) test) {
    Option<E> result = const None();
    for (final element in this) {
      if (test(element)) {
        if (result.isSome()) {
          return const None();
        }
        result = Some(element);
      }
    }
    return result;
  }

  Option<E> reduceOrNone(E Function(E value, E element) combine) {
    final it = iterator;
    if (!it.moveNext()) {
      return const None();
    }
    var value = it.current;
    while (it.moveNext()) {
      value = combine(value, it.current);
    }
    return Some(value);
  }

  Option<E> elementAtOrNone(int index) {
    if (index < 0) return const None();

    var i = 0;
    for (final element in this) {
      if (i == index) {
        return Some(element);
      }
      i++;
    }
    return const None();
  }
}

// Source: ./lib/src/utils/let_or_non_collections.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'dart:collection';

// import '../monads/monad.dart';
// import 'let_or_none.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

Option<Iterable<T>> letIterableOrNone<T extends Object>(dynamic input) {
  if (input is Option<Iterable<T>>) return input;
  if (input is Iterable<T>) return Some(input);
  final rawValue = unwrapOptionOrNull(input);
  if (rawValue == null) return const None();
  if (rawValue is Iterable<T>) return Some(rawValue);
  final sourceIterable = switch (rawValue) {
    Iterable<dynamic> i => Some(i),
    String s => jsonDecodeOrNone<Iterable<dynamic>>(s),
    _ => const None<Iterable<dynamic>>(),
  };
  return sourceIterable.flatMap((e) => letAsOrNone<Iterable<T>>((e)));
}

Option<List<T>> letListOrNone<T extends Object>(dynamic input) {
  if (input is Option<List<T>>) return input;
  if (input is List<T>) return Some(input);

  return letIterableOrNone<T>(input).flatMap((i) => letAsOrNone<List<T>>(i));
}

Option<Set<T>> letSetOrNone<T extends Object>(dynamic input) {
  if (input is Option<Set<T>>) return input;
  if (input is Set<T>) return Some(input);

  return letIterableOrNone<T>(input).flatMap((i) => letAsOrNone<Set<T>>(i));
}

Option<Queue<T>> letQueueOrNone<T extends Object>(dynamic input) {
  if (input is Option<Queue<T>>) return input;
  if (input is Queue<T>) return Some(input);

  return letIterableOrNone<T>(input).flatMap((i) => letAsOrNone<Queue<T>>(i));
}

// Source: ./lib/src/utils/let_or_none.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'dart:convert' show jsonDecode;

// import '../monads/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

dynamic unwrapOptionOrNull(dynamic input) {
  return switch (input) {
    Some(value: final v) => v,
    None() => null,
    _ => input,
  };
}

Option<T> jsonDecodeOrNone<T extends Object>(String input) {
  try {
    final decoded = jsonDecode(input);
    return decoded is T ? Some(decoded) : const None();
  } catch (_) {
    return const None();
  }
}

@pragma('vm:prefer-inline')
Option<T> letAsOrNone<T extends Object>(dynamic input) {
  if (input is T) return Some(input);
  final rawValue = unwrapOptionOrNull(input);
  return rawValue is T ? Some(rawValue) : const None();
}

Option<num> letNumOrNone(dynamic input) {
  if (input is Option<num>) return input;
  if (input is num) return Some(input);

  final rawValue = unwrapOptionOrNull(input);
  if (rawValue is num) return Some(rawValue);
  if (rawValue is String) {
    return Option.fromNullable(num.tryParse(rawValue.trim()));
  }
  if (rawValue is bool) return Some(rawValue ? 1 : 0);

  return const None();
}

@pragma('vm:prefer-inline')
Option<int> letIntOrNone(dynamic input) {
  if (input is Option<int>) return input;
  return letNumOrNone(input).map((n) => n.toInt());
}

@pragma('vm:prefer-inline')
Option<double> letDoubleOrNone(dynamic input) {
  if (input is Option<double>) return input;
  return letNumOrNone(input).map((n) => n.toDouble());
}

Option<bool> letBoolOrNone(dynamic input) {
  if (input is Option<bool>) return input;
  if (input is bool) return Some(input);

  final rawValue = unwrapOptionOrNull(input);
  if (rawValue is bool) return Some(rawValue);
  if (rawValue is num) return Some(rawValue != 0);
  if (rawValue is String) {
    return Option.fromNullable(bool.tryParse(rawValue, caseSensitive: false));
  }

  return const None();
}

Option<Uri> letUriOrNone(dynamic input) {
  if (input is Option<Uri>) return input;
  if (input is Uri) return Some(input);

  final rawValue = unwrapOptionOrNull(input);
  if (rawValue is Uri) return Some(rawValue);
  if (rawValue is String) {
    return Option.fromNullable(Uri.tryParse(rawValue.trim()));
  }

  return const None();
}

Option<DateTime> letDateTimeOrNone(dynamic input) {
  if (input is Option<DateTime>) return input;
  if (input is DateTime) return Some(input);

  final rawValue = unwrapOptionOrNull(input);
  if (rawValue is DateTime) return Some(rawValue);
  if (rawValue is String) {
    return Option.fromNullable(DateTime.tryParse(rawValue.trim()));
  }
  return const None();
}

// Source: ./lib/src/utils/let_or_non_map.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'dart:convert';
// import 'let_or_none.dart';

// import '../monads/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

Option<T> _tryJsonDecode<T extends Object>(String s) {
  try {
    final decoded = jsonDecode(s);
    return decoded is T ? Some(decoded) : const None();
  } catch (_) {
    return const None();
  }
}

Option<Map<K, V>> letMapOrNone<K extends Object, V extends Object>(
  dynamic input,
) {
  if (input is Option<Map<K, V>>) return input;
  if (input is Map<K, V>) return Some(input);
  final rawValue = unwrapOptionOrNull(input);
  if (rawValue == null) return const None();
  if (rawValue is Map<K, V>) return Some(rawValue);
  final sourceMap = switch (rawValue) {
    Map<dynamic, dynamic> m => Some(m),
    String s => _tryJsonDecode<Map<dynamic, dynamic>>(s),
    _ => const None<Map<dynamic, dynamic>>(),
  };
  return sourceMap.flatMap((map) => letAsOrNone<Map<K, V>>(map));
}

// Source: ./lib/src/flatten/flatten_option.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '../monads/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension FlattenOption2<T extends Object> on Option<Option<T>> {
  @pragma('vm:prefer-inline')
  Option<T> flatten() => flatten2();

  Option<T> flatten2() {
    if (isNone()) {
      return const None();
    } else {
      final option = unwrap();
      if (option.isNone()) {
        return const None();
      } else {
        return Some(option.unwrap());
      }
    }
  }
}

extension FlattenOption3<T extends Object> on Option<Option<Option<T>>> {
  @pragma('vm:prefer-inline')
  Option<T> flatten() => flatten3();

  @pragma('vm:prefer-inline')
  Option<T> flatten3() => flatten2().flatten2();
}

extension FlattenOption4<T extends Object>
    on Option<Option<Option<Option<T>>>> {
  @pragma('vm:prefer-inline')
  Option<T> flatten() => flatten4();

  @pragma('vm:prefer-inline')
  Option<T> flatten4() => flatten3().flatten2();
}

extension FlattenOption5<T extends Object>
    on Option<Option<Option<Option<Option<T>>>>> {
  @pragma('vm:prefer-inline')
  Option<T> flatten() => flatten5();

  @pragma('vm:prefer-inline')
  Option<T> flatten5() => flatten4().flatten2();
}

extension FlattenOption6<T extends Object>
    on Option<Option<Option<Option<Option<Option<T>>>>>> {
  @pragma('vm:prefer-inline')
  Option<T> flatten() => flatten6();

  @pragma('vm:prefer-inline')
  Option<T> flatten6() => flatten5().flatten2();
}

extension FlattenOption7<T extends Object>
    on Option<Option<Option<Option<Option<Option<Option<T>>>>>>> {
  @pragma('vm:prefer-inline')
  Option<T> flatten() => flatten7();

  @pragma('vm:prefer-inline')
  Option<T> flatten7() => flatten6().flatten2();
}

extension FlattenOption8<T extends Object>
    on Option<Option<Option<Option<Option<Option<Option<Option<T>>>>>>>> {
  @pragma('vm:prefer-inline')
  Option<T> flatten() => flatten8();

  @pragma('vm:prefer-inline')
  Option<T> flatten8() => flatten7().flatten2();
}

extension FlattenOption9<T extends Object>
    on
        Option<
          Option<Option<Option<Option<Option<Option<Option<Option<T>>>>>>>>
        > {
  @pragma('vm:prefer-inline')
  Option<T> flatten() => flatten9();

  @pragma('vm:prefer-inline')
  Option<T> flatten9() => flatten8().flatten2();
}

// Source: ./lib/src/flatten/flatten_resolvable.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: invalid_use_of_visible_for_testing_member

// import '../monads/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension FlattenResolvable2<T extends Object> on Resolvable<Resolvable<T>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten2();

  Resolvable<T> flatten2() {
    if (value is Result<Resolvable<T>>) {
      return Sync(() {
        final a = value as Result<Resolvable<T>>;
        if (a.isErr()) {
          throw a;
        }
        final b = a.unwrap().value as Result<T>;
        if (b.isErr()) {
          throw b;
        }
        return b.unwrap();
      });
    } else {
      return Async(() async {
        final a = await value;
        if (a.isErr()) {
          throw a;
        }
        final b = await a.unwrap().value;
        if (b.isErr()) {
          throw b;
        }
        return b.unwrap();
      });
    }
  }
}

extension FlattenResolvable3<T extends Object>
    on Resolvable<Resolvable<Resolvable<T>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten3();

  @pragma('vm:prefer-inline')
  Resolvable<T> flatten3() => flatten2().flatten2();
}

extension FlattenResolvable4<T extends Object>
    on Resolvable<Resolvable<Resolvable<Resolvable<T>>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten4();

  @pragma('vm:prefer-inline')
  Resolvable<T> flatten4() => flatten3().flatten2();
}

extension FlattenResolvable5<T extends Object>
    on Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<T>>>>> {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten5();

  @pragma('vm:prefer-inline')
  Resolvable<T> flatten5() => flatten4().flatten2();
}

extension FlattenResolvable6<T extends Object>
    on
        Resolvable<
          Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<T>>>>>
        > {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten6();

  @pragma('vm:prefer-inline')
  Resolvable<T> flatten6() => flatten5().flatten2();
}

extension FlattenResolvable7<T extends Object>
    on
        Resolvable<
          Resolvable<
            Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<T>>>>>
          >
        > {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten7();

  @pragma('vm:prefer-inline')
  Resolvable<T> flatten7() => flatten6().flatten2();
}

extension FlattenResolvable8<T extends Object>
    on
        Resolvable<
          Resolvable<
            Resolvable<
              Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<T>>>>>
            >
          >
        > {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten8();

  @pragma('vm:prefer-inline')
  Resolvable<T> flatten8() => flatten7().flatten2();
}

extension FlattenResolvable9<T extends Object>
    on
        Resolvable<
          Resolvable<
            Resolvable<
              Resolvable<
                Resolvable<Resolvable<Resolvable<Resolvable<Resolvable<T>>>>>
              >
            >
          >
        > {
  @pragma('vm:prefer-inline')
  Resolvable<T> flatten() => flatten9();

  @pragma('vm:prefer-inline')
  Resolvable<T> flatten9() => flatten8().flatten2();
}

// Source: ./lib/src/flatten/flatten_result.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import '../monads/monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

extension FlattenResult2<T extends Object> on Result<Result<T>> {
  @pragma('vm:prefer-inline')
  Result<T> flatten() => flatten2();

  Result<T> flatten2() {
    if (isErr()) {
      return transf();
    } else {
      final result = unwrap();
      if (result.isErr()) {
        return result.transf();
      } else {
        return Ok(result.unwrap());
      }
    }
  }
}

extension FlattenResult3<T extends Object> on Result<Result<Result<T>>> {
  @pragma('vm:prefer-inline')
  Result<T> flatten() => flatten3();

  @pragma('vm:prefer-inline')
  Result<T> flatten3() => flatten2().flatten2();
}

extension FlattenResult4<T extends Object>
    on Result<Result<Result<Result<T>>>> {
  @pragma('vm:prefer-inline')
  Result<T> flatten() => flatten4();

  @pragma('vm:prefer-inline')
  Result<T> flatten4() => flatten3().flatten2();
}

extension FlattenResult5<T extends Object>
    on Result<Result<Result<Result<Result<T>>>>> {
  @pragma('vm:prefer-inline')
  Result<T> flatten() => flatten5();

  @pragma('vm:prefer-inline')
  Result<T> flatten5() => flatten4().flatten2();
}

extension FlattenResult6<T extends Object>
    on Result<Result<Result<Result<Result<Result<T>>>>>> {
  @pragma('vm:prefer-inline')
  Result<T> flatten() => flatten6();

  @pragma('vm:prefer-inline')
  Result<T> flatten6() => flatten5().flatten2();
}

extension FlattenResult7<T extends Object>
    on Result<Result<Result<Result<Result<Result<Result<T>>>>>>> {
  @pragma('vm:prefer-inline')
  Result<T> flatten() => flatten7();

  @pragma('vm:prefer-inline')
  Result<T> flatten7() => flatten6().flatten2();
}

extension FlattenResult8<T extends Object>
    on Result<Result<Result<Result<Result<Result<Result<Result<T>>>>>>>> {
  @pragma('vm:prefer-inline')
  Result<T> flatten() => flatten8();

  @pragma('vm:prefer-inline')
  Result<T> flatten8() => flatten7().flatten2();
}

extension FlattenResult9<T extends Object>
    on
        Result<
          Result<Result<Result<Result<Result<Result<Result<Result<T>>>>>>>>
        > {
  @pragma('vm:prefer-inline')
  Result<T> flatten() => flatten9();

  @pragma('vm:prefer-inline')
  Result<T> flatten9() => flatten8().flatten2();
}

// Source: ./lib/src/err_model/_err_model.g.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// GENERATED - DO NOT MODIFY BY HAND
// See: https://github.com/dev-cetera/df_generate_dart_models
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// ignore_for_file: annotate_overrides
// ignore_for_file: overridden_fields

// part of 'err_model.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// Generated class for [_ErrModel].
class ErrModel {
  //
  //
  //

  /// No description provided.
  final String? type;

  /// No description provided.
  final String? debugPath;

  /// No description provided.
  final String? error;

  /// No description provided.
  final int? statusCode;

  /// No description provided.
  final List<String>? stackTrace;

  /// Constructs a new instance of [ErrModel]
  /// from optional and required parameters.
  const ErrModel({
    required this.type,
    this.debugPath,
    required this.error,
    this.statusCode,
    this.stackTrace,
  });

  /// Creates a copy of this instance, replacing the specified fields.
  ErrModel copyWith({
    String? type,
    String? debugPath,
    String? error,
    int? statusCode,
    List<String>? stackTrace,
  }) {
    return ErrModel(
      type: type ?? this.type,
      debugPath: debugPath ?? this.debugPath,
      error: error ?? this.error,
      statusCode: statusCode ?? this.statusCode,
      stackTrace: stackTrace ?? this.stackTrace,
    );
  }

  /// Creates a copy of this instance, removing the specified fields.
  ErrModel copyWithout({
    bool type = true,
    bool debugPath = true,
    bool error = true,
    bool statusCode = true,
    bool stackTrace = true,
  }) {
    return ErrModel(
      type: type ? this.type : null,
      debugPath: debugPath ? this.debugPath : null,
      error: error ? this.error : null,
      statusCode: statusCode ? this.statusCode : null,
      stackTrace: stackTrace ? this.stackTrace : null,
    );
  }

  /// Returns the value of the [type] field.
  /// If the field is nullable, the return value may be null; otherwise, it
  /// will always return a non-null value.
  @pragma('vm:prefer-inline')
  String get type$ => type!;

  /// Returns the value of the [debugPath] field.
  /// If the field is nullable, the return value may be null; otherwise, it
  /// will always return a non-null value.
  @pragma('vm:prefer-inline')
  String? get debugPath$ => debugPath;

  /// Returns the value of the [error] field.
  /// If the field is nullable, the return value may be null; otherwise, it
  /// will always return a non-null value.
  @pragma('vm:prefer-inline')
  String get error$ => error!;

  /// Returns the value of the [statusCode] field.
  /// If the field is nullable, the return value may be null; otherwise, it
  /// will always return a non-null value.
  @pragma('vm:prefer-inline')
  int? get statusCode$ => statusCode;

  /// Returns the value of the [stackTrace] field.
  /// If the field is nullable, the return value may be null; otherwise, it
  /// will always return a non-null value.
  @pragma('vm:prefer-inline')
  List<String>? get stackTrace$ => stackTrace;
}

// Source: ./lib/src/err_model/err_model.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~
// import 'package:df_generate_dart_models_core/df_generate_dart_models_core.dart';

// part '_err_model.g.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

// @GenerateDartModel(
//   fields: {
//     Field(fieldPath: ['type'], fieldType: String, nullable: false),
//     Field(fieldPath: ['debugPath'], fieldType: String, nullable: true),
//     Field(fieldPath: ['error'], fieldType: String, nullable: false),
//     Field(fieldPath: ['statusCode'], fieldType: int, nullable: true),
//     Field(fieldPath: ['stackTrace'], fieldType: List<String>, nullable: true),
//   },
// )
// ignore: unused_element
abstract class _ErrModel {}

// Source: ./lib/src/monads/monad.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// import 'dart:async' show FutureOr;
// import 'dart:convert';
// import 'package:equatable/equatable.dart';

// import '/df_safer_dart.dart';

// part '_option.dart';
// part '_result.dart';
// part '_resolvable.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

sealed class Monad<T extends Object> implements Equatable {
  const Monad();

  /// Reduces the monad to a [Resolvable] of an [Option] of type [R].
  Resolvable<Option<R>> reduce<R extends Object>() {
    switch (this) {
      case Sync<T> sync:
        final value = sync.value;
        return value.reduce();
      case Async<T> async:
        return _resolveAsync<R>(async);
      case Some<T> some:
        return _resolveValue(some.value);
      case None<T> _:
        return const Sync.value(Ok(None()));
      case Ok<T> ok:
        return _resolveValue(ok.value);
      case Err<T> err:
        return Sync(() => throw err);
    }
  }

  @pragma('vm:prefer-inline')
  Resolvable<Option<R>> _resolveAsync<R extends Object>(Async<T> async) {
    return Async(() async {
      final test = await async.value.then((e) {
        final test = e.reduce();
        return test.value;
      });
      if (test.isErr()) {
        throw test;
      }
      try {
        return test.unwrap().transf<R>().unwrap();
      } catch (_) {
        throw Err<T>('Cannot resolve $T to $R.');
      }
    });
  }

  @pragma('vm:prefer-inline')
  Resolvable<Option<R>> _resolveValue<R extends Object>(T value) {
    if (value is Monad) {
      return value.reduce();
    } else {
      return Resolvable(() {
        try {
          return Some(value as R);
        } catch (_) {
          throw Err<T>('Cannot resolve $T to $R.');
        }
      });
    }
  }

  Some<Monad<T>> wrapSome();

  Ok<Monad<T>> wrapOk();

  Resolvable<Monad<T>> wrapResolvable();

  Sync<Monad<T>> wrapSync();

  Async<Monad<T>> wrapAsync();
}

// Source: ./lib/src/monads/_resolvable.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// part of 'monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represents a value which can be resolved either synchronously
/// [Sync] or asynchronously [Async]. The value of a [Sync] is never a [Future]
/// while the value of an [Async] is always a [Future].
sealed class Resolvable<T extends Object> extends Monad<T> {
  /// The underlying value, which is a `FutureOr` of a [Result].
  final FutureOr<Result<T>> value;

  const Resolvable.value(this.value);

  /// Creates a [Sync] or [Async] depending on the return type of [unsafe].
  factory Resolvable(
    FutureOr<T> Function() unsafe, {
    Err<T> Function(Object? error)? onError,
    void Function()? onFinalize,
  }) {
    final result = unsafe();
    if (result is Future<T>) {
      return Async(() => result, onError: onError, onFinalize: onFinalize);
    } else {
      return Sync(() => result, onError: onError, onFinalize: onFinalize);
    }
  }

  /// Returns this as an [Resolvable].
  @pragma('vm:prefer-inline')
  Resolvable<T> asResolvable() => this;

  /// Converts this [Resolvable] to an [Async].
  Async<T> asAsync();

  /// Returns this [Resolvable] as a [Some].
  Some<Resolvable<T>> asSome();

  /// Returns this [Resolvable] as a [None].
  None<Resolvable<T>> asNone();

  /// Returns this [Resolvable] as an [Ok].
  Ok<Resolvable<T>> asOk();

  /// Returns `true` if this is a [Sync] instance.
  bool isSync();

  /// Returns `true` if this is an [Async] instance.
  bool isAsync();

  /// Performs a side-effect if this is a [Sync].
  Resolvable<T> ifSync(void Function(Sync<T> sync) unsafe);

  /// Performs a side-effect if this is an [Async].
  Resolvable<T> ifAsync(void Function(Async<T> async) unsafe);

  /// Returns a [Result] containing the [Sync] instance if it is one.
  Result<Sync<T>> sync();

  /// Returns a [Result] containing the [Async] instance if it is one.
  Result<Async<T>> async();

  /// Returns the contained [Ok] value, resolving the [Future] if necessary.
  FutureOr<T> unwrap();

  /// Unwraps the [Sync] instance and returns its value. Throws if not [Sync].
  @pragma('vm:prefer-inline')
  Sync<T> unwrapSync() => sync().unwrap();

  /// Unwraps the [Async] instance and returns its value. Throws if not [Async].
  @pragma('vm:prefer-inline')
  Async<T> unwrapAsync() => async().unwrap();

  /// Maps the contained [Ok] value to a new value.
  Resolvable<R> map<R extends Object>(R Function(T value) unsafe);

  /// Chains [Resolvable] computations by applying a function to the inner [Result].
  Resolvable<R> resultMap<R extends Object>(
    Result<R> Function(Result<T> value) mapper,
  );

  /// Maps the contained [Ok] value using a function that returns a `FutureOr`.
  Resolvable<R> mapFutureOr<R extends Object>(
    FutureOr<R> Function(T value) unsafe,
  );

  /// Handles [Sync] and [Async] cases to produce a new [Resolvable].
  Resolvable<Object> fold(
    Resolvable<Object>? Function(Sync<T> sync) onSync,
    Resolvable<Object>? Function(Async<T> async) onAsync,
  );

  /// Exhaustively handles [Ok] and [Err] cases, returning a final value.
  Resolvable<Object> foldResult(
    Result<Object>? Function(Ok<T> ok) onOk,
    Result<Object>? Function(Err<T> err) onErr,
  );

  /// Exhaustively handles [Ok] and [Err] cases, returning a final value.
  FutureOr<R> match<R extends Object>(
    R Function(T value) onOk,
    R Function(Err<T> err) onErr,
  );

  /// Converts this [Resolvable] to a [Sync]. Throws if it's an [Async].
  Sync<T> toSync();

  /// Converts this [Resolvable] to an [Async].
  Async<T> toAsync();

  /// Returns the contained [Ok] value or `null`, resolving the [Future] if necessary.
  Future<T?> orNull();

  /// Returns this if it's [Sync], otherwise returns [other].
  Resolvable<Object> syncOr<R extends Object>(Resolvable<R> other);

  /// Returns this if it's [Async], otherwise returns [other].
  Resolvable<Object> asyncOr<R extends Object>(Resolvable<R> other);

  /// Transforms the contained [Ok] value's type from `T` to `R`.
  Resolvable<R> transf<R extends Object>([R Function(T e)? transformer]);

  /// Returns the value as an [Ok] if possible or [None] if there's an error.
  FutureOr<Option<Ok<T>>> ok();

  /// Returns the [Err] if possible or [None] if there is a value.
  FutureOr<Option<Err<T>>> err();

  @override
  @pragma('vm:prefer-inline')
  Some<Resolvable<T>> wrapSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<Resolvable<T>> wrapOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Resolvable<T>> wrapResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<Resolvable<T>> wrapSync() => Sync.value(Ok(this));

  @override
  @pragma('vm:prefer-inline')
  Async<Resolvable<T>> wrapAsync() => Async.value(Future.value(Ok(this)));

  @override
  @pragma('vm:prefer-inline')
  List<Object?> get props => [this.value];

  @override
  @pragma('vm:prefer-inline')
  bool? get stringify => false;
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represnets a [Resolvable] that holds a synchronous [Result].
/// It's [value] is never a [Future].
final class Sync<T extends Object> extends Resolvable<T> {
  @override
  // ignore: overridden_fields
  final Result<T> value;

  /// Creates a [Sync] with a pre-computed [Result].
  const Sync.value(this.value) : super.value(value);

  /// Creates a [Sync] by executing a synchronous function [unsafe].
  factory Sync(
    T Function() unsafe, {
    Err<T> Function(Object? error)? onError,
    void Function()? onFinalize,
  }) {
    return Sync.value(() {
      try {
        return Ok(unsafe());
      } on Err catch (e) {
        return e.transfErr<T>();
      } catch (error) {
        try {
          if (onError == null) {
            rethrow;
          }
          return onError(error);
        } catch (e) {
          return Err<T>(e);
        }
      } finally {
        onFinalize?.call();
      }
    }());
  }

  @override
  @pragma('vm:prefer-inline')
  Async<T> asAsync() => Async.value(Future.value(value));

  @override
  @pragma('vm:prefer-inline')
  Some<Sync<T>> asSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  None<Sync<T>> asNone() => const None();

  @override
  @pragma('vm:prefer-inline')
  Ok<Sync<T>> asOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  bool isSync() => true;

  @override
  @pragma('vm:prefer-inline')
  bool isAsync() => false;

  @override
  @pragma('vm:prefer-inline')
  Sync<T> ifSync(void Function(Sync<T> sync) unsafe) {
    try {
      unsafe(this);
      return this;
    } catch (error) {
      return Sync.value(Err(error));
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Sync<T> ifAsync(void Function(Async<T> async) unsafe) => this;

  @override
  @pragma('vm:prefer-inline')
  Ok<Sync<T>> sync() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Err<Async<T>> async() {
    return Err('Called async() on Sync<$T>.');
  }

  @override
  @pragma('vm:prefer-inline')
  T unwrap() => value.unwrap();

  @override
  @pragma('vm:prefer-inline')
  Sync<R> map<R extends Object>(R Function(T value) unsafe) {
    return Sync(() => value.map((e) => unsafe(e)).unwrap());
  }

  @override
  @pragma('vm:prefer-inline')
  Sync<R> resultMap<R extends Object>(
    Result<R> Function(Result<T> value) mapper,
  ) {
    return Sync.value(mapper(value));
  }

  @override
  @pragma('vm:prefer-inline')
  Resolvable<R> mapFutureOr<R extends Object>(
    FutureOr<R> Function(T value) unsafe,
  ) {
    return Resolvable(() => unsafe(value.unwrap()));
  }

  @override
  Resolvable<Object> fold(
    Resolvable<Object>? Function(Sync<T> sync) onSync,
    Resolvable<Object>? Function(Async<T> async) onAsync,
  ) {
    try {
      return onSync(this) ?? this;
    } catch (error) {
      return Sync.value(Err(error));
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Sync<Object> foldResult(
    Result<Object>? Function(Ok<T> ok) onOk,
    Result<Object>? Function(Err<T> err) onErr,
  ) {
    return Sync.value(value.fold(onOk, onErr));
  }

  @override
  @pragma('vm:prefer-inline')
  FutureOr<R> match<R extends Object>(
    R Function(T value) onOk,
    R Function(Err<T> err) onErr,
  ) {
    return value.match(onOk, onErr);
  }

  @override
  @pragma('vm:prefer-inline')
  Sync<T> toSync() => this;

  @override
  @pragma('vm:prefer-inline')
  Async<T> toAsync() => Async.value(Future.value(value));

  @override
  @pragma('vm:prefer-inline')
  Future<T?> orNull() async => value.orNull();

  @override
  @pragma('vm:prefer-inline')
  Sync<Object> syncOr<R extends Object>(Resolvable<R> other) => this;

  @override
  @pragma('vm:prefer-inline')
  Resolvable<R> asyncOr<R extends Object>(Resolvable<R> other) => other;

  @override
  Sync<R> transf<R extends Object>([R Function(T e)? transformer]) {
    return Sync(() {
      final okOrErr = value.transf<R>(transformer);
      if (okOrErr.isErr()) {
        throw okOrErr;
      }
      return okOrErr.unwrap();
    });
  }

  @override
  @pragma('vm:prefer-inline')
  Option<Ok<T>> ok() => value.ok();

  @override
  @pragma('vm:prefer-inline')
  Option<Err<T>> err() => value.err();

  @override
  @pragma('vm:prefer-inline')
  Some<Sync<T>> wrapSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<Sync<T>> wrapOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Sync<T>> wrapResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<Sync<T>> wrapSync() => Sync.value(Ok(this));

  @override
  @pragma('vm:prefer-inline')
  Async<Sync<T>> wrapAsync() => Async.value(Future.value(Ok(this)));
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represents a [Resolvable] that holds an asynchronous
/// [Result]. It's [value] is always a [Future].
final class Async<T extends Object> extends Resolvable<T> {
  @override
  // ignore: overridden_fields
  final Future<Result<T>> value;

  /// Creates an [Async] with a [Future] of a [Result].
  const Async.value(this.value) : super.value(value);

  /// Creates an [Async] by executing an asynchronous function [unsafe].
  factory Async(
    Future<T> Function() unsafe, {
    Err<T> Function(Object? error)? onError,
    void Function()? onFinalize,
  }) {
    return Async.value(() async {
      try {
        return Ok<T>(await unsafe());
      } on Err catch (e) {
        return e.transfErr<T>();
      } catch (error) {
        try {
          if (onError == null) {
            rethrow;
          }
          return onError(error);
        } catch (e) {
          return Err<T>(e);
        }
      } finally {
        onFinalize?.call();
      }
    }());
  }

  @override
  @pragma('vm:prefer-inline')
  Async<T> asAsync() => this;

  @override
  @pragma('vm:prefer-inline')
  Some<Async<T>> asSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  None<Async<T>> asNone() => const None();

  @override
  @pragma('vm:prefer-inline')
  Ok<Async<T>> asOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  bool isSync() => false;

  @override
  @pragma('vm:prefer-inline')
  bool isAsync() => true;

  @override
  @pragma('vm:prefer-inline')
  Async<T> ifSync(void Function(Sync<T> async) unsafe) => this;

  @override
  @pragma('vm:prefer-inline')
  Async<T> ifAsync(void Function(Async<T> async) unsafe) {
    try {
      unsafe(this);
      return this;
    } catch (error) {
      return Async.value(Future.value(Err(error)));
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Err<Sync<T>> sync() {
    return Err('Called sync() on Async<$T>.');
  }

  @override
  @pragma('vm:prefer-inline')
  Ok<Async<T>> async() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Future<T> unwrap() => value.then((e) => e.unwrap());

  @override
  @pragma('vm:prefer-inline')
  Async<R> map<R extends Object>(R Function(T value) unsafe) {
    return Async.value(value.then((e) => e.map(unsafe)));
  }

  @override
  Async<R> resultMap<R extends Object>(
    Result<R> Function(Result<T> value) mapper,
  ) {
    return Async(() async {
      final a = await value;
      if (a.isErr()) {
        throw a;
      }
      final b = mapper(a);
      if (b.isErr()) {
        throw b;
      }
      return b.unwrap();
    });
  }

  @override
  @pragma('vm:prefer-inline')
  Async<R> mapFutureOr<R extends Object>(FutureOr<R> Function(T value) unsafe) {
    return Async(() async => unsafe((await value).unwrap()));
  }

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Object> fold(
    Resolvable<Object>? Function(Sync<T> sync) onSync,
    Resolvable<Object>? Function(Async<T> async) onAsync,
  ) {
    try {
      return onAsync(this) ?? this;
    } catch (error) {
      return Async.value(Future.value(Err(error)));
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Async<Object> foldResult(
    Result<Object>? Function(Ok<T> ok) onOk,
    Result<Object>? Function(Err<T> err) onErr,
  ) {
    return this..resultMap((e) => e.fold(onOk, onErr));
  }

  @override
  @pragma('vm:prefer-inline')
  Future<R> match<R extends Object>(
    R Function(T value) onOk,
    R Function(Err<T> err) onErr,
  ) {
    return value.then((e) => e.match(onOk, onErr));
  }

  @override
  @pragma('vm:prefer-inline')
  Sync<T> toSync() {
    throw Err<T>('Called toSync() on Async<$T>.').addStackLevel();
  }

  @override
  @pragma('vm:prefer-inline')
  Async<T> toAsync() => this;

  @override
  @pragma('vm:prefer-inline')
  Future<T?> orNull() => value.then((e) => e.orNull());

  @override
  Async<R> transf<R extends Object>([R Function(T e)? transformer]) {
    return Async(() async {
      final okOrErr = (await value).transf<R>(transformer);
      if (okOrErr.isErr()) {
        throw okOrErr;
      }
      return okOrErr.unwrap();
    });
  }

  @override
  @pragma('vm:prefer-inline')
  Resolvable<R> syncOr<R extends Object>(Resolvable<R> other) => other;

  @override
  @pragma('vm:prefer-inline')
  Async<Object> asyncOr<R extends Object>(Resolvable<R> other) => this;

  @override
  @pragma('vm:prefer-inline')
  Future<Option<Ok<T>>> ok() => value.then((e) => e.ok());

  @override
  @pragma('vm:prefer-inline')
  Future<Option<Err<T>>> err() => value.then((e) => e.err());

  @override
  @pragma('vm:prefer-inline')
  Some<Async<T>> wrapSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<Async<T>> wrapOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Async<T>> wrapResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<Async<T>> wrapSync() => Sync.value(Ok(this));

  @override
  @pragma('vm:prefer-inline')
  Async<Async<T>> wrapAsync() => Async.value(Future.value(Ok(this)));
}

// Source: ./lib/src/monads/_option.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// part of 'monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represents either [Some] value or [None], the absense of a
/// value.
sealed class Option<T extends Object> extends Monad<T> {
  const Option._();

  /// Creates an [Option] from a nullable value.
  factory Option.fromNullable(T? value) {
    if (value != null) {
      return Some(value);
    } else {
      return const None();
    }
  }

  /// Returns this as an [Option].
  @pragma('vm:prefer-inline')
  Option<T> asOption() => this;

  /// Returns this [Option] as an [Ok].
  Ok<Option<T>> asOk();

  /// Converts this [Option] to an [Async] monad.
  @pragma('vm:prefer-inline')
  Async<Option<T>> asAsync() => Async.value(Future.value(Ok(this)));

  /// Converts this [Option] to a [Sync] monad.
  @pragma('vm:prefer-inline')
  Sync<Option<T>> asSync() => Sync.value(Ok(this));

  /// Returns `true` if this is a [Some].
  bool isSome();

  /// Returns `true` if this is a [None].
  bool isNone();

  /// Returns a [Result] containing this instance if it's a [Some].
  Result<Some<T>> some();

  /// Returns a [Result] containing this instance if it's a [None].
  Result<None<T>> none();

  /// Performs a side-effect if this is a [Some].
  Result<Option<T>> ifSome(void Function(Some<T> some) unsafe);

  /// Performs a side-effect if this is a [None].
  Result<Option<T>> ifNone(void Function() unsafe);

  /// Returns the contained value. Throws if this is a [None].
  T unwrap({int stackLevel = 1});

  /// Returns the contained value or a provided fallback.
  T unwrapOr(T fallback);

  /// Returns the contained value or computes it from a function.
  @pragma('vm:prefer-inline')
  T unwrapOrElse(T Function() unsafe) => unwrapOr(unsafe());

  /// Returns the contained value or `null`.
  T? orNull();

  /// Maps an `Option<T>` to `Option<R>` by applying the [mapper] function.
  Option<R> map<R extends Object>(R Function(T value) mapper);

  /// Maps an `Option<T>` to `Option<R>` by applying the [mapper] function.
  Option<R> flatMap<R extends Object>(Option<R> Function(T value) mapper) {
    if (isSome()) {
      return mapper(unwrap());
    } else {
      return const None();
    }
  }

  /// Returns [None] if the [Option] is [None], or if the predicate returns `false`.
  Option<T> filter(bool Function(T value) test);

  /// Chains [Option] instances by handling [Some] and [None] cases.
  Result<Option<Object>> fold(
    Option<Object>? Function(Some<T> some) onSome,
    Option<Object>? Function(None<T> none) onNone,
  );

  /// Exhaustively handles [Some] and [None] cases, returning a new value.
  R match<R extends Object>(R Function(T value) onSome, R Function() onNone);

  /// Returns this if it's [Some], otherwise returns [other].
  Option<Object> someOr<R extends Object>(Option<R> other);

  /// Returns this if it's [None], otherwise returns [other].
  Option<Object> noneOr<R extends Object>(Option<R> other);

  /// Transforms the [Some] value's type.
  Result<Option<R>> transf<R extends Object>([R Function(T e)? transformer]);

  @override
  @pragma('vm:prefer-inline')
  Some<Option<T>> wrapSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<Option<T>> wrapOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Option<T>> wrapResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<Option<T>> wrapSync() => Sync.value(Ok(this));

  @override
  @pragma('vm:prefer-inline')
  Async<Option<T>> wrapAsync() => Async.value(Future.value(Ok(this)));
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represents an [Option] that contains a [value].
final class Some<T extends Object> extends Option<T> {
  final T value;

  const Some(this.value) : super._();

  @override
  @pragma('vm:prefer-inline')
  Ok<Some<T>> asOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  bool isSome() => true;

  @override
  @pragma('vm:prefer-inline')
  bool isNone() => false;

  @override
  @pragma('vm:prefer-inline')
  Ok<Some<T>> some() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Err<None<T>> none() {
    return Err('Called none() on Some<$T>.');
  }

  @override
  @pragma('vm:prefer-inline')
  Result<Some<T>> ifSome(void Function(Some<T> some) unsafe) {
    try {
      unsafe(this);
      return Ok(this);
    } catch (error) {
      return Err(error);
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Ok<Some<T>> ifNone(void Function() unsafe) => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  T unwrap({int stackLevel = 1}) => value;

  @override
  @pragma('vm:prefer-inline')
  T unwrapOr(T fallback) => value;

  @override
  @pragma('vm:prefer-inline')
  T? orNull() => value;

  @override
  @pragma('vm:prefer-inline')
  Some<R> map<R extends Object>(R Function(T value) mapper) =>
      Some(mapper(value));

  @override
  @pragma('vm:prefer-inline')
  Option<T> filter(bool Function(T value) test) =>
      test(value) ? this : const None();

  @override
  @pragma('vm:prefer-inline')
  Result<Option<Object>> fold(
    Option<Object>? Function(Some<T> some) onSome,
    Option<Object>? Function(None<T> none) onNone,
  ) {
    try {
      return Ok(onSome(this) ?? this);
    } catch (error) {
      return Err(error);
    }
  }

  @override
  @pragma('vm:prefer-inline')
  R match<R extends Object>(R Function(T value) onSome, R Function() onNone) {
    return onSome(this.value);
  }

  @override
  @pragma('vm:prefer-inline')
  Some<T> someOr<R extends Object>(Option<R> other) => this;

  @override
  @pragma('vm:prefer-inline')
  Option<R> noneOr<R extends Object>(Option<R> other) => other;

  @override
  Result<Option<R>> transf<R extends Object>([R Function(T e)? transformer]) {
    try {
      final value0 = unwrap();
      final value1 = transformer?.call(value0) ?? value0 as R;
      return Ok(Option.fromNullable(value1));
    } catch (_) {
      return Err('Cannot transform $T to $R');
    }
  }

  @pragma('vm:prefer-inline')
  None<T> asNone() => const None();

  @override
  @pragma('vm:prefer-inline')
  Some<Some<T>> wrapSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<Some<T>> wrapOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Some<T>> wrapResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<Some<T>> wrapSync() => Sync.value(Ok(this));

  @override
  @pragma('vm:prefer-inline')
  Async<Some<T>> wrapAsync() => Async.value(Future.value(Ok(this)));

  @pragma('vm:prefer-inline')
  @override
  List<Object?> get props => [this.value];

  @pragma('vm:prefer-inline')
  @override
  bool? get stringify => false;
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represents an [Option] that does not contain a value.
final class None<T extends Object> extends Option<T> {
  const None() : super._();

  @override
  @pragma('vm:prefer-inline')
  Ok<None<T>> asOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  bool isSome() => false;

  @override
  @pragma('vm:prefer-inline')
  bool isNone() => true;

  @override
  @pragma('vm:prefer-inline')
  Err<Some<T>> some() {
    return Err('Called some() on None<$T>.');
  }

  @override
  @pragma('vm:prefer-inline')
  Ok<None<T>> none() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<None<T>> ifSome(void Function(Some<T> some) unsafe) => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Result<None<T>> ifNone(void Function() unsafe) {
    try {
      unsafe();
      return Ok(this);
    } catch (error) {
      return Err(error);
    }
  }

  @override
  @pragma('vm:prefer-inline')
  T unwrap({int stackLevel = 1}) {
    throw Err<T>('Called unwrap() on None<$T>.').addStackLevel(stackLevel);
  }

  @override
  @pragma('vm:prefer-inline')
  T unwrapOr(T fallback) => fallback;

  @override
  @pragma('vm:prefer-inline')
  T? orNull() => null;

  @override
  @pragma('vm:prefer-inline')
  None<R> map<R extends Object>(R Function(T value) mapper) => None<R>();

  @override
  @pragma('vm:prefer-inline')
  None<T> filter(bool Function(T value) test) => const None();

  @override
  @pragma('vm:prefer-inline')
  Result<Option<Object>> fold(
    Option<Object>? Function(Some<T> some) onSome,
    Option<Object>? Function(None<T> none) onNone,
  ) {
    try {
      return Ok(onNone(this) ?? this);
    } catch (error) {
      return Err(error);
    }
  }

  @override
  @pragma('vm:prefer-inline')
  R match<R extends Object>(R Function(T value) onSome, R Function() onNone) {
    return onNone();
  }

  @override
  @pragma('vm:prefer-inline')
  Option<Object> someOr<R extends Object>(Option<R> other) => other;

  @override
  @pragma('vm:prefer-inline')
  None<T> noneOr<R extends Object>(Option<R> other) => this;

  @override
  @pragma('vm:prefer-inline')
  Ok<None<R>> transf<R extends Object>([R Function(T e)? transformer]) {
    return const Ok(None());
  }

  @override
  @pragma('vm:prefer-inline')
  Some<None<T>> wrapSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<None<T>> wrapOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<None<T>> wrapResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<None<T>> wrapSync() => Sync.value(Ok(this));

  @override
  @pragma('vm:prefer-inline')
  Async<None<T>> wrapAsync() => Async.value(Future.value(Ok(this)));

  @override
  @pragma('vm:prefer-inline')
  List<Object?> get props => [];

  @override
  @pragma('vm:prefer-inline')
  bool? get stringify => false;
}

// Source: ./lib/src/monads/_result.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// Dart/Flutter (DF) Packages by dev-cetera.com & contributors. The use of this
// source code is governed by an MIT-style license described in the LICENSE
// file located in this project's root directory.
//
// See: https://opensource.org/license/mit
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

// part of 'monad.dart';

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represents either an [Ok] result or an [Error] result.
sealed class Result<T extends Object> extends Monad<T> {
  const Result._();

  /// Returns this as an [Option].
  @pragma('vm:prefer-inline')
  Result<T> asResult() => this;

  /// Adds to the stack trace level for debugging [Err] types.
  Result<T> addStackLevel([int delta = 1]);

  /// Returns this [Result] as a [Some].
  Some<Result<T>> asSome();

  /// Returns this [Result] as a [None].
  None<Result<T>> asNone();

  /// Converts this [Result] to an [Async] monad.
  @pragma('vm:prefer-inline')
  Async<T> asAsync() => Async.value(Future.value(this));

  /// Converts this [Result] to a [Sync] monad.
  @pragma('vm:prefer-inline')
  Sync<T> asSync() => Sync.value(this);

  /// Returns `true` if this is an [Ok].
  bool isOk();

  /// Returns `true` if this is an [Err].
  bool isErr();

  /// Performs a side-effect if this is an [Ok].
  Result<T> ifOk(void Function(Ok<T> ok) unsafe);

  /// Performs a side-effect if this is an [Err].
  Result<T> ifErr(void Function(Err<T> err) unsafe);

  /// Returns an [Option] containing the [Err] if this is an [Err].
  Option<Err<T>> err();

  /// Returns an [Option] containing the [Ok] if this is an [Ok].
  Option<Ok<T>> ok();

  /// Returns the contained [Ok] value. Throws an [Err] if this is an [Err].
  T unwrap({int stackLevel = 1});

  /// Returns the contained [Ok] value or a provided fallback.
  T unwrapOr(T fallback);

  /// Returns the contained [Ok] value or computes it from a function.
  @pragma('vm:prefer-inline')
  T unwrapOrElse(T Function() unsafe) => unwrapOr(unsafe());

  /// Returns the contained [Ok] value or `null`.
  T? orNull();

  /// Maps a `Result<T, E>` to `Result<R, E>` by applying a function to a contained [Ok] value.
  Result<R> map<R extends Object>(R Function(T value) mapper);

  /// Maps an `Result<T>` to `Result<R>` by applying the [mapper] function.
  Result<R> flatMap<R extends Object>(Result<R> Function(T value) mapper) {
    if (isOk()) {
      return mapper(unwrap());
    } else {
      return Err('Called flatMap() on Err<$T>.');
    }
  }

  /// Chains [Result] instances by handling [Ok] and [Err] cases.
  Result<Object> fold(
    Result<Object>? Function(Ok<T> ok) onOk,
    Result<Object>? Function(Err<T> err) onErr,
  );

  /// Exhaustively handles [Ok] and [Err] cases, returning a new value.
  R match<R extends Object>(
    R Function(T value) onOk,
    R Function(Err<T> err) onErr,
  );

  /// Combines this [Result] with another, returning a tuple of their values if both are [Ok].
  (Option<T>, Option<R>) and<R extends Object>(Result<R> other);

  /// Returns this if it's [Ok], otherwise returns [other].
  Result<Object> okOr<R extends Object>(Result<R> other);

  /// Returns this if it's [Err], otherwise returns [other].
  Result<Object> errOr<R extends Object>(Result<R> other);

  /// Transforms the [Ok] value's type.
  Result<R> transf<R extends Object>([R Function(T e)? transformer]);

  @override
  @pragma('vm:prefer-inline')
  Some<Result<T>> wrapSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<Result<T>> wrapOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Result<T>> wrapResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<Result<T>> wrapSync() => Sync.value(Ok(this));

  @override
  @pragma('vm:prefer-inline')
  Async<Result<T>> wrapAsync() => Async.value(Future.value(Ok(this)));
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represents a [Result] that represents a non-error [value].
final class Ok<T extends Object> extends Result<T> {
  final T value;
  const Ok(this.value) : super._();

  @override
  @pragma('vm:prefer-inline')
  Ok<T> addStackLevel([int delta = 1]) => this;

  @override
  @pragma('vm:prefer-inline')
  Some<Ok<T>> asSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  None<Ok<T>> asNone() => const None();

  @override
  @pragma('vm:prefer-inline')
  bool isOk() => true;

  @override
  @pragma('vm:prefer-inline')
  bool isErr() => false;

  @override
  @pragma('vm:prefer-inline')
  Result<T> ifOk(void Function(Ok<T> ok) unsafe) {
    try {
      unsafe(this);
      return this;
    } catch (error) {
      return Err(error);
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Ok<T> ifErr(void Function(Err<T> err) unsafe) => this;

  @override
  @pragma('vm:prefer-inline')
  None<Err<T>> err() => const None();

  @override
  @pragma('vm:prefer-inline')
  Some<Ok<T>> ok() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  T unwrap({int stackLevel = 1}) => value;

  @override
  @pragma('vm:prefer-inline')
  T unwrapOr(T fallback) => value;

  @override
  @pragma('vm:prefer-inline')
  T? orNull() => value;

  @override
  @pragma('vm:prefer-inline')
  Result<R> map<R extends Object>(R Function(T value) mapper) =>
      Ok(mapper(value));

  @override
  @pragma('vm:prefer-inline')
  Result<Object> fold(
    Result<Object>? Function(Ok<T> ok) onOk,
    Result<Object>? Function(Err<T> err) onErr,
  ) {
    try {
      return onOk(this) ?? this;
    } catch (error) {
      return Err(error);
    }
  }

  @override
  @pragma('vm:prefer-inline')
  R match<R extends Object>(
    R Function(T value) onOk,
    R Function(Err<T> err) onErr,
  ) {
    return onOk(this.value);
  }

  @override
  @pragma('vm:prefer-inline')
  (Option<T>, Option<R>) and<R extends Object>(Result<R> other) {
    if (other.isOk()) {
      return (Some(this.unwrap()), Some(other.unwrap()));
    } else {
      return (const None(), const None());
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Ok<T> okOr<R extends Object>(Result<R> other) => this;

  @override
  @pragma('vm:prefer-inline')
  Result<R> errOr<R extends Object>(Result<R> other) => other;

  @override
  Result<R> transf<R extends Object>([R Function(T e)? transformer]) {
    try {
      final value0 = unwrap();
      final value1 = transformer?.call(value0) ?? value0 as R;
      return Ok(value1);
    } catch (_) {
      return Err('Cannot transform $T to $R.');
    }
  }

  @override
  @pragma('vm:prefer-inline')
  Some<Ok<T>> wrapSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<Ok<T>> wrapOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Ok<T>> wrapResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<Ok<T>> wrapSync() => Sync.value(Ok(this));

  @override
  @pragma('vm:prefer-inline')
  Async<Ok<T>> wrapAsync() => Async.value(Future.value(Ok(this)));

  @override
  @pragma('vm:prefer-inline')
  List<Object?> get props => [this.value];

  @override
  @pragma('vm:prefer-inline')
  bool? get stringify => false;
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

/// A [Monad] that represents a [Result] that represents an error.
final class Err<T extends Object> extends Result<T> implements Exception {
  late final Option<String> debugPath;
  final Object error;
  final Option<int> statusCode;
  final Option<StackTrace> stackTrace;
  final int _initialStackLevel;

  factory Err(Object error, {int? statusCode}) {
    return Err._internal(error, Option.fromNullable(statusCode), 3);
  }

  Err._internal(this.error, this.statusCode, int initialStackLevel)
    : stackTrace = Some(StackTrace.current),
      _initialStackLevel = initialStackLevel,
      super._() {
    this.debugPath = Here(_initialStackLevel).basepath;
  }

  factory Err.fromModel(ErrModel model) {
    final error = model.error;
    if (error == null) {
      return Err('Error is null!');
    }
    return Err(error, statusCode: model.statusCode ?? -1);
  }

  @override
  Err<T> addStackLevel([int delta = 1]) {
    return Err._internal(error, statusCode, _initialStackLevel + delta + 1);
  }

  @override
  @pragma('vm:prefer-inline')
  Some<Err<T>> asSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  None<Err<T>> asNone() => const None();

  @override
  @pragma('vm:prefer-inline')
  bool isOk() => false;

  @override
  @pragma('vm:prefer-inline')
  bool isErr() => true;

  @override
  @pragma('vm:prefer-inline')
  Err<T> ifOk(void Function(Ok<T> ok) unsafe) => this;

  @override
  @pragma('vm:prefer-inline')
  Err<T> ifErr(void Function(Err<T> err) unsafe) {
    unsafe(this);
    return this;
  }

  @override
  @pragma('vm:prefer-inline')
  Some<Err<T>> err() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  None<Ok<T>> ok() => const None();

  @override
  @pragma('vm:prefer-inline')
  T unwrap({int stackLevel = 1}) {
    throw Err<T>(
      'Called unwrap() on Err<$T>.',
      statusCode: statusCode.orNull(),
    ).addStackLevel(stackLevel);
  }

  @override
  @pragma('vm:prefer-inline')
  T unwrapOr(T fallback) => fallback;

  @override
  @pragma('vm:prefer-inline')
  T? orNull() => null;

  @override
  @pragma('vm:prefer-inline')
  Err<R> map<R extends Object>(R Function(T value) mapper) => transfErr<R>();

  @override
  @pragma('vm:prefer-inline')
  Result<Object> fold(
    Result<Object>? Function(Ok<T> ok) onOk,
    Result<Object>? Function(Err<T> err) onErr,
  ) {
    try {
      return onErr(this) ?? this;
    } catch (error) {
      return Err(error);
    }
  }

  @override
  @pragma('vm:prefer-inline')
  R match<R extends Object>(
    R Function(T value) onOk,
    R Function(Err<T> err) onErr,
  ) {
    return onErr(this);
  }

  @override
  @pragma('vm:prefer-inline')
  (None<T>, None<R>) and<R extends Object>(Result<R> other) {
    return (const None(), const None());
  }

  @override
  @pragma('vm:prefer-inline')
  Result<R> okOr<R extends Object>(Result<R> other) => other;

  @override
  @pragma('vm:prefer-inline')
  Result<T> errOr<R extends Object>(Result<R> other) => this;

  @override
  @pragma('vm:prefer-inline')
  Err<R> transf<R extends Object>([R Function(T e)? transformer]) {
    return transfErr<R>();
  }

  @override
  @pragma('vm:prefer-inline')
  Some<Err<T>> wrapSome() => Some(this);

  @override
  @pragma('vm:prefer-inline')
  Ok<Err<T>> wrapOk() => Ok(this);

  @override
  @pragma('vm:prefer-inline')
  Resolvable<Err<T>> wrapResolvable() => Resolvable(() => this);

  @override
  @pragma('vm:prefer-inline')
  Sync<Err<T>> wrapSync() => Sync.value(Ok(this));

  @override
  @pragma('vm:prefer-inline')
  Async<Err<T>> wrapAsync() => Async.value(Future.value(Ok(this)));

  /// Checks if the contained [error] matches the type [E].
  @pragma('vm:prefer-inline')
  Option<E> matchError<E extends Object>() =>
      error is E ? Some(error as E) : NONE;

  /// Transforms the type [T] without casting [error].
  @pragma('vm:prefer-inline')
  Err<R> transfErr<R extends Object>() {
    return Err(error, statusCode: statusCode.orNull());
  }

  /// Converts this [Err] to an `ErrModel`.
  ErrModel toModel() {
    final type = 'Err<${T.toString()}>';
    final error = _safeToString(this.error);
    return ErrModel(
      type: type,
      debugPath: debugPath.orNull(),
      error: error,
      statusCode: statusCode.orNull(),
    );
  }

  /// Converts this [Err] to a JSON map.
  Map<String, dynamic> toJson() {
    final model = toModel();
    return {
      if (model.type != null) 'type': model.type,
      if (model.debugPath != null) 'debugPath': model.debugPath,
      if (model.error != null) 'error': model.error,
      if (model.statusCode != null) 'statusCode': model.statusCode,
      if (model.stackTrace != null) 'stackTrace': model.stackTrace,
    };
  }

  @override
  @pragma('vm:prefer-inline')
  String toString() {
    final encoder = const JsonEncoder.withIndent('  ');
    return encoder.convert(toJson());
  }

  @override
  @pragma('vm:prefer-inline')
  List<Object?> get props => [debugPath, error, statusCode];

  @override
  @pragma('vm:prefer-inline')
  bool? get stringify => false;
}

// ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░

String _safeToString(Object? obj) {
  try {
    return obj.toString();
  } catch (_) {
    return '${obj.runtimeType}@${obj.hashCode.toRadixString(16)}';
  }
}

// Source: ./lib/src/_src.g.dart
//.title
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//
// GENERATED - DO NOT MODIFY BY HAND
// See: https://github.com/dev-cetera/df_generate_dart_indexes
//
// ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓
//.title~

export './swap/swap_err.dart';
export './swap/swap_async.dart';
export './swap/swap_result.dart';
export './swap/swap_ok.dart';
export './swap/swap_resolvable.dart';
export './swap/swap_some.dart';
export './swap/swap_sync.dart';
export './swap/swap_none.dart';
export './swap/swap_option.dart';
export './etc/typedefs.dart';
export './etc/here.dart';
export './etc/sequential.dart';
export './etc/lazy.dart';
export './etc/finisher.dart';
export './utils/helpers.dart';
export './utils/safer_map.dart';
export './utils/safer_string.dart';
export './utils/safer_iterable.dart';
export './utils/let_or_non_collections.dart';
export './utils/let_or_none.dart';
export './utils/let_or_non_map.dart';
export './flatten/flatten_option.dart';
export './flatten/flatten_resolvable.dart';
export './flatten/flatten_result.dart';
export './err_model/err_model.dart';
export './monads/monad.dart';

